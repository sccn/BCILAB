<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of ParadigmSIFT</title>
  <meta name="keywords" content="ParadigmSIFT">
  <meta name="description" content="">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="#">code</a> &gt; <a href="index.html">paradigms</a> &gt; ParadigmSIFT.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for code/paradigms&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>ParadigmSIFT

</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong></strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>This is a script file. </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">

<li><a href="ParadigmDataflowSimplified.html" class="code" title="">ParadigmDataflowSimplified</a>	</li>
<li><a href="ParadigmSIFT.html" class="code" title="">ParadigmSIFT</a>	</li>
</ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">

<li><a href="ParadigmSIFT.html" class="code" title="">ParadigmSIFT</a>	</li>
</ul>
<!-- crossreference -->


<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">

<li><a href="#_sub1" class="code">function defaults = preprocessing_defaults(self)</a></li>
<li><a href="#_sub2" class="code">function defaults = machine_learning_defaults(self)</a></li>
<li><a href="#_sub3" class="code">function defaults = machine_learning_search_defaults(self)</a></li>
<li><a href="#_sub4" class="code">function model = feature_adapt(self,varargin)</a></li>
<li><a href="#_sub5" class="code">function [features,shape] = feature_extract(self,signal,featuremodel)</a></li>
<li><a href="#_sub6" class="code">function [featuremodel,conditioningmodel,predictivemodel] = calibrate_prediction_function(self,varargin)</a></li>
<li><a href="#_sub7" class="code">function visualize_model(self,varargin)</a></li>
<li><a href="#_sub8" class="code">function layout = dialog_layout_defaults(self)</a></li>
<li><a href="#_sub9" class="code">function tf = needs_voting(self)</a></li>
<li><a href="#_sub10" class="code">function sig = make_continuous(self,sig)</a></li>
</ul>




<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 classdef <a href="ParadigmSIFT.html" class="code" title="">ParadigmSIFT</a> &lt; <a href="ParadigmDataflowSimplified.html" class="code" title="">ParadigmDataflowSimplified</a>
0002     <span class="comment">% Source Information Toolbox adapter paradigm.</span>
0003     <span class="comment">%</span>
0004     <span class="comment">% This paradigm exposes SIFT-derived connectivity features within BCILAB.</span>
0005     <span class="comment">%</span>
0006     <span class="comment">% Name:</span>
0007     <span class="comment">%   Source Information Flow Toolbox Adapter</span>
0008     <span class="comment">%</span>
0009     
0010     
0011     methods
0012       
0013         <a name="_sub0" href="#_subfunctions" class="code">function defaults = preprocessing_defaults(self)</a>
0014             <span class="comment">% define the default pre-processing parameters of this paradigm</span>
0015             defaults = { <span class="keyword">...</span>
0016                 <span class="string">'FilterOrdering'</span>, {<span class="string">'flt_clean_settings'</span>,<span class="string">'flt_ica'</span>,<span class="string">'flt_selchans'</span>,<span class="string">'flt_reref'</span>} <span class="keyword">...</span>
0017                 <span class="string">'Resampling'</span>, { <span class="keyword">...</span>
0018                     <span class="string">'SamplingRate'</span>, 128} <span class="keyword">...</span>
0019                 <span class="string">'DataCleaning'</span>, { <span class="keyword">...</span>
0020                     <span class="string">'DataSetting'</span>, {<span class="string">'1.1-beta'</span> <span class="keyword">...</span>
0021                         <span class="string">'ChannelDropoutRepair'</span>, <span class="string">'off'</span>}} <span class="keyword">...</span>
0022                 <span class="string">'ICA'</span>, { <span class="keyword">...</span>
0023                     <span class="string">'Variant'</span>, <span class="string">'robust_sphere'</span> <span class="keyword">...</span>
0024                     <span class="string">'DataCleaning'</span>, { <span class="keyword">...</span>
0025                         <span class="string">'DataSetting'</span>, <span class="string">'off'</span>} <span class="keyword">...</span>
0026                     <span class="string">'TransformData'</span>, true} <span class="keyword">...</span>
0027                 <span class="string">'ChannelSelection'</span>, { <span class="keyword">...</span>
0028                     <span class="string">'Channels'</span>, {<span class="string">'FP1'</span>,<span class="string">'FP2'</span>,<span class="string">'Fz'</span>,<span class="string">'FCz'</span>,<span class="string">'C3'</span>,<span class="string">'Cz'</span>,<span class="string">'C4'</span>,<span class="string">'PO3'</span>,<span class="string">'POz'</span>,<span class="string">'PO4'</span>,<span class="string">'O1'</span>,<span class="string">'O2'</span>} <span class="keyword">...</span>
0029                     <span class="string">'FindClosest'</span>, true} <span class="keyword">...</span>
0030                 <span class="string">'Rereferencing'</span>, <span class="string">'on'</span> <span class="keyword">...</span>
0031                 <span class="string">'FIRFilter'</span>, { <span class="keyword">...</span>
0032                     <span class="string">'Frequencies'</span>, [45 50] <span class="keyword">...</span>
0033                     <span class="string">'Mode'</span>, <span class="string">'lowpass'</span>} <span class="keyword">...</span>
0034                 <span class="string">'EpochExtraction'</span>, { <span class="keyword">...</span>
0035                     <span class="string">'TimeWindow'</span>, [-0.5 1.5]}};
0036         <span class="keyword">end</span>
0037         
0038         <a name="_sub1" href="#_subfunctions" class="code">function defaults = machine_learning_defaults(self)</a>
0039             defaults = {<span class="string">'proximal'</span> <span class="keyword">...</span>
0040                 <span class="string">'Regularizers'</span>, { <span class="keyword">...</span>
0041                     <span class="string">'Term1'</span>, <span class="string">'l1'</span> <span class="keyword">...</span>
0042                     <span class="string">'Term2'</span>, <span class="string">'l2'</span> <span class="keyword">...</span>
0043                     <span class="string">'Term4'</span>, {<span class="string">'l2'</span> <span class="keyword">...</span>
0044                         <span class="string">'LinearOperator'</span>, <span class="string">'@(x)[vec(diff(x,[],3));vec(diff(x,[],4))]'</span> <span class="keyword">...</span>
0045                         <span class="string">'NonorthogonalTransform'</span>, true} <span class="keyword">...</span>
0046                     <span class="string">'Term5'</span>, {<span class="string">'trace'</span> <span class="keyword">...</span>
0047                         <span class="string">'LinearOperator'</span>, <span class="string">'@(x)reshape(permute(x,[1 2 4 3 5]),a*b*d,c,[])'</span>} <span class="keyword">...</span>
0048                     <span class="string">'Term6'</span>, {<span class="string">'trace'</span> <span class="keyword">...</span>
0049                         <span class="string">'LinearOperator'</span>, <span class="string">'@(x)reshape(x,a*b*c,d,[])'</span>}} <span class="keyword">...</span>
0050                 <span class="string">'TermWeights'</span>, {[1 1 1 1 1]} <span class="keyword">...</span>
0051                 <span class="string">'SolverOptions'</span>, { <span class="keyword">...</span>
0052                     <span class="string">'MaxIterations'</span>, 150 <span class="keyword">...</span>
0053                     <span class="string">'AbsoluteTolerance'</span>, 5e-06 <span class="keyword">...</span>
0054                     <span class="string">'CouplingParameter'</span>, 8} <span class="keyword">...</span>
0055                 <span class="string">'LambdaSearch'</span>, { <span class="keyword">...</span>
0056                     <span class="string">'Lambdas'</span>, [8 5.06302637588112 3.20427951035849 2.02791895958006 1.2834258975629 0.812252396356235 0.514056913328033 0.325335463860483 0.205897754316893 0.13030822010514 0.0824692444233059 0.0521929949642731 0.0330318137675431 0.020905118043533 0.0132303955056645 0.00837323017606479 0.00529923565409247] <span class="keyword">...</span>
0057                     <span class="string">'FoldMargin'</span>, 5 <span class="keyword">...</span>
0058                     <span class="string">'ParameterMetric'</span>, <span class="string">'auc'</span> <span class="keyword">...</span>
0059                     <span class="string">'ReturnRegpath'</span>, false} <span class="keyword">...</span>
0060                 <span class="string">'Verbosity'</span>, 1};
0061         <span class="keyword">end</span>
0062         
0063         <a name="_sub2" href="#_subfunctions" class="code">function defaults = machine_learning_search_defaults(self)</a>
0064             defaults = {<span class="string">'logreg'</span> <span class="keyword">...</span>
0065                 <span class="string">'Lambda'</span>,0.001, <span class="keyword">...</span>
0066                 <span class="string">'Variant'</span>, {<span class="string">'l2'</span> <span class="string">'LambdaSearch'</span>,false}};
0067         <span class="keyword">end</span>
0068         
0069         <a name="_sub3" href="#_subfunctions" class="code">function model = feature_adapt(self,varargin)</a>
0070             <span class="comment">% configure and adapt parameters for SIFT's online pipeline</span>
0071             g = arg_define(varargin, <span class="keyword">...</span>
0072                     arg_norep(<span class="string">'signal'</span>), <span class="keyword">...</span>
0073                     arg_sub({<span class="string">'connPipeline'</span>,<span class="string">'ConnectivityPipeline'</span>}, <span class="keyword">...</span>
0074                         {<span class="keyword">...</span>
0075                         <span class="string">'EEG'</span>,struct(<span class="string">'srcpot'</span>,1,<span class="string">'icaweights'</span>,1), <span class="keyword">...</span>
0076                         <span class="string">'Channels'</span>, {} <span class="keyword">...</span>
0077                         <span class="string">'Preprocessing'</span>, { <span class="keyword">...</span>
0078                             <span class="string">'SignalType'</span>, {<span class="string">'Channels'</span> <span class="keyword">...</span>
0079                                 <span class="string">'ConvertChanlocs2Dipfit'</span>, <span class="string">'off'</span>} <span class="keyword">...</span>
0080                             <span class="string">'NormalizeData'</span>, { <span class="keyword">...</span>
0081                                 <span class="string">'Method'</span>, {<span class="string">'time'</span>}}} <span class="keyword">...</span>
0082                         <span class="string">'Modeling'</span>, {<span class="string">'Segmentation VAR'</span> <span class="keyword">...</span>
0083                             <span class="string">'Algorithm'</span>, {<span class="string">'Group Lasso (ADMM)'</span> <span class="keyword">...</span>
0084                                 <span class="string">'WarmStart'</span>, <span class="string">'on'</span> <span class="keyword">...</span>
0085                                 <span class="string">'NormCols'</span>, <span class="string">'norm'</span> <span class="keyword">...</span>
0086                                 <span class="string">'ADMM_Options'</span>, { <span class="keyword">...</span>
0087                                     <span class="string">'ReguParamLambda'</span>, 0.2 <span class="keyword">...</span>
0088                                     <span class="string">'AugLagrangParamRho'</span>, 2 <span class="keyword">...</span>
0089                                     <span class="string">'MaxIterations'</span>, 300 <span class="keyword">...</span>
0090                                     <span class="string">'LambdaUpdateThreshold'</span>, 0.001 <span class="keyword">...</span>
0091                                     <span class="string">'LambdaUpdateCount'</span>, 5 <span class="keyword">...</span>
0092                                     <span class="string">'RelativeTolerance'</span>, 0.001}} <span class="keyword">...</span>
0093                             <span class="string">'WindowLength'</span>, 0.66 <span class="keyword">...</span>
0094                             <span class="string">'WindowStepSize'</span>, 0.05 <span class="keyword">...</span>
0095                             <span class="string">'Detrend'</span>, { <span class="keyword">...</span>
0096                                 <span class="string">'DetrendingMethod'</span>, <span class="string">'linear'</span>} <span class="keyword">...</span>
0097                             <span class="string">'VerbosityLevel'</span>, 0} <span class="keyword">...</span>
0098                         <span class="string">'AutoSelectModelOrder'</span>, <span class="string">'off'</span> <span class="keyword">...</span>
0099                         <span class="string">'Connectivity'</span>, { <span class="keyword">...</span>
0100                             <span class="string">'ConnectivityMeasures'</span>, {<span class="string">'dDTF08'</span>} <span class="keyword">...</span>
0101                             <span class="string">'Frequencies'</span>, [1:15] <span class="keyword">...</span>
0102                             <span class="string">'VerbosityLevel'</span>, 0} <span class="keyword">...</span>
0103                         <span class="string">'Validation'</span>, <span class="string">'off'</span> <span class="keyword">...</span>
0104                         <span class="string">'PrintValidation'</span>, true}, @onl_siftpipeline,<span class="string">'Connectivity extraction options.'</span>), <span class="keyword">...</span>
0105                     arg_subtoggle({<span class="string">'lambdaSelection'</span>,<span class="string">'RegularizationParameterSelection'</span>},[], { <span class="keyword">...</span>
0106                         arg_sub({<span class="string">'validationMetric'</span>,<span class="string">'ValidationMetric'</span>},{},@est_validateMVAR,<span class="string">'Model validation options. Used for selection optimal lambda (VAR regularization).'</span>), <span class="keyword">...</span>
0107                         arg({<span class="string">'lambdaGrid'</span>,<span class="string">'LambdaGrid'</span>},logspace(log10(1e-5),log10(100),10),[],<span class="string">'Lambda grid. This is a row vector of possible lambda values to search over'</span>,<span class="string">'shape'</span>,<span class="string">'row'</span>) <span class="keyword">...</span>
0108                     },<span class="string">'Options for selecting optimal lambda. This only applies if you are using regularized model fitting methods that accept a &quot;lambda&quot; parameter'</span>), <span class="keyword">...</span>
0109                     arg({<span class="string">'valueFormat'</span>,<span class="string">'ValueFormat'</span>},<span class="string">'log-magnitude'</span>,{<span class="string">'complex'</span>,<span class="string">'components'</span>,<span class="string">'mixed'</span>,<span class="string">'magnitude'</span>,<span class="string">'sqrt-magnitude'</span>,<span class="string">'log-magnitude'</span>,<span class="string">'phase'</span>,<span class="string">'polar'</span>},<span class="string">'Output value format. Formatting for partially complex-valued features. Mixed means as-is, components means to separate real and imaginary components (both as real), magnitude retains only the complex magnitude, phase retains only the phase, and polar retains both magnitude and phase as real numbers.'</span>), <span class="keyword">...</span>
0110                     arg({<span class="string">'featureShape'</span>,<span class="string">'FeatureShape'</span>},<span class="string">'[CxCxFxTxM] (5d tensor)'</span>,{<span class="string">'[CCFTMx1] (unstructured vector)'</span>,<span class="string">'[CxCxFxTxM] (5d tensor)'</span>,<span class="string">'[CCMxFT] (time/freq row sparsity matrix)'</span>,<span class="string">'[CCxFTM] (per-link column sparsity matrix)'</span>,<span class="string">'[CCxFT]_m1,..,[CCxFT]_mk (low-rank space/time structure, sparse methods)'</span>,<span class="string">'[FxT]_c11,..,[FxT]_cnn (low-rank time/freq structure, sparse links)'</span>,<span class="string">'[CxC]_ft1,..,[CxC]_ft2 (low-rank link structure, sparse time/freq)'</span>},<span class="string">'Feature tensor arrangement. Features can be arranged in tensor or matrix or block-diagonal matrix form - most useful with the DAL classifier.'</span>), <span class="keyword">...</span>
0111                     arg({<span class="string">'vectorizeFeatures'</span>,<span class="string">'VectorizeFeatures'</span>},true,[],<span class="string">'Vectorize feature tensors. This is for classifiers that cannot handle matrix or tensor-shaped features.'</span>), <span class="keyword">...</span>
0112                     arg({<span class="string">'cacheFeatures'</span>,<span class="string">'CacheFeatures'</span>},<span class="string">'disk'</span>,{<span class="string">'no'</span>,<span class="string">'memory'</span>,<span class="string">'disk'</span>},<span class="string">'Whether/how to cache features. This generally applies only to offline processing. If set to memory, features will be cached in-memory. If set to disk, features will be cached on disk and reused across MATLAB sessions/instances. Note that the latter will produce huge amounts of data.'</span>), <span class="keyword">...</span>
0113                     arg({<span class="string">'logBias'</span>,<span class="string">'LogBias'</span>},1e-4,[],<span class="string">'Bias for logarithms. This is to shift connectivity values to a Gaussian distribution and also to prevent negative infinities from occurring.'</span>), <span class="keyword">...</span>
0114                     arg({<span class="string">'verb'</span>,<span class="string">'Verbosity'</span>,<span class="string">'verbosity'</span>},true,[],<span class="string">'Verbose output'</span>));
0115  
0116             <span class="comment">% make sure to clear persistent state of the SIFT estimator so we carry nothing over</span>
0117             <span class="comment">% between folds</span>
0118             clear mvar_glADMM;
0119                 
0120             <span class="keyword">if</span> g.lambdaSelection.arg_selection <span class="keyword">...</span>
0121                     &amp;&amp; g.lambdaSelection.validationMetric.checkWhiteness.arg_selection <span class="keyword">...</span>
0122                     &amp;&amp; length(g.lambdaSelection.validationMetric.checkWhiteness.whitenessCriteria)&gt;1
0123                 error(<span class="string">'BCILAB:ParadigmSIFT:MoreThanOneIC'</span>,<span class="string">'Only one WhitenessCriteria can be selected for ParadigmSIFT.'</span>); <span class="keyword">end</span>
0124             
0125             <span class="keyword">if</span> g.lambdaSelection.arg_selection <span class="keyword">...</span>
0126                  &amp;&amp; sum([g.lambdaSelection.validationMetric.checkConsistency.arg_selection <span class="keyword">...</span>
0127                     g.lambdaSelection.validationMetric.checkResidualVariance.arg_selection <span class="keyword">...</span>
0128                     g.lambdaSelection.validationMetric.checkStability.arg_selection <span class="keyword">...</span>
0129                     g.lambdaSelection.validationMetric.checkWhiteness.arg_selection]) &gt; 1
0130                 error(<span class="string">'BCILAB:ParadigmSIFT:MoreThanOneValidationMetric'</span>,<span class="string">'Only one validation metric (Whiteness,Stability,ResidualVariance, or Consistency) may be selected for ParadigmSIFT'</span>); <span class="keyword">end</span>
0131                 
0132             <span class="comment">% force window length and step size to match epoch length</span>
0133             model.siftPipelineConfig = g.connPipeline;
0134             
0135             continuous = self.make_continuous(g.signal);
0136             
0137             <span class="comment">% lambda selection.</span>
0138             <span class="comment">% Here we use one of validation metrics to select lambda</span>
0139             <span class="keyword">if</span> g.lambdaSelection.arg_selection
0140                 <span class="keyword">if</span> g.verb
0141                     fprintf(<span class="string">'Performing grid search for optimal lambda\n'</span>); <span class="keyword">end</span>
0142                 
0143                 <span class="comment">% fit model and perform validation</span>
0144                 connPipelineRange = g.connPipeline;
0145                 <span class="keyword">if</span> strcmpi(g.connPipeline.modeling.algorithm.arg_selection,<span class="string">'Group Lasso (ADMM)'</span>)
0146                     connPipelineRange.modeling.algorithm.admm_args.lambda = search(g.lambdaSelection.lambdaGrid);
0147                 <span class="keyword">else</span>
0148                     error(<span class="string">'Unknown modeling method %s. Disable lambda search and try again'</span>,g.connPipeline.modeling.algorithm.arg_selection);
0149                     <span class="comment">% FIXME: ADD ADDITIONAL CASES FOR OTHER ALGORITHMS...s</span>
0150                 <span class="keyword">end</span>
0151                 
0152                 [min_idx,all_inputs,all_outputs] = utl_gridsearch(<span class="string">'clauses'</span>,@onl_siftpipeline,connPipelineRange,<span class="string">'EEG'</span>,continuous,<span class="string">'connectivity'</span>,[],<span class="string">'validation'</span>,g.lambdaSelection.validationMetric); <span class="comment">%#ok&lt;ASGLU&gt;</span>
0153                 
0154                 <span class="comment">% pick optimal lambda</span>
0155                 <span class="keyword">if</span> g.lambdaSelection.validationMetric.checkConsistency.arg_selection
0156                     <span class="comment">% objective function (minimize) is mean percent</span>
0157                     <span class="comment">% consistency over epochs</span>
0158                     objFun = cellfun(@(x) x{1}.CAT.validation.PCstats.PC,all_outputs,<span class="string">'UniformOutput'</span>,false);
0159                     objFun = cellfun(@mean,objFun);
0160                 <span class="keyword">elseif</span> g.lambdaSelection.validationMetric.checkResidualVariance.arg_selection
0161                     <span class="comment">% objective function (minimize) is residual whiteness</span>
0162                     <span class="comment">% over epochs</span>
0163                     objFun = cellfun(@(x) x{1}.CAT.validation.residualstats.variance,all_outputs,<span class="string">'UniformOutput'</span>,false);
0164                     objFun = cellfun(@(x) mean(cell2mat(x)),objFun);
0165                 <span class="keyword">elseif</span> g.lambdaSelection.validationMetric.checkStability.arg_selection
0166                     <span class="comment">% objective function (minimize) is fraction of epochs</span>
0167                     <span class="comment">% with unstable VAR model</span>
0168                     objFun = cellfun(@(x) x{1}.CAT.validation.stabilitystats.stability,all_outputs,<span class="string">'UniformOutput'</span>,false);
0169                     objFun = 1-cellfun(@(x) nnz(x)/numel(x),objFun);
0170                 <span class="keyword">elseif</span> g.lambdaSelection.validationMetric.checkWhiteness.arg_selection
0171                     whitenessCriterion = lower(hlp_variableize(g.lambdaSelection.validationMetric.checkWhiteness.whitenessCriteria{1}));
0172                     <span class="comment">% objective function (minimize) is 1-pvalue where</span>
0173                     <span class="comment">% a sufficiently large pvalue indicates white residuals</span>
0174                     objFun = cellfun(@(x) x{1}.CAT.validation.whitestats.(whitenessCriterion).pval,all_outputs,<span class="string">'UniformOutput'</span>,false);
0175                     objFun = 1-cellfun(@mean,objFun);
0176                 <span class="keyword">end</span>
0177                 
0178                 <span class="comment">% get the min of the objective function and select lambda</span>
0179                 [min_val min_idx] = min(objFun); <span class="comment">%#ok&lt;NCOMMA&gt;</span>
0180                 optLambda = g.lambdaSelection.lambdaGrid(min_idx);
0181                 <span class="keyword">if</span> g.verb
0182                   fprintf(<span class="string">'Optimal lambda found. lambda=%05g; objFun(lambda)=%0.5g\n'</span>,optLambda,min_val); <span class="keyword">end</span>
0183                 
0184                 <span class="comment">% retrieve the configuration structure corresponding to the</span>
0185                 <span class="comment">% optimal lambda</span>
0186                 model.siftPipelineConfig.modeling = all_outputs{min_idx}{2}.modeling;
0187                 <span class="keyword">if</span> strcmpi(g.connPipeline.modeling.algorithm.arg_selection,<span class="string">'Group Lasso (ADMM)'</span>)
0188                     model.siftPipelineConfig.modeling.algorithm.admm_args.lambda = optLambda;
0189                 <span class="keyword">end</span>
0190             <span class="keyword">end</span>
0191             model.valueFormat = g.valueFormat;
0192             model.featureShape = g.featureShape;
0193             model.vectorizeFeatures = g.vectorizeFeatures;
0194             model.cacheFeatures = g.cacheFeatures;
0195             model.logBias = g.logBias;
0196             model.args = g;
0197             
0198             <span class="comment">% run feature extraction for a short signal to get shape information</span>
0199             tmpsignal = exp_eval(set_selepos(g.signal,1:min(3,g.signal.trials)));
0200             <span class="keyword">if</span> ~strcmp(g.featureShape,<span class="string">'[CCFTMx1] (unstructured vector)'</span>)                
0201                 [dummy,model.shape] = self.feature_extract(tmpsignal,model); <span class="keyword">end</span> <span class="comment">%#ok&lt;ASGLU&gt;</span>
0202         <span class="keyword">end</span>
0203         
0204         <a name="_sub4" href="#_subfunctions" class="code">function [features,shape] = feature_extract(self,signal,featuremodel)            </a>
0205             <span class="keyword">if</span> ~isfield(featuremodel,<span class="string">'cacheFeatures'</span>)
0206                 featuremodel.cacheFeatures = <span class="string">'memory'</span>; <span class="keyword">end</span>
0207             
0208             <span class="comment">% pre-calculate the placement indices within each epoch</span>
0209             winStartIdx = 1 : round(featuremodel.siftPipelineConfig.modeling.winstep*signal.srate) : signal.pnts - ceil(featuremodel.siftPipelineConfig.modeling.winlen * signal.srate);
0210             <span class="comment">% calculate placement indices across all epochs (after make_continuous)</span>
0211             winStartIdx = 1 + bsxfun(@plus,winStartIdx'-1, (0:signal.trials-1)*signal.pnts);
0212             featuremodel.siftPipelineConfig.modeling.winStartIdx = winStartIdx(:);
0213             
0214             <span class="comment">% extract connectivity features per epoch</span>
0215             call = {@onl_siftpipeline,featuremodel.siftPipelineConfig,<span class="string">'EEG'</span>,self.make_continuous(signal),<span class="string">'arg_direct'</span>,true};
0216             <span class="keyword">if</span> onl_isonline || strcmp(featuremodel.cacheFeatures,<span class="string">'no'</span>)
0217                 EEG = call{1}(call{2:end});
0218             <span class="keyword">elseif</span> strcmp(featuremodel.cacheFeatures,<span class="string">'memory'</span>)
0219                 hlp_microcache(<span class="string">'conn'</span>,<span class="string">'max_key_size'</span>,2^30,<span class="string">'max_result_size'</span>,2^30);
0220                 EEG = hlp_microcache(<span class="string">'conn'</span>,call{:});
0221             <span class="keyword">elseif</span> strcmp(featuremodel.cacheFeatures,<span class="string">'disk'</span>)
0222                 EEG = hlp_diskcache(<span class="string">'features'</span>,call{:});
0223             <span class="keyword">else</span>
0224                 error(<span class="string">'Unsupported CacheFeatures setting: %s'</span>,hlp_tostring(featuremodel.cacheFeatures,100));
0225             <span class="keyword">end</span>
0226             
0227             rawfeatures = cellfun(@(connmethod) EEG.CAT.Conn.(connmethod), <span class="keyword">...</span>
0228                 featuremodel.siftPipelineConfig.connectivity.connmethods, <span class="keyword">...</span>
0229                 <span class="string">'UniformOutput'</span>,false);
0230             
0231             <span class="comment">% reshape them to separate time points from trials {CxCxFxTxN, CxCxFxTxN, ...}</span>
0232             <span class="keyword">for</span> m=1:length(rawfeatures)
0233                 [C,C2,F,TN] = size(rawfeatures{m});
0234                 rawfeatures{m} = reshape(rawfeatures{m},C,C2,F,[],signal.trials);
0235             <span class="keyword">end</span>
0236             
0237             <span class="comment">% combine into single tensor: CxCxFxTxMxN</span>
0238             features = permute(cat(6,rawfeatures{:}),[1,2,3,4,6,5]);
0239             [C,C2,F,T,M,N] = size(features);
0240             <span class="keyword">if</span> C2 ~= C || N ~= signal.trials
0241                 error(<span class="string">'Unexpected feature shape.'</span>); <span class="keyword">end</span>
0242             
0243             <span class="comment">% reshape into desired form (note: all arrays are implicitly xN)</span>
0244             same_size = @(shape,features) isequal(shape(1:ndims(features)),size(features));
0245             <span class="keyword">switch</span> featuremodel.featureShape                
0246                 <span class="keyword">case</span> <span class="string">'[CxCxFxTxM] (5d tensor)'</span>
0247                     shape = [C,C,F,T,M];
0248                     <span class="keyword">if</span> ~same_size([shape N],features)
0249                         error(<span class="string">'Unexpected feature shape.'</span>); <span class="keyword">end</span>
0250                 <span class="keyword">case</span> <span class="string">'[CCMxFT] (time/freq row sparsity matrix)'</span>
0251                     features = reshape(permute(features,[1 2 5 3 4 6]),[C*C*M,F*T,N]);
0252                     shape = [C*C*M,F*T];
0253                     <span class="keyword">if</span> ~same_size([shape N],features)
0254                         error(<span class="string">'Unexpected feature shape.'</span>); <span class="keyword">end</span>
0255                 <span class="keyword">case</span> <span class="string">'[CCxFTM] (per-link column sparsity matrix)'</span>
0256                     features = reshape(permute(features,[1 2 3 4 5 6]),[C*C,F*T*M,N]);
0257                     shape = [C*C,F*T*M];
0258                     <span class="keyword">if</span> ~same_size([shape N],features)
0259                         error(<span class="string">'Unexpected feature shape.'</span>); <span class="keyword">end</span>
0260                 <span class="keyword">case</span> <span class="string">'[CCxFT]_m1,..,[CCxFT]_mk (low-rank space/time structure, sparse methods)'</span>
0261                     features = reshape(permute(features,[1 2 3 4 5 6]),[C*C,F*T*M,N]);
0262                     shape = repmat([C*C,F*T],M,1);
0263                 <span class="keyword">case</span> <span class="string">'[FxT]_c11,..,[FxT]_cnn (low-rank time/freq structure, sparse links)'</span>
0264                     features = reshape(permute(features,[3 4 1 2 5 6]),[F*T,C*C*M,N]);
0265                     shape = repmat([F,T],C*C*M,1);
0266                 <span class="keyword">case</span> <span class="string">'[CxC]_ft1,..,[CxC]_ft2 (low-rank link structure, sparse time/freq)'</span>
0267                     features = reshape(permute(features,[1 2 3 4 5 6]),[C*C,F*T*M,N]);
0268                     shape = repmat([C,C],F*T*M,1);
0269                 <span class="keyword">case</span> <span class="string">'[CCFTMx1] (unstructured vector)'</span>
0270                     shape = [C*C*F*T*M,1];
0271                 <span class="keyword">otherwise</span>
0272                     error(<span class="string">'Unrecognized FeatureShape selected.'</span>);
0273             <span class="keyword">end</span>
0274             
0275             <span class="comment">% apply value formatting</span>
0276             <span class="keyword">switch</span> featuremodel.valueFormat
0277                 <span class="keyword">case</span> <span class="string">'complex'</span>
0278                     features = complex(features);
0279                 <span class="keyword">case</span> <span class="string">'mixed'</span>
0280                     <span class="comment">% nothing to do</span>
0281                 <span class="keyword">case</span> <span class="string">'magnitude'</span>
0282                     features = abs(features);
0283                 <span class="keyword">case</span> <span class="string">'sqrt-magnitude'</span>
0284                     features = sqrt(abs(features));
0285                 <span class="keyword">case</span> <span class="string">'log-magnitude'</span>
0286                     features = log(featuremodel.logBias+abs(features));
0287                 <span class="keyword">case</span> <span class="string">'phase'</span>
0288                     features = angle(features);
0289                     <span class="comment">% these two cases will double the first shape parameter for each block</span>
0290                 <span class="keyword">case</span> <span class="string">'components'</span>
0291                     <span class="comment">% components are expanded along the first dimension</span>
0292                     features = permute(cat(ndims(features)+1,real(features),imag(features)),[ndims(features)+1,1:ndims(features)]);
0293                     shape(:,1) = shape(:,1)*2;
0294                 <span class="keyword">case</span> <span class="string">'polar'</span>
0295                     <span class="comment">% components are expanded along the first dimension</span>
0296                     features = permute(cat(ndims(features)+1,abs(features),angle(features)),[ndims(features)+1,1:ndims(features)]);
0297                     shape(:,1) = shape(:,1)*2;
0298                 <span class="keyword">otherwise</span>
0299                     error([<span class="string">'Unsupported value format: '</span> featuremodel.valueFormat]);
0300             <span class="keyword">end</span>
0301             
0302             <span class="comment">% do final vectorization if desired</span>
0303             <span class="keyword">if</span> featuremodel.vectorizeFeatures
0304                 features = reshape(features,[],signal.trials)'; <span class="keyword">end</span>
0305         <span class="keyword">end</span>
0306         
0307         <a name="_sub5" href="#_subfunctions" class="code">function [featuremodel,conditioningmodel,predictivemodel] = calibrate_prediction_function(self,varargin)</a>
0308             <span class="comment">% Perform calibration of the prediction function; this includes everything except for signal</span>
0309             <span class="comment">% processing. This function can optionally be overridden if some custom feature-extraction /</span>
0310             <span class="comment">% machine learning data flow is desired; its user parameters may be arbitrarily redefined then.</span>
0311             <span class="comment">%</span>
0312             <span class="comment">% This function invokes the feature adaptation, feature extraction and machine learning</span>
0313             <span class="comment">% during the calibration phase (i.e. everything that is required to determine the</span>
0314             <span class="comment">% parameters of the BCI paradigm's prediction function).</span>
0315             <span class="comment">%</span>
0316             <span class="comment">% This function is what gives rise to the &quot;Prediction&quot; top-level argument of the paradigm;</span>
0317             <span class="comment">% as you see below, it has two sub-arguments: FeatureExtraction and MachineLearning, which</span>
0318             <span class="comment">% themselves are defined by feature_adapt() and ml_train().</span>
0319             <span class="comment">%</span>
0320             <span class="comment">% In:</span>
0321             <span class="comment">%   Signal : a signal as pre-processed according to the paradigm's pre-processing pipeline</span>
0322             <span class="comment">%</span>
0323             <span class="comment">%   FeatureExtraction : User parameters for the feature-extraction stage. These parameters</span>
0324             <span class="comment">%                       control how features are extracted from the filtered data before</span>
0325             <span class="comment">%                       they are passed int othe machine learning stage.</span>
0326             <span class="comment">%</span>
0327             <span class="comment">%   Conditioning : User parameters for an optional feature-conditioning stage. These parameters</span>
0328             <span class="comment">%                  control how features are remapped to features that are subsequently received</span>
0329             <span class="comment">%                  by the machine learning.</span>
0330             <span class="comment">%</span>
0331             <span class="comment">%   MachineLearning : Machine learning stage of the paradigm. Operates on the feature</span>
0332             <span class="comment">%                     vectors that are produced by the feature-extraction stage.</span>
0333             <span class="comment">%</span>
0334             <span class="comment">% Out:</span>
0335             <span class="comment">%   FeatureModel : a feature-extraction model as understood by apply_prediction_function()</span>
0336             <span class="comment">%                  or (if not otherwise customized) by the feature_extract() function</span>
0337             <span class="comment">%                  * special feature: if this contains a non-empty field named shape, this</span>
0338             <span class="comment">%                                     value will be passed on to the machine learning method</span>
0339             <span class="comment">%</span>
0340             <span class="comment">%   ConditioningModel : a model that is sandwiched between feature extraction and machine learning,</span>
0341             <span class="comment">%                       generated by feature_adapt_conditioning and understood by feature_apply_conditioning</span>
0342             <span class="comment">%</span>
0343             <span class="comment">%   PredictiveModel : a predictive model, as understood by apply_prediction_function() or</span>
0344             <span class="comment">%                     (if not otherwise customized) by the ml_predict() function</span>
0345             <span class="comment">%</span>
0346             <span class="comment">%</span>
0347             <span class="comment">% Notes:</span>
0348             <span class="comment">%   You may override this function if your prediction function blends traditional</span>
0349             <span class="comment">%   feature extraction and machine learning or otherwise makes this separation</span>
0350             <span class="comment">%   impractical (for example if you have an unusual mapping between training instances</span>
0351             <span class="comment">%   for machine learning and target values in the data set). This function should</span>
0352             <span class="comment">%   declare its arguments using arg_define().</span>
0353             
0354             args = arg_define(varargin, <span class="keyword">...</span>
0355                 arg_norep({<span class="string">'signal'</span>,<span class="string">'Signal'</span>}), <span class="keyword">...</span>
0356                 arg_sub({<span class="string">'fex'</span>,<span class="string">'FeatureExtraction'</span>},{},@self.feature_adapt,<span class="string">'Parameters for the feature-adaptation function. These parameters control how features are statistically adapted and extracted from the filtered data before they are passed into the machine learning stage.'</span>), <span class="keyword">...</span>
0357                 arg_sub({<span class="string">'cond'</span>,<span class="string">'Conditioning'</span>},{},@self.feature_adapt_conditioning,<span class="string">'Feature conditioning parameters. Allows to further process features for better usability with classifiers.'</span>), <span class="keyword">...</span>
0358                 arg_sub({<span class="string">'ml'</span>,<span class="string">'MachineLearning'</span>},{<span class="string">'Learner'</span>,self.machine_learning_defaults()},@ml_train,<span class="string">'Machine learning stage of the paradigm. Operates on the feature vectors that are produced by the feature-extraction stage.'</span>), <span class="keyword">...</span>
0359                 arg_sub({<span class="string">'ml_search'</span>,<span class="string">'MachineLearningForSearch'</span>},{<span class="string">'Learner'</span>,self.machine_learning_search_defaults()},@ml_train,<span class="string">'Machine learning stage for parameter search. This paradigm uses a fast classifier to optimize preproc pipeline parameters, and then uses the slower classifier with the optimized pipeline.'</span>));
0360             
0361             <span class="comment">% adapt features if necessary</span>
0362             featuremodel = self.feature_adapt(<span class="string">'signal'</span>,args.signal, args.fex);
0363             <span class="keyword">if</span> isfield(featuremodel,<span class="string">'shape'</span>) &amp;&amp; ~isempty(featuremodel.shape)
0364                 <span class="comment">% check if the learner supports a shape parameter...</span>
0365                 <span class="keyword">if</span> isfield(args.ml.learner,<span class="string">'shape'</span>)
0366                     args.ml.learner.shape = featuremodel.shape; 
0367                 <span class="keyword">else</span>
0368                     warn_once(<span class="string">'ParadigmDataflowSimplified:ignoring_shape'</span>,<span class="string">'The learning function does not appear to support a shape parameter, but the paradigm prefers to supply one; ignoring the shape. This warning will not be shown again during this session.'</span>);
0369                 <span class="keyword">end</span>
0370             <span class="keyword">end</span>
0371             <span class="keyword">if</span> isfield(featuremodel,<span class="string">'modality_ranges'</span>) &amp;&amp; ~isempty(featuremodel.modality_ranges)
0372                 <span class="comment">% check if the learner supports a modality_ranges parameter...</span>
0373                 <span class="keyword">if</span> isfield(args.ml.learner,<span class="string">'modality_ranges'</span>)
0374                     args.ml.learner.modality_ranges = featuremodel.modality_ranges; 
0375                 <span class="keyword">else</span>
0376                     warn_once(<span class="string">'ParadigmDataflowSimplified:ignoring_modality_ranges'</span>,<span class="string">'The learning function does not appear to support a modality_ranges parameter, but the paradigm prefers to supply one; ignoring the modality_ranges. This warning will not be shown again during this session.'</span>);
0377                 <span class="keyword">end</span>
0378             <span class="keyword">end</span>
0379             
0380             <span class="comment">% try to extract some signal-related properties</span>
0381             featuremodel.signalinfo.chanlocs = args.signal.chanlocs;
0382             featuremodel.signalinfo.chaninfo = args.signal.chaninfo;
0383             
0384             <span class="comment">% extract features</span>
0385             features = self.feature_extract(args.signal, featuremodel);
0386             
0387             <span class="comment">% extract target labels</span>
0388             targets = set_gettarget(args.signal);
0389             
0390             <span class="comment">% adapt and apply feature conditioning</span>
0391             conditioningmodel = self.feature_adapt_conditioning(<span class="string">'features'</span>,features,<span class="string">'targets'</span>,targets,args.cond);
0392             [features,targets] = self.feature_apply_conditioning(features,targets,conditioningmodel);
0393             
0394             <span class="comment">% run the machine learning stage</span>
0395             <span class="keyword">if</span> hlp_iscaller(<span class="string">'utl_gridsearch'</span>)
0396                 <span class="comment">% within a grid search we use the fast and simple ml_search classifier</span>
0397                 predictivemodel = ml_train(<span class="string">'data'</span>,{features,targets}, args.ml_search);
0398             <span class="keyword">else</span>
0399                 <span class="comment">% outside the search we use the better ml classifier</span>
0400                 predictivemodel = ml_train(<span class="string">'data'</span>,{features,targets}, args.ml);
0401             <span class="keyword">end</span>            
0402         <span class="keyword">end</span>
0403         
0404         <a name="_sub6" href="#_subfunctions" class="code">function visualize_model(self,varargin) </a><span class="comment">%#ok&lt;*INUSD&gt;</span>
0405             args = arg_define([0 3],varargin, <span class="keyword">...</span>
0406                 arg_norep({<span class="string">'parent'</span>,<span class="string">'Parent'</span>},[],[],<span class="string">'Parent figure.'</span>), <span class="keyword">...</span>
0407                 arg_norep({<span class="string">'featuremodel'</span>,<span class="string">'FeatureModel'</span>},[],[],<span class="string">'Feature model. This is the part of the model that describes the feature extraction.'</span>), <span class="keyword">...</span>
0408                 arg_norep({<span class="string">'predictivemodel'</span>,<span class="string">'PredictiveModel'</span>},[],[],<span class="string">'Predictive model. This is the part of the model that describes the predictive mapping.'</span>), <span class="keyword">...</span>
0409                 arg({<span class="string">'signed'</span>,<span class="string">'SignedWeights'</span>},true,[],<span class="string">'Plot signed weights. Whether the original signed weights should be plotted or their absolute values.'</span>), <span class="keyword">...</span>
0410                 arg({<span class="string">'reordering'</span>,<span class="string">'Reordering'</span>},[],uint32([1 10000]),<span class="string">'Component reordering. Allows to reorder components for plotting.'</span>,<span class="string">'shape'</span>,<span class="string">'row'</span>,<span class="string">'guru'</span>,true), <span class="keyword">...</span>
0411                 arg({<span class="string">'smoothing_kernel'</span>,<span class="string">'SmoothingKernel'</span>},[],[],<span class="string">'Smoothing filter kernel. Allows to smooth time/frequency activation.'</span>,<span class="string">'shape'</span>,<span class="string">'row'</span>,<span class="string">'guru'</span>,true));
0412             [featuremodel,predictivemodel] = deal(args.featuremodel,args.predictivemodel);
0413             fs = featuremodel.shape;
0414             <span class="comment">% get weights and featureshape</span>
0415             w = predictivemodel.model.w; 
0416             <span class="keyword">if</span> numel(w) == prod(fs)+1
0417                 w = w(1:end-1); <span class="keyword">end</span>
0418             <span class="comment">% reshape into tensor</span>
0419             M = ((reshape(w,fs))); 
0420             <span class="comment">% reverse frequency axis for plotting</span>
0421             M = M(:,:,end:-1:1,:); 
0422             <span class="keyword">if</span> ~isempty(args.smoothing_kernel)
0423                 M = filter(args.smoothing_kernel/norm(args.smoothing_kernel),1,M,[],3);
0424                 M = filter(args.smoothing_kernel/norm(args.smoothing_kernel),1,M,[],4);
0425             <span class="keyword">end</span>
0426             <span class="keyword">if</span> ~isempty(args.reordering)
0427                 M = M(args.reordering,args.reordering,:,:); <span class="keyword">end</span>
0428             <span class="comment">% add padding</span>
0429             M(:,:,end+1,:)=max(abs(M(:)));
0430             M(:,:,:,end+1)=max(abs(M(:)));            
0431             <span class="comment">% reorder for plotting</span>
0432             N = reshape(permute(M,[3,1,4,2,5]),fs(1)*(fs(3)+1),fs(2)*(fs(4)+1),[]);
0433             <span class="comment">% plot</span>
0434             chns = featuremodel.siftPipelineConfig.channels;
0435             <span class="keyword">if</span> args.signed
0436                 imagesc(N,<span class="string">'XData'</span>,[0.5 length(chns)+0.5],<span class="string">'YData'</span>,[0.5 length(chns)+0.5]);
0437                 caxis([-max(abs(N(:))) max(abs(N(:)))])
0438             <span class="keyword">else</span>
0439                 imagesc(abs(N),<span class="string">'XData'</span>,[0.5 length(chns)+0.5],<span class="string">'YData'</span>,[0.5 length(chns)+0.5]);
0440             <span class="keyword">end</span>
0441             colorbar;
0442             title(<span class="string">'Absolute model weights across component pairs in time/frequency.'</span>);            
0443             xlabel(<span class="string">'From Component'</span>);
0444             set(gca,<span class="string">'XTick'</span>,1:length(chns),<span class="string">'XTickLabel'</span>,chns);
0445             set(gca,<span class="string">'YTick'</span>,1:length(chns),<span class="string">'YTickLabel'</span>,chns);
0446             ylabel(<span class="string">'To Component'</span>);
0447         <span class="keyword">end</span>
0448 
0449         <a name="_sub7" href="#_subfunctions" class="code">function layout = dialog_layout_defaults(self)</a>
0450             <span class="comment">% define the default configuration dialog layout</span>
0451             layout = {<span class="string">'SignalProcessing.Resampling.SamplingRate'</span>, <span class="keyword">...</span>
0452                 <span class="string">'SignalProcessing.DataCleaning.DataSetting'</span>, <span class="keyword">...</span>
0453                 <span class="string">''</span>, <span class="keyword">...</span>
0454                 <span class="string">'SignalProcessing.ICA.Variant'</span>, <span class="keyword">...</span>
0455                 <span class="string">''</span>, <span class="keyword">...</span>
0456                 <span class="string">'SignalProcessing.ChannelSelection.Channels'</span>, <span class="keyword">...</span>
0457                 <span class="string">''</span>, <span class="keyword">...</span>
0458                 <span class="string">'SignalProcessing.EpochExtraction'</span>, <span class="keyword">...</span>
0459                 <span class="string">''</span>, <span class="keyword">...</span>
0460                 <span class="string">'Prediction.FeatureExtraction.ValueFormat'</span>, <span class="keyword">...</span>
0461                 <span class="string">''</span>, <span class="keyword">...</span>
0462                 <span class="string">'Prediction.FeatureExtraction.ConnectivityPipeline.Modeling.ModelOrder'</span>, <span class="keyword">...</span>
0463                 <span class="string">'Prediction.FeatureExtraction.ConnectivityPipeline.Modeling.WindowLength'</span>, <span class="keyword">...</span>
0464                 <span class="string">'Prediction.FeatureExtraction.ConnectivityPipeline.Modeling.WindowStepSize'</span>, <span class="keyword">...</span>
0465                 <span class="string">'Prediction.FeatureExtraction.ConnectivityPipeline.Connectivity.Frequencies'</span>, <span class="keyword">...</span>
0466                 <span class="string">'Prediction.FeatureExtraction.ConnectivityPipeline.Connectivity.ConnectivityMeasures'</span>, <span class="keyword">...</span>
0467                 <span class="string">''</span>, <span class="keyword">...</span>
0468                 <span class="string">'Prediction.MachineLearning.Learner.LossType'</span>, <span class="keyword">...</span>
0469                 <span class="string">'Prediction.MachineLearning.Learner.LambdaSearch.Lambdas'</span>, <span class="keyword">...</span>
0470                 <span class="string">'Prediction.MachineLearning.Learner.LambdaSearch.ParameterMetric'</span>, <span class="keyword">...</span>
0471                 <span class="string">'Prediction.MachineLearning.Learner.LambdaSearch.NumFolds'</span>};
0472         <span class="keyword">end</span>
0473                 
0474         <a name="_sub8" href="#_subfunctions" class="code">function tf = needs_voting(self)</a>
0475             <span class="comment">% by default we use voting to handle more than two classes</span>
0476             tf = true; 
0477         <span class="keyword">end</span>
0478         
0479         <a name="_sub9" href="#_subfunctions" class="code">function sig = make_continuous(self,sig)</a>
0480             <span class="comment">% turn an epoched signal into a continuous one</span>
0481             <span class="keyword">if</span> sig.trials ~= 1
0482                 <span class="comment">% epoched dataset... reshape it</span>
0483                 sig.data = sig.data(:,:);
0484                 <span class="keyword">if</span> isfield(sig,<span class="string">'srcpot'</span>) &amp;&amp; ~isempty(sig.srcpot)
0485                     sig.srcpot = sig.srcpot(:,:); <span class="keyword">end</span>
0486                 <span class="keyword">if</span> isfield(sig,<span class="string">'icaact'</span>) &amp;&amp; ~isempty(sig.icaact)
0487                     sig.icaact = sig.icaact(:,:); <span class="keyword">end</span>
0488                 [sig.chns,sig.pnts,sig.trials] = size(sig.data);
0489                 sig.epoch = [];
0490                 sig.event = [];
0491             <span class="keyword">end</span>
0492         <span class="keyword">end</span>
0493         
0494     <span class="keyword">end</span>
0495 <span class="keyword">end</span>
0496</pre></div>

<hr><address>Generated on Wed 19-Aug-2015 18:06:23 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>