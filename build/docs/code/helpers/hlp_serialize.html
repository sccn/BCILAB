<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of hlp_serialize</title>
  <meta name="keywords" content="hlp_serialize">
  <meta name="description" content="Convert a MATLAB data structure into a compact byte vector.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="#">code</a> &gt; <a href="index.html">helpers</a> &gt; hlp_serialize.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for code/helpers&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>hlp_serialize

</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>Convert a MATLAB data structure into a compact byte vector.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function m = hlp_serialize(v) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Convert a MATLAB data structure into a compact byte vector.
 Bytes = hlp_serialize(Data)

 The original data structure can be recovered from the byte vector via hlp_deserialize.

 In:
   Data : some MATLAB data structure

 Out:
   Bytes : a representation of the original data as a byte stream

 Notes:
   The code is a rewrite of Tim Hutt's serialization code. Support has been added for correct 
   recovery of sparse, complex, single, (u)intX, function handles, anonymous functions, objects, 
   and structures with unlimited field count. Serialize/deserialize performance is ~10x higher.

 Limitations:
   * Java objects cannot be serialized
   * Arrays with more than 255 dimensions have their last dimensions clamped
   * Handles to nested/scoped functions can only be deserialized when their parent functions 
     support the BCILAB argument reporting protocol (e.g., by using arg_define).
   * New MATLAB objects need to be reasonably friendly to serialization; either they support
     construction from a struct, or they support saveobj/loadobj(struct), or all their important 
     properties can be set via set(obj,'name',value)
   * In anonymous functions, accessing unreferenced variables in the workspace of the original
     declaration via eval(in) works only if manually enabled via the global variable
     tracking.serialize_anonymous_fully (possibly at a significant performance hit).
     note: this feature is currently not rock solid and can be broken either by Ctrl+C'ing
           in the wrong moment or by concurrently serializing from MATLAB timers.

 See also:
   <a href="hlp_deserialize.html" class="code" title="function v = hlp_deserialize(m)">hlp_deserialize</a>

 Examples:
   bytes = hlp_serialize(mydata);
   ... e.g. transfer the 'bytes' array over the network ...
   mydata = hlp_deserialize(bytes);

                                Christian Kothe, Swartz Center for Computational Neuroscience, UCSD
                                2010-04-02

                                adapted from serialize.m
                                (C) 2010 Tim Hutt</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">

<li><a href="hlp_serialize.html" class="code" title="function m = hlp_serialize(v)">hlp_serialize</a>	Convert a MATLAB data structure into a compact byte vector.</li>
</ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">

<li><a href="hlp_cryptohash.html" class="code" title="function hash = hlp_cryptohash(data,fromfile)">hlp_cryptohash</a>	Compute an MD5 hash of a file, string or generic data structure.</li>
<li><a href="hlp_diskcache.html" class="code" title="function varargout = hlp_diskcache(options, f, varargin)">hlp_diskcache</a>	Cache results of function invocations.</li>
<li><a href="hlp_serialize.html" class="code" title="function m = hlp_serialize(v)">hlp_serialize</a>	Convert a MATLAB data structure into a compact byte vector.</li>
</ul>
<!-- crossreference -->


<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">

<li><a href="#_sub1" class="code">function m = serialize_scalar(v)</a></li>
<li><a href="#_sub2" class="code">function m = serialize_string(v)</a></li>
<li><a href="#_sub3" class="code">function m = serialize_logical(v)</a></li>
<li><a href="#_sub4" class="code">function m = serialize_numeric_simple(v)</a></li>
<li><a href="#_sub5" class="code">function m = serialize_numeric(v)</a></li>
<li><a href="#_sub6" class="code">function m = serialize_struct(v)</a></li>
<li><a href="#_sub7" class="code">function m = serialize_cell_heterogenous(v)</a></li>
<li><a href="#_sub8" class="code">function m = serialize_cell_typed(v,serializer)</a></li>
<li><a href="#_sub9" class="code">function m = serialize_cell(v)</a></li>
<li><a href="#_sub10" class="code">function m = serialize_object(v)</a></li>
<li><a href="#_sub11" class="code">function m = serialize_handle(v)</a></li>
<li><a href="#_sub12" class="code">function b = class2tag(cls)</a></li>
<li><a href="#_sub13" class="code">function warn_once(varargin)</a></li>
</ul>




<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function m = hlp_serialize(v)</a>
0002 <span class="comment">% Convert a MATLAB data structure into a compact byte vector.</span>
0003 <span class="comment">% Bytes = hlp_serialize(Data)</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% The original data structure can be recovered from the byte vector via hlp_deserialize.</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% In:</span>
0008 <span class="comment">%   Data : some MATLAB data structure</span>
0009 <span class="comment">%</span>
0010 <span class="comment">% Out:</span>
0011 <span class="comment">%   Bytes : a representation of the original data as a byte stream</span>
0012 <span class="comment">%</span>
0013 <span class="comment">% Notes:</span>
0014 <span class="comment">%   The code is a rewrite of Tim Hutt's serialization code. Support has been added for correct</span>
0015 <span class="comment">%   recovery of sparse, complex, single, (u)intX, function handles, anonymous functions, objects,</span>
0016 <span class="comment">%   and structures with unlimited field count. Serialize/deserialize performance is ~10x higher.</span>
0017 <span class="comment">%</span>
0018 <span class="comment">% Limitations:</span>
0019 <span class="comment">%   * Java objects cannot be serialized</span>
0020 <span class="comment">%   * Arrays with more than 255 dimensions have their last dimensions clamped</span>
0021 <span class="comment">%   * Handles to nested/scoped functions can only be deserialized when their parent functions</span>
0022 <span class="comment">%     support the BCILAB argument reporting protocol (e.g., by using arg_define).</span>
0023 <span class="comment">%   * New MATLAB objects need to be reasonably friendly to serialization; either they support</span>
0024 <span class="comment">%     construction from a struct, or they support saveobj/loadobj(struct), or all their important</span>
0025 <span class="comment">%     properties can be set via set(obj,'name',value)</span>
0026 <span class="comment">%   * In anonymous functions, accessing unreferenced variables in the workspace of the original</span>
0027 <span class="comment">%     declaration via eval(in) works only if manually enabled via the global variable</span>
0028 <span class="comment">%     tracking.serialize_anonymous_fully (possibly at a significant performance hit).</span>
0029 <span class="comment">%     note: this feature is currently not rock solid and can be broken either by Ctrl+C'ing</span>
0030 <span class="comment">%           in the wrong moment or by concurrently serializing from MATLAB timers.</span>
0031 <span class="comment">%</span>
0032 <span class="comment">% See also:</span>
0033 <span class="comment">%   hlp_deserialize</span>
0034 <span class="comment">%</span>
0035 <span class="comment">% Examples:</span>
0036 <span class="comment">%   bytes = hlp_serialize(mydata);</span>
0037 <span class="comment">%   ... e.g. transfer the 'bytes' array over the network ...</span>
0038 <span class="comment">%   mydata = hlp_deserialize(bytes);</span>
0039 <span class="comment">%</span>
0040 <span class="comment">%                                Christian Kothe, Swartz Center for Computational Neuroscience, UCSD</span>
0041 <span class="comment">%                                2010-04-02</span>
0042 <span class="comment">%</span>
0043 <span class="comment">%                                adapted from serialize.m</span>
0044 <span class="comment">%                                (C) 2010 Tim Hutt</span>
0045 
0046 <span class="comment">% hlp_serialize_version&lt;1.00&gt;</span>
0047 
0048 <span class="comment">% Copyright (C) Christian Kothe, SCCN, 2010, christian@sccn.ucsd.edu</span>
0049 <span class="comment">%</span>
0050 <span class="comment">% This program is free software; you can redistribute it and/or modify it under the terms of the GNU</span>
0051 <span class="comment">% General Public License as published by the Free Software Foundation; either version 2 of the</span>
0052 <span class="comment">% License, or (at your option) any later version.</span>
0053 <span class="comment">%</span>
0054 <span class="comment">% This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without</span>
0055 <span class="comment">% even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
0056 <span class="comment">% General Public License for more details.</span>
0057 <span class="comment">%</span>
0058 <span class="comment">% You should have received a copy of the GNU General Public License along with this program; if not,</span>
0059 <span class="comment">% write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307</span>
0060 <span class="comment">% USA</span>
0061 
0062     <span class="comment">% dispatch according to type</span>
0063     <span class="keyword">if</span> isnumeric(v) 
0064         m = <a href="#_sub5" class="code" title="subfunction m = serialize_numeric(v)">serialize_numeric</a>(v);
0065     <span class="keyword">elseif</span> ischar(v)
0066         m = <a href="#_sub2" class="code" title="subfunction m = serialize_string(v)">serialize_string</a>(v);
0067     <span class="keyword">elseif</span> iscell(v)
0068         m = <a href="#_sub9" class="code" title="subfunction m = serialize_cell(v)">serialize_cell</a>(v);
0069     <span class="keyword">elseif</span> isstruct(v)
0070         m = <a href="#_sub6" class="code" title="subfunction m = serialize_struct(v)">serialize_struct</a>(v);
0071     <span class="keyword">elseif</span> isa(v,<span class="string">'function_handle'</span>)
0072         m = <a href="#_sub11" class="code" title="subfunction m = serialize_handle(v)">serialize_handle</a>(v);
0073     <span class="keyword">elseif</span> islogical(v)
0074         m = <a href="#_sub3" class="code" title="subfunction m = serialize_logical(v)">serialize_logical</a>(v);
0075     <span class="keyword">elseif</span> isobject(v)
0076         m = <a href="#_sub10" class="code" title="subfunction m = serialize_object(v)">serialize_object</a>(v);
0077     <span class="keyword">elseif</span> isjava(v)
0078         <a href="#_sub13" class="code" title="subfunction warn_once(varargin)">warn_once</a>(<span class="string">'hlp_serialize:cannot_serialize_java'</span>,<span class="string">'Cannot properly serialize Java class %s; using a placeholder instead.'</span>,class(v));
0079         m = <a href="#_sub2" class="code" title="subfunction m = serialize_string(v)">serialize_string</a>([<span class="string">'&lt;&lt;hlp_serialize: '</span> class(v) <span class="string">' unsupported&gt;&gt;'</span>]);
0080     <span class="keyword">else</span>
0081         <span class="keyword">try</span>
0082             m = <a href="#_sub10" class="code" title="subfunction m = serialize_object(v)">serialize_object</a>(v);
0083         <span class="keyword">catch</span>
0084             <a href="#_sub13" class="code" title="subfunction warn_once(varargin)">warn_once</a>(<span class="string">'hlp_serialize:unknown_type'</span>,<span class="string">'Cannot properly serialize object of unknown type &quot;%s&quot;; using a placeholder instead.'</span>,class(v));
0085             m = <a href="#_sub2" class="code" title="subfunction m = serialize_string(v)">serialize_string</a>([<span class="string">'&lt;&lt;hlp_serialize: '</span> class(v) <span class="string">' unsupported&gt;&gt;'</span>]);
0086         <span class="keyword">end</span>
0087     <span class="keyword">end</span>
0088 <span class="keyword">end</span>
0089 
0090 <span class="comment">% single scalar</span>
0091 <a name="_sub1" href="#_subfunctions" class="code">function m = serialize_scalar(v)</a>
0092     <span class="comment">% Data type &amp; data</span>
0093     m = [<a href="#_sub12" class="code" title="subfunction b = class2tag(cls)">class2tag</a>(class(v)); typecast(v,<span class="string">'uint8'</span>).'];
0094 <span class="keyword">end</span>
0095 
0096 <span class="comment">% char arrays</span>
0097 <a name="_sub2" href="#_subfunctions" class="code">function m = serialize_string(v)</a>
0098     <span class="keyword">if</span> size(v,1) == 1
0099         <span class="comment">% horizontal string: Type, Length, and Data</span>
0100         m = [uint8(0); typecast(uint32(length(v)),<span class="string">'uint8'</span>).'; uint8(v(:))];
0101     <span class="keyword">elseif</span> sum(size(v)) == 0
0102         <span class="comment">% '': special encoding</span>
0103         m = uint8(200);
0104     <span class="keyword">else</span>
0105         <span class="comment">% general char array: Tag &amp; Number of dimensions, Dimensions, Data</span>
0106         m = [uint8(132); ndims(v); typecast(uint32(size(v)),<span class="string">'uint8'</span>).'; uint8(v(:))];
0107     <span class="keyword">end</span>
0108 <span class="keyword">end</span>
0109 
0110 <span class="comment">% logical arrays</span>
0111 <a name="_sub3" href="#_subfunctions" class="code">function m = serialize_logical(v)</a>
0112     <span class="comment">% Tag &amp; Number of dimensions, Dimensions, Data</span>
0113     m = [uint8(133); ndims(v); typecast(uint32(size(v)),<span class="string">'uint8'</span>).'; uint8(v(:))];
0114 <span class="keyword">end</span>
0115 
0116 <span class="comment">% non-complex and non-sparse numerical matrix</span>
0117 <a name="_sub4" href="#_subfunctions" class="code">function m = serialize_numeric_simple(v)</a>
0118     <span class="comment">% Tag &amp; Number of dimensions, Dimensions, Data</span>
0119     m = [16+<a href="#_sub12" class="code" title="subfunction b = class2tag(cls)">class2tag</a>(class(v)); ndims(v); typecast(uint32(size(v)),<span class="string">'uint8'</span>).'; typecast(v(:).',<span class="string">'uint8'</span>).'];
0120 <span class="keyword">end</span>
0121 
0122 <span class="comment">% Numeric Matrix: can be real/complex, sparse/full, scalar</span>
0123 <a name="_sub5" href="#_subfunctions" class="code">function m = serialize_numeric(v)</a>
0124     <span class="keyword">if</span> isa(v,<span class="string">'gpuArray'</span>)
0125         m = <a href="#_sub5" class="code" title="subfunction m = serialize_numeric(v)">serialize_numeric</a>(gather(v));
0126     <span class="keyword">elseif</span> issparse(v)
0127         <span class="comment">% Data Type &amp; Dimensions</span>
0128         m = [uint8(130); typecast(uint64(size(v,1)), <span class="string">'uint8'</span>).'; typecast(uint64(size(v,2)), <span class="string">'uint8'</span>).']; <span class="comment">% vectorize</span>
0129         <span class="comment">% Index vectors</span>
0130         [i,j,s] = find(v);        
0131         <span class="comment">% Real/Complex</span>
0132         <span class="keyword">if</span> isreal(v)
0133             m = [m; <a href="#_sub4" class="code" title="subfunction m = serialize_numeric_simple(v)">serialize_numeric_simple</a>(i); <a href="#_sub4" class="code" title="subfunction m = serialize_numeric_simple(v)">serialize_numeric_simple</a>(j); 1; <a href="#_sub4" class="code" title="subfunction m = serialize_numeric_simple(v)">serialize_numeric_simple</a>(s)];
0134         <span class="keyword">else</span>
0135             m = [m; <a href="#_sub4" class="code" title="subfunction m = serialize_numeric_simple(v)">serialize_numeric_simple</a>(i); <a href="#_sub4" class="code" title="subfunction m = serialize_numeric_simple(v)">serialize_numeric_simple</a>(j); 0; <a href="#_sub4" class="code" title="subfunction m = serialize_numeric_simple(v)">serialize_numeric_simple</a>(real(s)); <a href="#_sub4" class="code" title="subfunction m = serialize_numeric_simple(v)">serialize_numeric_simple</a>(imag(s))];
0136         <span class="keyword">end</span>
0137     <span class="keyword">elseif</span> ~isreal(v)
0138         <span class="comment">% Data type &amp; contents</span>
0139         m = [uint8(131); <a href="#_sub4" class="code" title="subfunction m = serialize_numeric_simple(v)">serialize_numeric_simple</a>(real(v)); <a href="#_sub4" class="code" title="subfunction m = serialize_numeric_simple(v)">serialize_numeric_simple</a>(imag(v))];
0140     <span class="keyword">elseif</span> isscalar(v)
0141         <span class="comment">% Scalar</span>
0142         m = <a href="#_sub1" class="code" title="subfunction m = serialize_scalar(v)">serialize_scalar</a>(v);
0143     <span class="keyword">else</span>
0144         <span class="comment">% Simple matrix</span>
0145         m = <a href="#_sub4" class="code" title="subfunction m = serialize_numeric_simple(v)">serialize_numeric_simple</a>(v);
0146     <span class="keyword">end</span>
0147 <span class="keyword">end</span>
0148 
0149 <span class="comment">% Struct array.</span>
0150 <a name="_sub6" href="#_subfunctions" class="code">function m = serialize_struct(v)</a>
0151     <span class="comment">% Tag, Field Count, Field name lengths, Field name char data, #dimensions, dimensions</span>
0152     fieldNames = fieldnames(v);
0153     fnLengths = [length(fieldNames); cellfun(<span class="string">'length'</span>,fieldNames)];
0154     fnChars = [fieldNames{:}];
0155     dims = [ndims(v) size(v)];
0156     m = [uint8(128); typecast(uint32(fnLengths(:)).',<span class="string">'uint8'</span>).'; uint8(fnChars(:)); typecast(uint32(dims), <span class="string">'uint8'</span>).'];
0157     <span class="comment">% Content.</span>
0158     <span class="keyword">if</span> numel(v) &gt; length(fieldNames)
0159         <span class="comment">% more records than field names; serialize each field as a cell array to expose homogenous content</span>
0160         tmp = cellfun(@(f)<a href="#_sub9" class="code" title="subfunction m = serialize_cell(v)">serialize_cell</a>({v.(f)}),fieldNames,<span class="string">'UniformOutput'</span>,false);
0161         m = [m; 0; vertcat(tmp{:})];
0162     <span class="keyword">else</span>
0163         <span class="comment">% more field names than records; use struct2cell</span>
0164         m = [m; 1; <a href="#_sub9" class="code" title="subfunction m = serialize_cell(v)">serialize_cell</a>(struct2cell(v))];
0165     <span class="keyword">end</span>
0166 <span class="keyword">end</span>
0167 
0168 <span class="comment">% Cell array of heterogenous contents</span>
0169 <a name="_sub7" href="#_subfunctions" class="code">function m = serialize_cell_heterogenous(v)</a>
0170     contents = cellfun(@<a href="hlp_serialize.html" class="code" title="function m = hlp_serialize(v)">hlp_serialize</a>,v,<span class="string">'UniformOutput'</span>,false);
0171     m = [uint8(33); ndims(v); typecast(uint32(size(v)),<span class="string">'uint8'</span>).'; vertcat(contents{:})];
0172 <span class="keyword">end</span>
0173 
0174 <span class="comment">% Cell array of homogenously-typed contents</span>
0175 <a name="_sub8" href="#_subfunctions" class="code">function m = serialize_cell_typed(v,serializer)</a>
0176     contents = cellfun(serializer,v,<span class="string">'UniformOutput'</span>,false);
0177     m = [uint8(33); ndims(v); typecast(uint32(size(v)),<span class="string">'uint8'</span>).'; vertcat(contents{:})];
0178 <span class="keyword">end</span>
0179 
0180 <span class="comment">% Cell array</span>
0181 <a name="_sub9" href="#_subfunctions" class="code">function m = serialize_cell(v)</a>
0182     sizeprod = cellfun(<span class="string">'prodofsize'</span>,v);
0183     <span class="keyword">if</span> sizeprod == 1
0184         <span class="comment">% all scalar elements</span>
0185         <span class="keyword">if</span> (all(cellfun(<span class="string">'isclass'</span>,v(:),<span class="string">'double'</span>)) || all(cellfun(<span class="string">'isclass'</span>,v(:),<span class="string">'single'</span>))) &amp;&amp; all(~cellfun(@issparse,v(:)))
0186             <span class="comment">% uniformly typed floating-point scalars (and non-sparse)</span>
0187             reality = cellfun(<span class="string">'isreal'</span>,v);
0188             <span class="keyword">if</span> reality
0189                 <span class="comment">% all real</span>
0190                 m = [uint8(34); <a href="#_sub4" class="code" title="subfunction m = serialize_numeric_simple(v)">serialize_numeric_simple</a>(reshape([v{:}],size(v)))];
0191             <span class="keyword">elseif</span> ~reality
0192                 <span class="comment">% all complex</span>
0193                 m = [uint8(34); <a href="#_sub5" class="code" title="subfunction m = serialize_numeric(v)">serialize_numeric</a>(reshape([v{:}],size(v)))];
0194             <span class="keyword">else</span>
0195                 <span class="comment">% mixed reality</span>
0196                 m = [uint8(35); <a href="#_sub5" class="code" title="subfunction m = serialize_numeric(v)">serialize_numeric</a>(reshape([v{:}],size(v))); <a href="#_sub3" class="code" title="subfunction m = serialize_logical(v)">serialize_logical</a>(reality(:))];
0197             <span class="keyword">end</span>
0198         <span class="keyword">else</span>
0199             <span class="comment">% non-float types</span>
0200             <span class="keyword">if</span> cellfun(<span class="string">'isclass'</span>,v,<span class="string">'struct'</span>)
0201                 <span class="comment">% structs</span>
0202                 m = <a href="#_sub8" class="code" title="subfunction m = serialize_cell_typed(v,serializer)">serialize_cell_typed</a>(v,@<a href="#_sub6" class="code" title="subfunction m = serialize_struct(v)">serialize_struct</a>); 
0203             <span class="keyword">elseif</span> cellfun(<span class="string">'isclass'</span>,v,<span class="string">'cell'</span>)
0204                 <span class="comment">% cells</span>
0205                 m = <a href="#_sub8" class="code" title="subfunction m = serialize_cell_typed(v,serializer)">serialize_cell_typed</a>(v,@<a href="#_sub9" class="code" title="subfunction m = serialize_cell(v)">serialize_cell</a>); 
0206             <span class="keyword">elseif</span> cellfun(<span class="string">'isclass'</span>,v,<span class="string">'logical'</span>)
0207                 <span class="comment">% bool flags</span>
0208                 m = [uint8(39); <a href="#_sub3" class="code" title="subfunction m = serialize_logical(v)">serialize_logical</a>(reshape([v{:}],size(v)))];
0209             <span class="keyword">elseif</span> cellfun(<span class="string">'isclass'</span>,v,<span class="string">'function_handle'</span>)
0210                 <span class="comment">% function handles</span>
0211                 m = <a href="#_sub8" class="code" title="subfunction m = serialize_cell_typed(v,serializer)">serialize_cell_typed</a>(v,@<a href="#_sub11" class="code" title="subfunction m = serialize_handle(v)">serialize_handle</a>); 
0212             <span class="keyword">else</span>
0213                 <span class="comment">% arbitrary / mixed types</span>
0214                 m = <a href="#_sub7" class="code" title="subfunction m = serialize_cell_heterogenous(v)">serialize_cell_heterogenous</a>(v);
0215             <span class="keyword">end</span>
0216         <span class="keyword">end</span>
0217     <span class="keyword">elseif</span> isempty(v)
0218         <span class="comment">% empty cell array</span>
0219         m = [uint8(33); ndims(v); typecast(uint32(size(v)),<span class="string">'uint8'</span>).'];
0220     <span class="keyword">else</span>        
0221         <span class="comment">% some non-scalar elements</span>
0222         dims = cellfun(<span class="string">'ndims'</span>,v);
0223         size1 = cellfun(<span class="string">'size'</span>,v,1);
0224         size2 = cellfun(<span class="string">'size'</span>,v,2);
0225         <span class="keyword">if</span> cellfun(<span class="string">'isclass'</span>,v,<span class="string">'char'</span>) &amp; size1 &lt;= 1 <span class="comment">%#ok&lt;AND2&gt;</span>
0226             <span class="comment">% all horizontal strings or proper empty strings</span>
0227             m = [uint8(36); <a href="#_sub2" class="code" title="subfunction m = serialize_string(v)">serialize_string</a>([v{:}]); <a href="#_sub4" class="code" title="subfunction m = serialize_numeric_simple(v)">serialize_numeric_simple</a>(uint32(size2)); <a href="#_sub3" class="code" title="subfunction m = serialize_logical(v)">serialize_logical</a>(size1(:)==0)];
0228         <span class="keyword">elseif</span> (size1+size2 == 0) &amp; (dims == 2) <span class="comment">%#ok&lt;AND2&gt;</span>
0229             <span class="comment">% all empty and non-degenerate elements</span>
0230             <span class="keyword">if</span> all(cellfun(<span class="string">'isclass'</span>,v(:),<span class="string">'double'</span>)) || all(cellfun(<span class="string">'isclass'</span>,v(:),<span class="string">'cell'</span>)) || all(cellfun(<span class="string">'isclass'</span>,v(:),<span class="string">'struct'</span>))
0231                 <span class="comment">% of standard data types: Tag, Type Tag, #Dims, Dims</span>
0232                 m = [uint8(37); <a href="#_sub12" class="code" title="subfunction b = class2tag(cls)">class2tag</a>(class(v{1})); ndims(v); typecast(uint32(size(v)),<span class="string">'uint8'</span>).'];
0233             <span class="keyword">elseif</span> length(unique(cellfun(@class,v(:),<span class="string">'UniformOutput'</span>,false))) == 1
0234                 <span class="comment">% of uniform class with prototype</span>
0235                 m = [uint8(38); <a href="hlp_serialize.html" class="code" title="function m = hlp_serialize(v)">hlp_serialize</a>(class(v{1})); ndims(v); typecast(uint32(size(v)),<span class="string">'uint8'</span>).'];
0236             <span class="keyword">else</span>
0237                 <span class="comment">% of arbitrary classes</span>
0238                 m = <a href="#_sub7" class="code" title="subfunction m = serialize_cell_heterogenous(v)">serialize_cell_heterogenous</a>(v);
0239             <span class="keyword">end</span>
0240         <span class="keyword">else</span>
0241             <span class="comment">% arbitrary sizes (and types, etc.)</span>
0242             m = <a href="#_sub7" class="code" title="subfunction m = serialize_cell_heterogenous(v)">serialize_cell_heterogenous</a>(v);
0243         <span class="keyword">end</span>
0244     <span class="keyword">end</span>
0245 <span class="keyword">end</span>
0246 
0247 <span class="comment">% Object / class</span>
0248 <a name="_sub10" href="#_subfunctions" class="code">function m = serialize_object(v)</a>
0249     <span class="keyword">try</span>
0250         <span class="comment">% try to use the saveobj method first to get the contents</span>
0251         conts = saveobj(v);
0252         <span class="keyword">if</span> isstruct(conts) || iscell(conts) || isnumeric(conts) || ischar(conts) || islogical(conts) || isa(conts,<span class="string">'function_handle'</span>)
0253             <span class="comment">% contents is something that we can readily serialize</span>
0254             conts = <a href="hlp_serialize.html" class="code" title="function m = hlp_serialize(v)">hlp_serialize</a>(conts);
0255         <span class="keyword">else</span>
0256             <span class="comment">% contents is still an object: turn into a struct now</span>
0257             warning off MATLAB:structOnObject
0258             conts = <a href="#_sub6" class="code" title="subfunction m = serialize_struct(v)">serialize_struct</a>(struct(conts));
0259         <span class="keyword">end</span>
0260     <span class="keyword">catch</span>
0261         <span class="comment">% saveobj failed for this object: turn into a struct</span>
0262         conts = <a href="#_sub6" class="code" title="subfunction m = serialize_struct(v)">serialize_struct</a>(struct(v));
0263     <span class="keyword">end</span>
0264     <span class="comment">% Tag, Class name and Contents</span>
0265     m = [uint8(134); <a href="#_sub2" class="code" title="subfunction m = serialize_string(v)">serialize_string</a>(class(v)); conts];
0266 <span class="keyword">end</span>
0267 
0268 <span class="comment">% Function handle</span>
0269 <a name="_sub11" href="#_subfunctions" class="code">function m = serialize_handle(v) </a>
0270     <span class="comment">% get the representation</span>
0271     t0 = tic;
0272     rep = functions(v);
0273     <span class="comment">% if you are getting this warning, your problem is likely that you created an anonymous function</span>
0274     <span class="comment">% in a workspace that had references to a large amount of data; function handles generally</span>
0275     <span class="comment">% reference the data in their scope (implicitly), which is usually unnecessary except in rare</span>
0276     <span class="comment">% cases where the handle calls an eval or evalin function. To solve this, you need to create the</span>
0277     <span class="comment">% handle in a separate function that references only those variables that you actually need.</span>
0278     <span class="comment">% Note that you may need 2 levels of indirection since the caller's workspace is included in the</span>
0279     <span class="comment">% anonymous function, as well.</span>
0280     <span class="keyword">if</span> toc(t0) &gt; 5
0281         <a href="#_sub13" class="code" title="subfunction warn_once(varargin)">warn_once</a>(<span class="string">'hlp_serialize:large_handle'</span>,<span class="string">'hlp_serialize: the function handle %s took unusually long to process; see hlp_serialize.serialize_handle for how to fix this.\n'</span>,char(v)); <span class="keyword">end</span>
0282     <span class="keyword">switch</span> rep.type
0283         <span class="keyword">case</span> {<span class="string">'simple'</span>,<span class="string">'classsimple'</span>}
0284             <span class="comment">% simple function: Tag &amp; name</span>
0285             m = [uint8(151); <a href="#_sub2" class="code" title="subfunction m = serialize_string(v)">serialize_string</a>(rep.function)];
0286         <span class="keyword">case</span> <span class="string">'anonymous'</span>
0287             <span class="keyword">global</span> tracking; <span class="comment">%#ok&lt;TLEV&gt;</span>
0288             <span class="keyword">if</span> isfield(tracking,<span class="string">'serialize_anonymous_fully'</span>) &amp;&amp; tracking.serialize_anonymous_fully
0289                 <span class="comment">% serialize anonymous function with their entire variable environment (for complete</span>
0290                 <span class="comment">% eval and evalin support). Requires a stack of function id's, as function handles</span>
0291                 <span class="comment">% can reference themselves in their full workspace.</span>
0292                 <span class="keyword">persistent</span> handle_stack; <span class="comment">%#ok&lt;TLEV&gt;</span>
0293                 <span class="comment">% Tag and Code</span>
0294                 m = [uint8(152); <a href="#_sub2" class="code" title="subfunction m = serialize_string(v)">serialize_string</a>(char(v))];
0295                 <span class="comment">% take care of self-references</span>
0296                 str = java.lang.String(rep.function);
0297                 func_id = str.hashCode();
0298                 <span class="keyword">if</span> ~any(handle_stack == func_id)
0299                     <span class="keyword">try</span>
0300                         <span class="comment">% push the function id</span>
0301                         handle_stack(end+1) = func_id;
0302                         <span class="comment">% now serialize workspace</span>
0303                         m = [m; <a href="#_sub6" class="code" title="subfunction m = serialize_struct(v)">serialize_struct</a>(rep.workspace{end})];
0304                         <span class="comment">% pop the ID again</span>
0305                         handle_stack(end) = [];
0306                     <span class="keyword">catch</span> e
0307                         <span class="comment">% note: Ctrl-C can mess up the handle stack</span>
0308                         handle_stack(end) = []; <span class="comment">%#ok&lt;NASGU&gt;</span>
0309                         rethrow(e);
0310                     <span class="keyword">end</span>
0311                 <span class="keyword">else</span>
0312                     <span class="comment">% serialize the empty workspace</span>
0313                     m = [m; <a href="#_sub6" class="code" title="subfunction m = serialize_struct(v)">serialize_struct</a>(struct())];
0314                 <span class="keyword">end</span>
0315                 <span class="keyword">if</span> length(m) &gt; 2^18
0316                     <span class="comment">% If you are getting this warning, it is likely that one of your anonymous functions</span>
0317                     <span class="comment">% was created in a scope that contained large variables; MATLAB will implicitly keep</span>
0318                     <span class="comment">% these variables around (referenced by the function) just in case you refer to them.</span>
0319                     <span class="comment">% To avoid this, you can create the anonymous function instead in a sub-function</span>
0320                     <span class="comment">% to which you only pass the variables that you actually need.</span>
0321                     <a href="#_sub13" class="code" title="subfunction warn_once(varargin)">warn_once</a>(<span class="string">'hlp_serialize:large_handle'</span>,<span class="string">'The function handle with code %s references variables of more than 256k bytes; this is likely very slow.'</span>,rep.function); 
0322                 <span class="keyword">end</span>
0323             <span class="keyword">else</span>
0324                 <span class="comment">% anonymous function: Tag, Code, and reduced workspace</span>
0325                 <span class="keyword">if</span> ~isempty(rep.workspace)
0326                     m = [uint8(152); <a href="#_sub2" class="code" title="subfunction m = serialize_string(v)">serialize_string</a>(char(v)); <a href="#_sub6" class="code" title="subfunction m = serialize_struct(v)">serialize_struct</a>(rep.workspace{1})];
0327                 <span class="keyword">else</span>
0328                     m = [uint8(152); <a href="#_sub2" class="code" title="subfunction m = serialize_string(v)">serialize_string</a>(char(v)); <a href="#_sub6" class="code" title="subfunction m = serialize_struct(v)">serialize_struct</a>(struct())];
0329                 <span class="keyword">end</span>
0330             <span class="keyword">end</span>
0331         <span class="keyword">case</span> {<span class="string">'scopedfunction'</span>,<span class="string">'nested'</span>}
0332             <span class="comment">% scoped function: Tag and Parentage</span>
0333             m = [uint8(153); <a href="#_sub9" class="code" title="subfunction m = serialize_cell(v)">serialize_cell</a>(rep.parentage)];
0334         <span class="keyword">otherwise</span>
0335             <a href="#_sub13" class="code" title="subfunction warn_once(varargin)">warn_once</a>(<span class="string">'hlp_serialize:unknown_handle_type'</span>,<span class="string">'A function handle with unsupported type &quot;%s&quot; was encountered; using a placeholder instead.'</span>,rep.type); 
0336             m = <a href="#_sub2" class="code" title="subfunction m = serialize_string(v)">serialize_string</a>([<span class="string">'&lt;&lt;hlp_serialize: function handle of type '</span> rep.type <span class="string">' unsupported&gt;&gt;'</span>]);
0337     <span class="keyword">end</span>
0338 <span class="keyword">end</span>
0339 
0340 <span class="comment">% *container* class to byte</span>
0341 <a name="_sub12" href="#_subfunctions" class="code">function b = class2tag(cls)</a>
0342     <span class="keyword">switch</span> cls
0343         <span class="keyword">case</span> <span class="string">'string'</span>
0344             b = uint8(0);
0345         <span class="keyword">case</span> <span class="string">'double'</span>
0346             b = uint8(1);
0347         <span class="keyword">case</span> <span class="string">'single'</span>
0348             b = uint8(2);
0349         <span class="keyword">case</span> <span class="string">'int8'</span>
0350             b = uint8(3);
0351         <span class="keyword">case</span> <span class="string">'uint8'</span>
0352             b = uint8(4);
0353         <span class="keyword">case</span> <span class="string">'int16'</span>
0354             b = uint8(5);
0355         <span class="keyword">case</span> <span class="string">'uint16'</span>
0356             b = uint8(6);
0357         <span class="keyword">case</span> <span class="string">'int32'</span>
0358             b = uint8(7);
0359         <span class="keyword">case</span> <span class="string">'uint32'</span>
0360             b = uint8(8);
0361         <span class="keyword">case</span> <span class="string">'int64'</span>
0362             b = uint8(9);
0363         <span class="keyword">case</span> <span class="string">'uint64'</span>
0364             b = uint8(10);
0365               
0366         <span class="comment">% other tags are as follows:</span>
0367         <span class="comment">% % offset by +16: scalar variants of these...</span>
0368         <span class="keyword">case</span> <span class="string">'cell'</span>
0369             b = uint8(33);
0370         <span class="keyword">case</span> <span class="string">'cellscalars'</span>
0371             b = uint8(34);
0372         <span class="keyword">case</span> <span class="string">'cellscalarsmixed'</span>
0373             b = uint8(35);
0374         <span class="keyword">case</span> <span class="string">'cellstrings'</span>
0375             b = uint8(36);
0376         <span class="keyword">case</span> <span class="string">'cellempty'</span>
0377             b = uint8(37);
0378         <span class="keyword">case</span> <span class="string">'cellemptyprot'</span>
0379             b = uint8(38);
0380         <span class="keyword">case</span> <span class="string">'cellbools'</span>
0381             b = uint8(39);
0382         <span class="keyword">case</span> <span class="string">'struct'</span>
0383             b = uint8(128);
0384         <span class="keyword">case</span> <span class="string">'sparse'</span>
0385             b = uint8(130);
0386         <span class="keyword">case</span> <span class="string">'complex'</span>
0387             b = uint8(131);
0388         <span class="keyword">case</span> <span class="string">'char'</span>
0389             b = uint8(132);
0390         <span class="keyword">case</span> <span class="string">'logical'</span>
0391             b = uint8(133);
0392         <span class="keyword">case</span> <span class="string">'object'</span>
0393             b = uint8(134);
0394         <span class="keyword">case</span> <span class="string">'function_handle'</span>
0395             b = uint8(150);
0396         <span class="keyword">case</span> <span class="string">'function_simple'</span>
0397             b = uint8(151);
0398         <span class="keyword">case</span> <span class="string">'function_anon'</span>
0399             b = uint8(152);
0400         <span class="keyword">case</span> <span class="string">'function_scoped'</span>
0401             b = uint8(153);
0402         <span class="keyword">case</span> <span class="string">'emptystring'</span>
0403             b = uint8(200);
0404 
0405         <span class="keyword">otherwise</span>
0406             error([<span class="string">'Unknown class: '</span> cls]);
0407     <span class="keyword">end</span>
0408 <span class="keyword">end</span>
0409 
0410 <span class="comment">% emit a specific warning only once (per MATLAB session)</span>
0411 <a name="_sub13" href="#_subfunctions" class="code">function warn_once(varargin)</a>
0412 <span class="keyword">persistent</span> displayed_warnings;
0413 <span class="comment">% determine the message content</span>
0414 <span class="keyword">if</span> length(varargin) &gt; 1 &amp;&amp; any(varargin{1}==<span class="string">':'</span>) &amp;&amp; ~any(varargin{1}==<span class="string">' '</span>) &amp;&amp; ischar(varargin{2})
0415     message_content = [varargin{1} sprintf(varargin{2:end})];
0416 <span class="keyword">else</span>
0417     message_content = sprintf(varargin{1:end});
0418 <span class="keyword">end</span>
0419 <span class="comment">% generate a hash of of the message content</span>
0420 str = java.lang.String(message_content);
0421 message_id = sprintf(<span class="string">'x%.0f'</span>,str.hashCode()+2^31);
0422 <span class="comment">% and check if it had been displayed before</span>
0423 <span class="keyword">if</span> ~isfield(displayed_warnings,message_id)
0424     <span class="comment">% emit the warning</span>
0425     warning(varargin{:});
0426     <span class="comment">% remember to not display the warning again</span>
0427     displayed_warnings.(message_id) = true;
0428 <span class="keyword">end</span>
0429 <span class="keyword">end</span></pre></div>

<hr><address>Generated on Wed 19-Aug-2015 18:06:23 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>