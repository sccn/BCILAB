<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of flt_ica</title>
  <meta name="keywords" content="flt_ica">
  <meta name="description" content="Annotate the Signal with a spatial decomposition into independent components (using ICA)">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="#">code</a> &gt; <a href="index.html">filters</a> &gt; flt_ica.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for code/filters&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>flt_ica

</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>Annotate the Signal with a spatial decomposition into independent components (using ICA)</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [signal,state] = flt_ica(varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Annotate the Signal with a spatial decomposition into independent components (using ICA)
 [Signal,State] = flt_ica(Signal, Variant, CleaningLevel, TransformData, OutputCleanedData, ResumePrevious)

 The IC-decomposed signal [1] can be considered to have &quot;better&quot; channels than the raw sensor
 signal, for several reasons:
  * The components are less correlated than the raw channels, which allows for easier-to-handle
    statistical assumptions in higher levels (e.g. using diagonal covariance matrices).
  * The relevant information can be assumed to be localized in only a small subset of the
    components, where the majority of components will carry less relevant data; this allows for the
    assumption of (channel-wise) sparsity in the derived features (e.g. using l1-regularized
    classifiers and/or feature extractors).
  * The components have a higher degree of semantic meaning than channels (which needs to be
    computed, though), such as the presence of eye artifacts, muscle artifacts, brain activity,
    etc.
  * A fraction of components can be localized in the brain using dipole fitting, beamforming,
    sparse bayesian learning, and other methods, which gives access to semantics that can be
    derived/computed from the component's location in the brain (e.g., postcentral gyrus -&gt; high
    chance of touch-related brain activity, etc.).

 In:
   Signal     : a continuous data set

   Variant    : type of ICA model to run (default: 'amica'), possible values are:
                'amica' : AMICA [2] is currently the best-of-breed ICA method and generally
                          preferred. (default) It uses a flexible model of source signal densities
                          (generalized gaussian scale mixtures) which allow it to obtain better
                          solutions for EEG data (in terms of statistical independence) than the
                          other available methods; furthermore, multiple models can be learned,
                          which allow it to capture non-stationarities in a principled manner. If
                          available, a binary implementation is used. Options: help runamica
                'infomax' : (extended) Infomax [3] is the second-best approach to ICA for EEG data,
                            and may be faster than the MATLAB implementation of AMICA, or possibly
                            easier to handle. If available, a binary implementation is used.
                            Options: help runica
                'beamica' : essentially Infomax in its default setting, but offers the option of 
                            constraining solutions with the help of beamforming. The fastest ICA 
                            implementation in the toolbox (especially when run on a fast GPU).
                'fastica' : FastICA [4] is a relatively simple ICA implementation, which is
                            converges relatively quickly, though at the expense of solution
                            quality. In many cases it can not attain results as good as extended
                            Infomax or AMICA, but for repeated computations (e.g. inside a
                            cross-validation) it can be a reasonable choice due to its speed.
                            Options: help fastica
                'rica' : (overcomplete) Reconstruction ICA [7] is a novel fast ICA approach that allows
                         to learn arbitrarily over-complete decompositions.
                'kernelica' : KernelICA [5] has a similarly flexible model of source densities as
                              AMICA, using a kernel approach, but requires massive computation
                              time, so KernelICA can realistically at best be used on small data
                              sets. Options: help kernel_ica_options
                'sphere' : just the spering matrix (second-order)
                'robust_spere' : the robust sphering matrix (estimated under super-Gaussian noise)
                others, if in path: 'jader','jadeop','jade_td_p','MatlabshibbsR','tica','erica',
                                    'simbec','unica','amuse','fobi','evd','evd24','sons','sobi',
                                    'ng_ol','acsobiro','acrsobibpf','pearson_ica','egld_ica','eeA',
                                    'tfbss','icaML','icaMS'.

                Note: each of these variants has its own set of sub-parameters, which can be
                specified by passing Variant as a cell array, e.g., {'amica', 'num_models',3, 'max_iter',1000}

                For a full list of these parameters, review either the argument specification below
                or the review/edit approach panel (under ICA)

   DataCleaning : Parameters for data cleaning prior to running an EEG; this is a cell array of 
                  parameters for the function flt_clean_settings. In the simplest case, it is just
                  a setting string (e.g. 'seated', 'noisy', 'walking', 'running')

   TransformData : whether to place the decomposition result in the actual channel data instead of
                   in an additional annotation field of the output data set (.icaact). (default: false)

   OutputCleanedData : whether to output the cleaned version of the data instead of the original
                       version of the data; by default, the cleaned data is only used to compute a
                       better decomposition, while the (decomposed) original data is what is returned
                       (default: false)

   ResumePrevious : whether to try to resume from a previous computation (on the same data), if
                    applicable (default: true)

   State      : state, for online updates (default: [])

 Out:
   Signal : continuous data set annotated with an ICA decomposition, and optionally with data
            transformed into IC activations

 Notes:
   Only the first two arguments can be specified without passing them by name.

 Examples:
   % annotate the data set with an ICA decomposition, using default settings
   eeg = flt_ica(eeg)

   % do an ICA decomposition using Infomax
   eeg = flt_ica(eeg, 'infomax')

   % do an ICA decomposition using Infomax and transform the actual channel data (so that
   % channel-based methods end up operating on components)
   eeg = flt_ica(eeg, 'infomax', 'TransformData',true)

   % do an ICA decomposition using Infomax and pass a specific cleaning level
   eeg = flt_ica(eeg, 'infomax', 'CleaningLevel','hardcore')

   % do an ICA decomposition using Infomax, pass a specific cleaning level, and override some
   parameters to infomax
   eeg = flt_ica(eeg, {'infomax' 'MaxIterations',300}, 'CleaningLevel','hardcore')

   % as before, but pass all arguments by name (recommended to avoid confusion)
   eeg = flt_ica('Signal',eeg, 'Variant',{'infomax' 'MaxIterations',300}, 'CleaningLevel','hardcore')

   % do an ICA decomposition using amica and specify some of its parameters (and use a custom cleaning level)
   eeg = flt_ica('Signal',eeg, 'Variant',{'amica', 'NumModels',3, 'MaxIterations',1000}, 'CleaningLevel','hardcore')

   % run an AMICA and don't try to use the cluster (i.e., run locally)
   eeg = flt_ica('Signal',eeg, 'Variant',{'amica', 'UseGridEngine','off'})

   % do a multi-model amica decomposition using 3 models using 16 slots on the cluster, and do some
   % moderate artifact handling
   eeg = flt_ica('Signal',eeg, 'Variant',{'amica', 'NumModels',3, 'NumProcessors',16}, 'CleaningLevel','strong')

   % do a quick-and-dirty FastICA
   eeg = flt_ica(eeg, {'fastica', 'MaxIterations',100})

   % do a super-slow Kernel ICA on highly cleaned data
   eeg = flt_ica(eeg,'kernelica','CleaningLevel','ultrahardcore')


 References:
   [1] Makeig S., Bell A.J., Jung T-P. and Sejnowski T.J. 1995. &quot;Independent Component Analysis of Electroencephalographic Data&quot;
       in Mozer M. et al (eds) Advances in Neural Information Processing Systems 8, MIT press
   [2] J. A. Palmer, S. Makeig, K. Kreutz-Delgado, and B. D. Rao, &quot;Newton Method for the ICA Mixture Model&quot;.
       In Proceedings of the 33rd IEEE International Conference on Acoustics and Signal Processing (ICASSP 2008), Las Vegas, NV, pp. 1805-1808, 2008.
   [3] Bell, A. J., and Sejnowski, T. J. &quot;An information-maximization approach to blind separation and blind deconvolution.&quot;
       Neural Comput. 7, 6 (1995), 1129?1159.
   [4] A. Hyvaerinen. &quot;Fast and Robust Fixed-Point Algorithms for Independent Component Analysis.&quot;
       IEEE Transactions on Neural Networks 10(3):626-634, 1999.
   [5] Francis R. Bach, Michael I. Jordan. &quot;Kernel Independent Component Analysis&quot;,
       Journal of Machine Learning Research, 3, 1-48, 2002
   [6] H. Shen, S. Jegelka and A. Gretton. &quot;Fast Kernel ICA using an approximate Newton method.&quot;
       AISTATS 2007.
   [7] Q.V. Le, A. Karpenko, J. Ngiam, A.Y. Ng. &quot;ICA with Reconstruction Cost for Efficient Overcomplete Feature Learning.&quot;
       NIPS 2011

 See also:
   runica, runamica11, fastica, kernel_ica_options, <a href="flt_clean_channels.html" class="code" title="function signal = flt_clean_channels(varargin)">flt_clean_channels</a>, <a href="flt_clean_windows.html" class="code" title="function signal = flt_clean_windows(varargin)">flt_clean_windows</a>, flt_clean_peaks

 TODO:
   Add robust and CUDA ICA's.

                                Christian Kothe, Swartz Center for Computational Neuroscience, UCSD
                                2010-04-17</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">

<li><a href="flt_clean_settings.html" class="code" title="function signal = flt_clean_settings(varargin)">flt_clean_settings</a>	Clean EEG data according to a particular cleaning setting.</li>
</ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">

</ul>
<!-- crossreference -->


<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">

<li><a href="#_sub1" class="code">function [job,result,t0,iter_times,maxiters,lastlines,job_started,early_finish] = schedule_amica(X,scheduler,amica_version,logfile,varargin)</a></li>
<li><a href="#_sub2" class="code">function r = amica_native(pre,variant)</a></li>
<li><a href="#_sub3" class="code">function delete_job(id,scheduler,outdir)</a></li>
</ul>




<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [signal,state] = flt_ica(varargin)</a>
0002 <span class="comment">% Annotate the Signal with a spatial decomposition into independent components (using ICA)</span>
0003 <span class="comment">% [Signal,State] = flt_ica(Signal, Variant, CleaningLevel, TransformData, OutputCleanedData, ResumePrevious)</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% The IC-decomposed signal [1] can be considered to have &quot;better&quot; channels than the raw sensor</span>
0006 <span class="comment">% signal, for several reasons:</span>
0007 <span class="comment">%  * The components are less correlated than the raw channels, which allows for easier-to-handle</span>
0008 <span class="comment">%    statistical assumptions in higher levels (e.g. using diagonal covariance matrices).</span>
0009 <span class="comment">%  * The relevant information can be assumed to be localized in only a small subset of the</span>
0010 <span class="comment">%    components, where the majority of components will carry less relevant data; this allows for the</span>
0011 <span class="comment">%    assumption of (channel-wise) sparsity in the derived features (e.g. using l1-regularized</span>
0012 <span class="comment">%    classifiers and/or feature extractors).</span>
0013 <span class="comment">%  * The components have a higher degree of semantic meaning than channels (which needs to be</span>
0014 <span class="comment">%    computed, though), such as the presence of eye artifacts, muscle artifacts, brain activity,</span>
0015 <span class="comment">%    etc.</span>
0016 <span class="comment">%  * A fraction of components can be localized in the brain using dipole fitting, beamforming,</span>
0017 <span class="comment">%    sparse bayesian learning, and other methods, which gives access to semantics that can be</span>
0018 <span class="comment">%    derived/computed from the component's location in the brain (e.g., postcentral gyrus -&gt; high</span>
0019 <span class="comment">%    chance of touch-related brain activity, etc.).</span>
0020 <span class="comment">%</span>
0021 <span class="comment">% In:</span>
0022 <span class="comment">%   Signal     : a continuous data set</span>
0023 <span class="comment">%</span>
0024 <span class="comment">%   Variant    : type of ICA model to run (default: 'amica'), possible values are:</span>
0025 <span class="comment">%                'amica' : AMICA [2] is currently the best-of-breed ICA method and generally</span>
0026 <span class="comment">%                          preferred. (default) It uses a flexible model of source signal densities</span>
0027 <span class="comment">%                          (generalized gaussian scale mixtures) which allow it to obtain better</span>
0028 <span class="comment">%                          solutions for EEG data (in terms of statistical independence) than the</span>
0029 <span class="comment">%                          other available methods; furthermore, multiple models can be learned,</span>
0030 <span class="comment">%                          which allow it to capture non-stationarities in a principled manner. If</span>
0031 <span class="comment">%                          available, a binary implementation is used. Options: help runamica</span>
0032 <span class="comment">%                'infomax' : (extended) Infomax [3] is the second-best approach to ICA for EEG data,</span>
0033 <span class="comment">%                            and may be faster than the MATLAB implementation of AMICA, or possibly</span>
0034 <span class="comment">%                            easier to handle. If available, a binary implementation is used.</span>
0035 <span class="comment">%                            Options: help runica</span>
0036 <span class="comment">%                'beamica' : essentially Infomax in its default setting, but offers the option of</span>
0037 <span class="comment">%                            constraining solutions with the help of beamforming. The fastest ICA</span>
0038 <span class="comment">%                            implementation in the toolbox (especially when run on a fast GPU).</span>
0039 <span class="comment">%                'fastica' : FastICA [4] is a relatively simple ICA implementation, which is</span>
0040 <span class="comment">%                            converges relatively quickly, though at the expense of solution</span>
0041 <span class="comment">%                            quality. In many cases it can not attain results as good as extended</span>
0042 <span class="comment">%                            Infomax or AMICA, but for repeated computations (e.g. inside a</span>
0043 <span class="comment">%                            cross-validation) it can be a reasonable choice due to its speed.</span>
0044 <span class="comment">%                            Options: help fastica</span>
0045 <span class="comment">%                'rica' : (overcomplete) Reconstruction ICA [7] is a novel fast ICA approach that allows</span>
0046 <span class="comment">%                         to learn arbitrarily over-complete decompositions.</span>
0047 <span class="comment">%                'kernelica' : KernelICA [5] has a similarly flexible model of source densities as</span>
0048 <span class="comment">%                              AMICA, using a kernel approach, but requires massive computation</span>
0049 <span class="comment">%                              time, so KernelICA can realistically at best be used on small data</span>
0050 <span class="comment">%                              sets. Options: help kernel_ica_options</span>
0051 <span class="comment">%                'sphere' : just the spering matrix (second-order)</span>
0052 <span class="comment">%                'robust_spere' : the robust sphering matrix (estimated under super-Gaussian noise)</span>
0053 <span class="comment">%                others, if in path: 'jader','jadeop','jade_td_p','MatlabshibbsR','tica','erica',</span>
0054 <span class="comment">%                                    'simbec','unica','amuse','fobi','evd','evd24','sons','sobi',</span>
0055 <span class="comment">%                                    'ng_ol','acsobiro','acrsobibpf','pearson_ica','egld_ica','eeA',</span>
0056 <span class="comment">%                                    'tfbss','icaML','icaMS'.</span>
0057 <span class="comment">%</span>
0058 <span class="comment">%                Note: each of these variants has its own set of sub-parameters, which can be</span>
0059 <span class="comment">%                specified by passing Variant as a cell array, e.g., {'amica', 'num_models',3, 'max_iter',1000}</span>
0060 <span class="comment">%</span>
0061 <span class="comment">%                For a full list of these parameters, review either the argument specification below</span>
0062 <span class="comment">%                or the review/edit approach panel (under ICA)</span>
0063 <span class="comment">%</span>
0064 <span class="comment">%   DataCleaning : Parameters for data cleaning prior to running an EEG; this is a cell array of</span>
0065 <span class="comment">%                  parameters for the function flt_clean_settings. In the simplest case, it is just</span>
0066 <span class="comment">%                  a setting string (e.g. 'seated', 'noisy', 'walking', 'running')</span>
0067 <span class="comment">%</span>
0068 <span class="comment">%   TransformData : whether to place the decomposition result in the actual channel data instead of</span>
0069 <span class="comment">%                   in an additional annotation field of the output data set (.icaact). (default: false)</span>
0070 <span class="comment">%</span>
0071 <span class="comment">%   OutputCleanedData : whether to output the cleaned version of the data instead of the original</span>
0072 <span class="comment">%                       version of the data; by default, the cleaned data is only used to compute a</span>
0073 <span class="comment">%                       better decomposition, while the (decomposed) original data is what is returned</span>
0074 <span class="comment">%                       (default: false)</span>
0075 <span class="comment">%</span>
0076 <span class="comment">%   ResumePrevious : whether to try to resume from a previous computation (on the same data), if</span>
0077 <span class="comment">%                    applicable (default: true)</span>
0078 <span class="comment">%</span>
0079 <span class="comment">%   State      : state, for online updates (default: [])</span>
0080 <span class="comment">%</span>
0081 <span class="comment">% Out:</span>
0082 <span class="comment">%   Signal : continuous data set annotated with an ICA decomposition, and optionally with data</span>
0083 <span class="comment">%            transformed into IC activations</span>
0084 <span class="comment">%</span>
0085 <span class="comment">% Notes:</span>
0086 <span class="comment">%   Only the first two arguments can be specified without passing them by name.</span>
0087 <span class="comment">%</span>
0088 <span class="comment">% Examples:</span>
0089 <span class="comment">%   % annotate the data set with an ICA decomposition, using default settings</span>
0090 <span class="comment">%   eeg = flt_ica(eeg)</span>
0091 <span class="comment">%</span>
0092 <span class="comment">%   % do an ICA decomposition using Infomax</span>
0093 <span class="comment">%   eeg = flt_ica(eeg, 'infomax')</span>
0094 <span class="comment">%</span>
0095 <span class="comment">%   % do an ICA decomposition using Infomax and transform the actual channel data (so that</span>
0096 <span class="comment">%   % channel-based methods end up operating on components)</span>
0097 <span class="comment">%   eeg = flt_ica(eeg, 'infomax', 'TransformData',true)</span>
0098 <span class="comment">%</span>
0099 <span class="comment">%   % do an ICA decomposition using Infomax and pass a specific cleaning level</span>
0100 <span class="comment">%   eeg = flt_ica(eeg, 'infomax', 'CleaningLevel','hardcore')</span>
0101 <span class="comment">%</span>
0102 <span class="comment">%   % do an ICA decomposition using Infomax, pass a specific cleaning level, and override some</span>
0103 <span class="comment">%   parameters to infomax</span>
0104 <span class="comment">%   eeg = flt_ica(eeg, {'infomax' 'MaxIterations',300}, 'CleaningLevel','hardcore')</span>
0105 <span class="comment">%</span>
0106 <span class="comment">%   % as before, but pass all arguments by name (recommended to avoid confusion)</span>
0107 <span class="comment">%   eeg = flt_ica('Signal',eeg, 'Variant',{'infomax' 'MaxIterations',300}, 'CleaningLevel','hardcore')</span>
0108 <span class="comment">%</span>
0109 <span class="comment">%   % do an ICA decomposition using amica and specify some of its parameters (and use a custom cleaning level)</span>
0110 <span class="comment">%   eeg = flt_ica('Signal',eeg, 'Variant',{'amica', 'NumModels',3, 'MaxIterations',1000}, 'CleaningLevel','hardcore')</span>
0111 <span class="comment">%</span>
0112 <span class="comment">%   % run an AMICA and don't try to use the cluster (i.e., run locally)</span>
0113 <span class="comment">%   eeg = flt_ica('Signal',eeg, 'Variant',{'amica', 'UseGridEngine','off'})</span>
0114 <span class="comment">%</span>
0115 <span class="comment">%   % do a multi-model amica decomposition using 3 models using 16 slots on the cluster, and do some</span>
0116 <span class="comment">%   % moderate artifact handling</span>
0117 <span class="comment">%   eeg = flt_ica('Signal',eeg, 'Variant',{'amica', 'NumModels',3, 'NumProcessors',16}, 'CleaningLevel','strong')</span>
0118 <span class="comment">%</span>
0119 <span class="comment">%   % do a quick-and-dirty FastICA</span>
0120 <span class="comment">%   eeg = flt_ica(eeg, {'fastica', 'MaxIterations',100})</span>
0121 <span class="comment">%</span>
0122 <span class="comment">%   % do a super-slow Kernel ICA on highly cleaned data</span>
0123 <span class="comment">%   eeg = flt_ica(eeg,'kernelica','CleaningLevel','ultrahardcore')</span>
0124 <span class="comment">%</span>
0125 <span class="comment">%</span>
0126 <span class="comment">% References:</span>
0127 <span class="comment">%   [1] Makeig S., Bell A.J., Jung T-P. and Sejnowski T.J. 1995. &quot;Independent Component Analysis of Electroencephalographic Data&quot;</span>
0128 <span class="comment">%       in Mozer M. et al (eds) Advances in Neural Information Processing Systems 8, MIT press</span>
0129 <span class="comment">%   [2] J. A. Palmer, S. Makeig, K. Kreutz-Delgado, and B. D. Rao, &quot;Newton Method for the ICA Mixture Model&quot;.</span>
0130 <span class="comment">%       In Proceedings of the 33rd IEEE International Conference on Acoustics and Signal Processing (ICASSP 2008), Las Vegas, NV, pp. 1805-1808, 2008.</span>
0131 <span class="comment">%   [3] Bell, A. J., and Sejnowski, T. J. &quot;An information-maximization approach to blind separation and blind deconvolution.&quot;</span>
0132 <span class="comment">%       Neural Comput. 7, 6 (1995), 1129?1159.</span>
0133 <span class="comment">%   [4] A. Hyvaerinen. &quot;Fast and Robust Fixed-Point Algorithms for Independent Component Analysis.&quot;</span>
0134 <span class="comment">%       IEEE Transactions on Neural Networks 10(3):626-634, 1999.</span>
0135 <span class="comment">%   [5] Francis R. Bach, Michael I. Jordan. &quot;Kernel Independent Component Analysis&quot;,</span>
0136 <span class="comment">%       Journal of Machine Learning Research, 3, 1-48, 2002</span>
0137 <span class="comment">%   [6] H. Shen, S. Jegelka and A. Gretton. &quot;Fast Kernel ICA using an approximate Newton method.&quot;</span>
0138 <span class="comment">%       AISTATS 2007.</span>
0139 <span class="comment">%   [7] Q.V. Le, A. Karpenko, J. Ngiam, A.Y. Ng. &quot;ICA with Reconstruction Cost for Efficient Overcomplete Feature Learning.&quot;</span>
0140 <span class="comment">%       NIPS 2011</span>
0141 <span class="comment">%</span>
0142 <span class="comment">% See also:</span>
0143 <span class="comment">%   runica, runamica11, fastica, kernel_ica_options, flt_clean_channels, flt_clean_windows, flt_clean_peaks</span>
0144 <span class="comment">%</span>
0145 <span class="comment">% TODO:</span>
0146 <span class="comment">%   Add robust and CUDA ICA's.</span>
0147 <span class="comment">%</span>
0148 <span class="comment">%                                Christian Kothe, Swartz Center for Computational Neuroscience, UCSD</span>
0149 <span class="comment">%                                2010-04-17</span>
0150 
0151 <span class="comment">% flt_ica_version&lt;1.2.11&gt; -- for the cache</span>
0152 
0153 
0154 <span class="keyword">if</span> ~exp_beginfun(<span class="string">'filter'</span>) <span class="keyword">return</span>; <span class="keyword">end</span>
0155 
0156 <span class="comment">% has its own highpass filter, sometimes applied on re-referenced data</span>
0157 declare_properties(<span class="string">'name'</span>,<span class="string">'ICA'</span>, <span class="string">'precedes'</span>,{<span class="string">'flt_fir'</span>,<span class="string">'flt_iir'</span>}, <span class="string">'follows'</span>,<span class="string">'flt_reref'</span>, <span class="string">'independent_trials'</span>,false, <span class="string">'independent_channels'</span>,false);
0158 
0159 arg_define([0 2],varargin, <span class="keyword">...</span>
0160     arg_norep({<span class="string">'signal'</span>,<span class="string">'Signal'</span>}), <span class="keyword">...</span>
0161     arg_subswitch({<span class="string">'variant'</span>,<span class="string">'Variant'</span>},<span class="string">'infomax'</span>,{ <span class="keyword">...</span>
0162     <span class="string">'noica'</span>, {}, <span class="keyword">...</span><span class="comment">  % noICA is a testing variant with no arguments</span>
0163     <span class="string">'amica'</span>, { <span class="keyword">...</span>
0164         arg({<span class="string">'amica_version'</span>,<span class="string">'AmicaVersion'</span>,<span class="string">'version'</span>},<span class="string">'stable11'</span>,{<span class="string">'devel'</span>,<span class="string">'stable11'</span>,<span class="string">'stable12'</span>,<span class="string">'stable'</span>,<span class="string">'matlab'</span>},<span class="string">'Amica version to use. The stable12 is cross-platform, stable11 has been tested extensively on the SCCN cluster, and the matlab version should run everywhere.'</span>,<span class="string">'cat'</span>,<span class="string">'Miscellaneous'</span>), <span class="keyword">...</span>
0165         arg({<span class="string">'max_iter'</span>,<span class="string">'MaxIterations'</span>},2500,uint32([1 10000]),<span class="string">'Maximum number of iterations to perform.'</span>,<span class="string">'cat'</span>,<span class="string">'Core Parameters'</span>), <span class="keyword">...</span>
0166         arg({<span class="string">'num_models'</span>,<span class="string">'NumModels'</span>},1, uint32([1 20]),<span class="string">'Number of models to learn. Per model, approx. 100,000 data points are needed at 100 channels.'</span>,<span class="string">'cat'</span>,<span class="string">'Core Parameters'</span>), <span class="keyword">...</span>
0167         arg({<span class="string">'num_mix_comps'</span>,<span class="string">'NumMixtureComponents'</span>},3, uint32([1 15]),<span class="string">'Number of mixture components to learn. This is per source.'</span>,<span class="string">'cat'</span>,<span class="string">'Core Parameters'</span>), <span class="keyword">...</span>
0168         arg({<span class="string">'pdftype'</span>,<span class="string">'TypeOfPDF'</span>},<span class="string">'GeneralizedGaussian'</span>,{<span class="string">'GeneralizedGaussian'</span>,<span class="string">'ExtendedInfomax'</span>,<span class="string">'Gaussian'</span>,<span class="string">'Logistic'</span>},<span class="string">'Probability density type for source model.'</span>,<span class="string">'cat'</span>,<span class="string">'Core Parameters'</span>), <span class="keyword">...</span>
0169         arg({<span class="string">'share_comps'</span>,<span class="string">'ShareComponents'</span>},false,[],<span class="string">'Flag to share components when num_models &gt; 1.'</span>,<span class="string">'cat'</span>,<span class="string">'Core Parameters'</span>), <span class="keyword">...</span>
0170         <span class="keyword">...</span>
0171         arg({<span class="string">'max_threads'</span>,<span class="string">'MaxThreads'</span>},[],[],<span class="string">'Number of threads per node. If this is too high, churn kicks in (especially between users on a shared cluster).'</span>,<span class="string">'cat'</span>,<span class="string">'Compute Resources'</span>,<span class="string">'shape'</span>,<span class="string">'scalar'</span>), <span class="keyword">...</span>
0172         arg({<span class="string">'useqsub'</span>,<span class="string">'UseGridEngine'</span>,<span class="string">'qsub'</span>},quickif(isdeployed,<span class="string">'off'</span>,<span class="string">'on'</span>),{<span class="string">'on'</span>,<span class="string">'off'</span>},<span class="string">'Use Sun Grid Engine cluster. Assumes qsub; the alternative is to run locally.'</span>,<span class="string">'cat'</span>,<span class="string">'Compute Resources'</span>), <span class="keyword">...</span>
0173         arg({<span class="string">'use_queue'</span>,<span class="string">'UseQueue'</span>},{<span class="string">'q3:32'</span>,<span class="string">'q4:32'</span>,<span class="string">'q5:32'</span>,<span class="string">'q6:32'</span>,<span class="string">'q7:32'</span>,<span class="string">'q8:32'</span>,<span class="string">'q9:32'</span>,<span class="string">'q10:32'</span>,<span class="string">'qa1:64'</span>,<span class="string">'qa2:64'</span>,<span class="string">'qa3:64'</span>,<span class="string">'qa4:64'</span>},[],<span class="string">'Grid Engine queue to use. If this is a cell array of queue names (of the form name:xx, where xx is the number of processors required to be available), a free queue will be identified automatically (and the respective number of available processors will be used as numprocs). flt_ica will wait and print a notification if no queue is available.'</span>,<span class="string">'cat'</span>,<span class="string">'Compute Resources'</span>), <span class="keyword">...</span>
0174         arg({<span class="string">'use_pe'</span>,<span class="string">'ParallelEnvironment'</span>},<span class="string">'autodetect'</span>,{<span class="string">'autodetect'</span>,<span class="string">'mpich'</span>,<span class="string">'orte'</span>,<span class="string">'make'</span>},<span class="string">'Parallel environment to use. Only recognized by the ''stable11'' and ''stable12'' versions.'</span>,<span class="string">'cat'</span>,<span class="string">'Compute Resources'</span>), <span class="keyword">...</span>
0175         arg({<span class="string">'numprocs'</span>,<span class="string">'NumProcessors'</span>,<span class="string">'num_procs'</span>},32, uint32([1 128]),<span class="string">'Number or processors to use. If use_queue was used with auto-detection, the # of slots in the queue will be used as numprocs.'</span>,<span class="string">'cat'</span>,<span class="string">'Compute Resources'</span>), <span class="keyword">...</span>
0176         arg({<span class="string">'poll_interval'</span>,<span class="string">'PollInterval'</span>},10,[0 Inf],<span class="string">'Check Amica status every n secs. Used to monitor Amica''s progress, if running on a cluster.'</span>,<span class="string">'cat'</span>,<span class="string">'Compute Resources'</span>), <span class="keyword">...</span>
0177         arg({<span class="string">'max_start_waiting'</span>,<span class="string">'MaxStartWaiting'</span>},600,[0 Inf],<span class="string">'Maximum wait time until Amica reschedule. If running on a cluster, maximum waiting time (if job not launched) until it is assumed that the AMICA job could not be scheduled, in seconds.'</span>,<span class="string">'cat'</span>,<span class="string">'Compute Resources'</span>), <span class="keyword">...</span>
0178         arg({<span class="string">'max_init_waiting'</span>,<span class="string">'MaxInitWaiting'</span>},2000,[0 Inf],<span class="string">'Maximum wait time until Amica reschedule. If running on a cluster, maximum waiting time (if computation not initialized) until it is assumed that the AMICA job does not make progress (e.g., due to a straggler), in seconds.'</span>,<span class="string">'cat'</span>,<span class="string">'Compute Resources'</span>), <span class="keyword">...</span>
0179         arg({<span class="string">'reduce_factor'</span>,<span class="string">'ReductionFactor'</span>},0.75,[0.1 1],<span class="string">'Processor reduction per restart. If running on a cluster, factor by which the number of processors is reduced when the maximum waiting time is exceeded.'</span>,<span class="string">'cat'</span>,<span class="string">'Compute Resources'</span>), <span class="keyword">...</span>
0180         arg({<span class="string">'scheduler'</span>,<span class="string">'Scheduler'</span>},<span class="string">'computing'</span>,[],<span class="string">'Name of grid scheduler/master. If running on a cluster, name of the Sun Grid Engine master (the ICA runner may need to ssh into this).'</span>,<span class="string">'cat'</span>,<span class="string">'Compute Resources'</span>), <span class="keyword">...</span>
0181         arg({<span class="string">'max_restarts'</span>,<span class="string">'MaxRestarts'</span>},20,uint32([0 1000]),<span class="string">'Maximum number of restarts. If amica has been restarted more than this many times (due to optimistic scheduling or NaN outputs), fall back to the MATLAB implementation.'</span>,<span class="string">'cat'</span>,<span class="string">'Compute Resources'</span>), <span class="keyword">...</span>
0182         arg({<span class="string">'fallback_reduce'</span>,<span class="string">'FallbackReductionFactor'</span>},0.5,[0.1 1],<span class="string">'Iteration reduction after fallback. If falling back, reduce maximum number of iterations by this factor (for time reasons).'</span>,<span class="string">'cat'</span>,<span class="string">'Compute Resources'</span>), <span class="keyword">...</span>
0183         arg({<span class="string">'measure_window'</span>,<span class="string">'ThroughputMeasurementWindow'</span>},5*60,[0 Inf],<span class="string">'Throughput Measurement Window. Amica computational throughput is measured within this past window (in seconds) to determine whether a re-schedule can significantly improve the expected running time.'</span>,<span class="string">'cat'</span>,<span class="string">'Compute Resources'</span>), <span class="keyword">...</span>
0184         arg({<span class="string">'benefit_threshold'</span>,<span class="string">'SpeedupRestartThreshold'</span>},3,[1 100],<span class="string">'Minimum speedup to justify a restart. If the expected speedup due to a restart is at least this high, restart the computation.'</span>,<span class="string">'cat'</span>,<span class="string">'Compute Resources'</span>), <span class="keyword">...</span>
0185         arg({<span class="string">'native_threshold'</span>,<span class="string">'NativeFallbackThreshold'</span>},10,[1 100],<span class="string">'Minimum speedup to justify a fallback. If the expected speedup due to a restart is at least this high, but we have already re-started MaxRestarts times, we fall back to a local MATLAB-based computation.'</span>,<span class="string">'cat'</span>,<span class="string">'Compute Resources'</span>), <span class="keyword">...</span>
0186         arg({<span class="string">'flaky_cluster'</span>,<span class="string">'HaveFlakyCluster'</span>},true,[],<span class="string">'Cluster is flaky. If this is true, computation never falls back to local computation and just retries to schedule or jobs until they eventually get through.'</span>,<span class="string">'cat'</span>,<span class="string">'Compute Resources'</span>), <span class="keyword">...</span>
0187         arg({<span class="string">'reuse_margin'</span>,<span class="string">'DirectoryReuseSafetyMargin'</span>},5,[0 Inf],<span class="string">'Safety margin for directory reuse. When selecting a directory to write results to, make sure that it has not been updated with (incomplete) results within the last n minutes.'</span>,<span class="string">'cat'</span>,<span class="string">'Compute Resources'</span>), <span class="keyword">...</span>
0188         arg({<span class="string">'min_numprocs_fraction'</span>,<span class="string">'MinimumNumProcsFraction'</span>},0.33,[0 1],<span class="string">'Minimum fraction of NumProcessors. If amica gives NaN''s, this is sometimes due to the number of processors chosen - so we use a random # of processors between this fraction and your original number if it crashes, until it eventually works.'</span>,<span class="string">'cat'</span>,<span class="string">'Compute Resources'</span>), <span class="keyword">...</span>
0189         <span class="keyword">...</span>
0190         arg({<span class="string">'lrate'</span>,<span class="string">'LRate'</span>},0.1,[0 1],<span class="string">'Initial learning rate for natural gradient. Extended Infomax only.'</span>,<span class="string">'cat'</span>,<span class="string">'Computation'</span>), <span class="keyword">...</span>
0191         arg({<span class="string">'lratefact'</span>,<span class="string">'LRateFactor'</span>},0.5,[0 1],<span class="string">'Learning rate reduction. Multiplicative factor by which to decrease learning rate (extended Infomax only).'</span>,<span class="string">'cat'</span>,<span class="string">'Computation'</span>), <span class="keyword">...</span>
0192         arg({<span class="string">'minlrate'</span>,<span class="string">'MinLRate'</span>},1e-8,[0 1],<span class="string">'Minimum learning rate. If lower, convergence is assumed; extended Infomax only.'</span>,<span class="string">'cat'</span>,<span class="string">'Computation'</span>), <span class="keyword">...</span>
0193         arg({<span class="string">'rholrate'</span>,<span class="string">'ShapeLRate'</span>},0.05,[0 1],<span class="string">'Initial learning rate for shape parameters. Only for generalized Gaussian mode.'</span>,<span class="string">'cat'</span>,<span class="string">'Computation'</span>), <span class="keyword">...</span>
0194         arg({<span class="string">'rholratefact'</span>,<span class="string">'ShapeLRateFactor'</span>},0.5,[0 1],<span class="string">'Shape learning rate reduction. Multiplicative factor by which to decrease the shape learning rate. Generalized Gaussian only.'</span>,<span class="string">'cat'</span>,<span class="string">'Computation'</span>), <span class="keyword">...</span>
0195         arg({<span class="string">'rho0'</span>,<span class="string">'InitialShape'</span>},1.5,[0 Inf],<span class="string">'Initial shape parameter value. Generalized Gaussian only.'</span>,<span class="string">'cat'</span>,<span class="string">'Computation'</span>), <span class="keyword">...</span>
0196         arg({<span class="string">'minrho'</span>,<span class="string">'MinShape'</span>},1.0,[0 Inf],<span class="string">'Minimum shape parameter value. Generalized Gaussian only.'</span>,<span class="string">'cat'</span>,<span class="string">'Computation'</span>), <span class="keyword">...</span>
0197         arg({<span class="string">'maxrho'</span>,<span class="string">'MaxShape'</span>},2.0,[0 Inf],<span class="string">'Maximum shape parameter value. Generalized Gaussian only.'</span>,<span class="string">'cat'</span>,<span class="string">'Computation'</span>), <span class="keyword">...</span>
0198         arg({<span class="string">'do_newton'</span>,<span class="string">'DoNewton'</span>},true,[],<span class="string">'Use the Newton method.'</span>,<span class="string">'cat'</span>,<span class="string">'Computation'</span>), <span class="keyword">...</span>
0199         arg({<span class="string">'newt_start'</span>,<span class="string">'NewtonStartIter'</span>},50,uint32([1 10000]),<span class="string">'Iterations without Newton method. Only after this many iterations, the Newton method is used.'</span>,<span class="string">'cat'</span>,<span class="string">'Computation'</span>), <span class="keyword">...</span>
0200         arg({<span class="string">'newtrate'</span>,<span class="string">'NewtonRate'</span>},1.0,[0 1],<span class="string">'Learning rate for Newton iterations.'</span>,<span class="string">'cat'</span>,<span class="string">'Computation'</span>), <span class="keyword">...</span>
0201         arg({<span class="string">'newt_ramp'</span>,<span class="string">'NewtonRampUp'</span>},10,uint32([1 10000]),<span class="string">'Iterations to ramp up Newton method.'</span>,<span class="string">'cat'</span>,<span class="string">'Computation'</span>), <span class="keyword">...</span>
0202         arg({<span class="string">'comp_thresh'</span>,<span class="string">'ComponentThreshold'</span>},0.98,[0 1],<span class="string">'Correlation Threshold to share components.'</span>,<span class="string">'cat'</span>,<span class="string">'Computation'</span>), <span class="keyword">...</span>
0203         arg({<span class="string">'share_start'</span>,<span class="string">'ShareStartIter'</span>},100,uint32([1 10000]),<span class="string">'Iteration to start component sharing.'</span>,<span class="string">'cat'</span>,<span class="string">'Computation'</span>), <span class="keyword">...</span>
0204         arg({<span class="string">'share_int'</span>,<span class="string">'ShareInterval'</span>},100,uint32([1 10000]),<span class="string">'Iterations between component sharing checks.'</span>,<span class="string">'cat'</span>,<span class="string">'Computation'</span>), <span class="keyword">...</span>
0205         <span class="keyword">...</span>
0206         arg({<span class="string">'outdir'</span>,<span class="string">'OutputDirectory'</span>},[],[],<span class="string">'Output directory. Results of the computation are written there (empty: to BCILAB''s temp directory).'</span>,<span class="string">'cat'</span>,<span class="string">'File IO'</span>), <span class="keyword">...</span>
0207         arg({<span class="string">'load_final'</span>,<span class="string">'LoadFinalModels'</span>},true,[],<span class="string">'Load final models. If the output directory contains a final model, try to load it.'</span>,<span class="string">'cat'</span>,<span class="string">'File IO'</span>), <span class="keyword">...</span>
0208         arg({<span class="string">'writestep'</span>,<span class="string">'WriteInterval'</span>},10,uint32([1 10000]),<span class="string">'Iterations between output writes.'</span>,<span class="string">'cat'</span>,<span class="string">'File IO'</span>), <span class="keyword">...</span>
0209         arg({<span class="string">'write_nd'</span>,<span class="string">'WriteHistory'</span>},true,[],<span class="string">'Write component update magnitudes. Per iteration.'</span>,<span class="string">'cat'</span>,<span class="string">'File IO'</span>), <span class="keyword">...</span>
0210         arg({<span class="string">'write_LLt'</span>,<span class="string">'WriteLoglikes'</span>},true,[],<span class="string">'Write model log-likelihoods. Per time point.'</span>,<span class="string">'cat'</span>,<span class="string">'File IO'</span>), <span class="keyword">...</span>
0211         arg({<span class="string">'indir'</span>,<span class="string">'InputDirectory'</span>},<span class="string">''</span>,[],<span class="string">'Directory of initial model, if any. Optional input directory from which to load the initial model (during AMICA runtime, models are stored in directories).'</span>,<span class="string">'cat'</span>,<span class="string">'File IO'</span>,<span class="string">'type'</span>,<span class="string">'char'</span>,<span class="string">'shape'</span>,<span class="string">'row'</span>), <span class="keyword">...</span>
0212         arg({<span class="string">'load_param'</span>,<span class="string">'ReadParams'</span>},false,[],<span class="string">'Read parameters from input directory.'</span>,<span class="string">'cat'</span>,<span class="string">'File IO'</span>), <span class="keyword">...</span>
0213         arg({<span class="string">'load_rej'</span>,<span class="string">'ReadRejections'</span>},false,[],<span class="string">'Read rejection info from input directory. This is for the Amica-internal rejection.'</span>,<span class="string">'cat'</span>,<span class="string">'File IO'</span>), <span class="keyword">...</span>
0214         arg({<span class="string">'load_comp_list'</span>,<span class="string">'ReadCompList'</span>},false,[],<span class="string">'Read component assigments.'</span>,<span class="string">'cat'</span>,<span class="string">'File IO'</span>), <span class="keyword">...</span>
0215         <span class="keyword">...</span>
0216         arg({<span class="string">'do_reject'</span>,<span class="string">'DoReject'</span>},false,[],<span class="string">'Do online time-point rejection.'</span>,<span class="string">'cat'</span>,<span class="string">'Artifact Handling'</span>), <span class="keyword">...</span>
0217         arg({<span class="string">'numrej'</span>,<span class="string">'RejectCycles'</span>},3,uint32([0 100]),<span class="string">'Number of rejections to perform in total.'</span>,<span class="string">'cat'</span>,<span class="string">'Artifact Handling'</span>), <span class="keyword">...</span>
0218         arg({<span class="string">'rejsig'</span>,<span class="string">'RejectSigma'</span>},3,[0 Inf],<span class="string">'Likelihood threshold for rejection (stddev). This is the number of standard deviations of likelihood below which to reject data.'</span>,<span class="string">'cat'</span>,<span class="string">'Artifact Handling'</span>), <span class="keyword">...</span>
0219         arg({<span class="string">'rejstart'</span>,<span class="string">'RejectStart'</span>},2,uint32([0 10000]),<span class="string">'Iteration at which to start rejection.'</span>,<span class="string">'cat'</span>,<span class="string">'Artifact Handling'</span>), <span class="keyword">...</span>
0220         arg({<span class="string">'rejint'</span>,<span class="string">'RejectInterval'</span>},3,uint32([0 10000]),<span class="string">'Iterations between successive rejections.'</span>,<span class="string">'cat'</span>,<span class="string">'Artifact Handling'</span>), <span class="keyword">...</span>
0221         arg({<span class="string">'kurt_start'</span>,<span class="string">'KurtosisStart'</span>},3,uint32([0 10000]),<span class="string">'Iterations without kurtosis calculations. This is for Extended Infomax only.'</span>,<span class="string">'cat'</span>,<span class="string">'Artifact Handling'</span>), <span class="keyword">...</span>
0222         arg({<span class="string">'num_kurt'</span>,<span class="string">'KurtosisCycles'</span>},5,uint32([0 10000]),<span class="string">'Number of kurtosis calcs to perform. This is for Extended Infomax only.'</span>,<span class="string">'cat'</span>,<span class="string">'Artifact Handling'</span>), <span class="keyword">...</span>
0223         arg({<span class="string">'kurt_int'</span>,<span class="string">'KurtosisInterval'</span>},1,uint32([0 10000]),<span class="string">'Iterations between successive kurtosis calculations. This is for Extended Infomax only.'</span>,<span class="string">'cat'</span>,<span class="string">'Artifact Handling'</span>), <span class="keyword">...</span>
0224         <span class="keyword">...</span>
0225         arg({<span class="string">'update_A'</span>,<span class="string">'UpdateWeights'</span>},true,[],<span class="string">'Update the mixing matrix.'</span>,<span class="string">'cat'</span>,<span class="string">'Parameter Updates'</span>), <span class="keyword">...</span>
0226         arg({<span class="string">'update_c'</span>,<span class="string">'UpdateCenters'</span>},true,[],<span class="string">'Update the model centers.'</span>,<span class="string">'cat'</span>,<span class="string">'Parameter Updates'</span>), <span class="keyword">...</span>
0227         arg({<span class="string">'update_gamma'</span>,<span class="string">'UpdateProbabilities'</span>},true,[],<span class="string">'Update the model probabilities.'</span>,<span class="string">'cat'</span>,<span class="string">'Parameter Updates'</span>), <span class="keyword">...</span>
0228         arg({<span class="string">'update_alpha'</span>,<span class="string">'UpdateProportions'</span>},true,[],<span class="string">'Update the source mixture proportions.'</span>,<span class="string">'cat'</span>,<span class="string">'Parameter Updates'</span>), <span class="keyword">...</span>
0229         arg({<span class="string">'update_mu'</span>,<span class="string">'UpdateLocations'</span>},true,[],<span class="string">'Update the source mixture locations.'</span>,<span class="string">'cat'</span>,<span class="string">'Parameter Updates'</span>), <span class="keyword">...</span>
0230         arg({<span class="string">'update_sbeta'</span>,<span class="string">'UpdateScales'</span>},true,[],<span class="string">'Update the source mixture scales.'</span>,<span class="string">'cat'</span>,<span class="string">'Parameter Updates'</span>), <span class="keyword">...</span>
0231         arg({<span class="string">'do_rho'</span>,<span class="string">'UpdateShapes'</span>},true,[],<span class="string">'Update the shape parameters.'</span>,<span class="string">'cat'</span>,<span class="string">'Parameter Updates'</span>), <span class="keyword">...</span>
0232         <span class="keyword">...</span>
0233         arg({<span class="string">'decwindow'</span>,<span class="string">'DetectWindow'</span>},1,[],<span class="string">'Moving average window for likelihood check. Likelihood decrease is detected in this window (presumably over iterations - Jason?).'</span>,<span class="string">'cat'</span>,<span class="string">'Miscellaneous'</span>), <span class="keyword">...</span>
0234         arg({<span class="string">'invsigmax'</span>,<span class="string">'MaxInverseSigma'</span>},100,[],<span class="string">'Maximum value of inverse scale parameters.'</span>,<span class="string">'cat'</span>,<span class="string">'Miscellaneous'</span>), <span class="keyword">...</span>
0235         arg({<span class="string">'invsigmin'</span>,<span class="string">'MinInverseSigma'</span>},1e-8,[],<span class="string">'Minimum value of inverse scale parameters.'</span>,<span class="string">'cat'</span>,<span class="string">'Miscellaneous'</span>), <span class="keyword">...</span>
0236         arg({<span class="string">'do_mean'</span>,<span class="string">'Centering'</span>},true,[],<span class="string">'Remove the mean from the data.'</span>,<span class="string">'cat'</span>,<span class="string">'Miscellaneous'</span>), <span class="keyword">...</span>
0237         arg({<span class="string">'do_sphere'</span>,<span class="string">'Sphering'</span>},true,[],<span class="string">'Sphere (whiten) the data.'</span>,<span class="string">'cat'</span>,<span class="string">'Miscellaneous'</span>), <span class="keyword">...</span>
0238         arg({<span class="string">'doPCA'</span>,<span class="string">'PCAReduction'</span>},true,[],<span class="string">'Do a PCA dimensionality reduction.'</span>,<span class="string">'cat'</span>,<span class="string">'Miscellaneous'</span>), <span class="keyword">...</span>
0239         arg({<span class="string">'pcakeep'</span>,<span class="string">'RetainPCAs'</span>},[],[],<span class="string">'Number of PCA components to keep. If PCA is enabled (if empty: #channels).'</span>,<span class="string">'cat'</span>,<span class="string">'Miscellaneous'</span>,<span class="string">'shape'</span>,<span class="string">'scalar'</span>,<span class="string">'type'</span>,<span class="string">'uint32'</span>), <span class="keyword">...</span>
0240         arg({<span class="string">'doscaling'</span>,<span class="string">'Rescale'</span>},true,[],<span class="string">'Rescale unmixing matrix to unit norm.'</span>,<span class="string">'cat'</span>,<span class="string">'Miscellaneous'</span>), <span class="keyword">...</span>
0241         arg({<span class="string">'scalestep'</span>,<span class="string">'ScaleInterval'</span>},1,uint32([1 10000]),<span class="string">'Iterations between unmixing matrix rescaling.'</span>,<span class="string">'cat'</span>,<span class="string">'Miscellaneous'</span>), <span class="keyword">...</span>
0242         arg({<span class="string">'block_size'</span>,<span class="string">'BlockSize'</span>},128,uint32([10 10000]),<span class="string">'Matrix block size for block multiplication.'</span>,<span class="string">'cat'</span>,<span class="string">'Miscellaneous'</span>), <span class="keyword">...</span>
0243         arg({<span class="string">'verbose'</span>,<span class="string">'Verbose'</span>},true,[],<span class="string">'Show progress updates.'</span>,<span class="string">'cat'</span>,<span class="string">'Miscellaneous'</span>)}, <span class="keyword">...</span>
0244     <span class="string">'infomax'</span>,{ <span class="keyword">...</span>
0245         arg({<span class="string">'maxsteps'</span>,<span class="string">'MaxIterations'</span>},512,uint32([1 10000]),<span class="string">'Maximum number of ICA training steps.'</span>,<span class="string">'cat'</span>,<span class="string">'Core Parameters'</span>), <span class="keyword">...</span>
0246         arg({<span class="string">'extended'</span>,<span class="string">'ExtendedInfomax'</span>},int32(3),[],<span class="string">'Perform Extended-ICA sign estimations for N training blocks. If N &gt; 0, automatically estimate the of sub-Gaussian sources. If N &lt; 0, fix number of sub-Gaussian comps to -N [faster than N&gt;0].'</span>,<span class="string">'cat'</span>,<span class="string">'Core Parameters'</span>), <span class="keyword">...</span>
0247         arg({<span class="string">'pca'</span>,<span class="string">'RetainPCAs'</span>},0,uint32([0 10000]),<span class="string">'Do a PCA dimensionality reduction. Value is the number of PCs to retain (0=off)'</span>,<span class="string">'cat'</span>,<span class="string">'Core Parameters'</span>), <span class="keyword">...</span>
0248         arg({<span class="string">'sphering'</span>,<span class="string">'Sphering'</span>},true,[],<span class="string">'Whether to sphere the data.'</span>,<span class="string">'cat'</span>,<span class="string">'Core Parameters'</span>), <span class="keyword">...</span>
0249         <span class="keyword">...</span>
0250         arg({<span class="string">'lrate'</span>,<span class="string">'LearningRate'</span>},[],[],<span class="string">'Initial ICA learning rate (&lt;&lt; 1). If empty, use a heuristic.'</span>,<span class="string">'cat'</span>,<span class="string">'Computation'</span>), <span class="keyword">...</span>
0251         arg({<span class="string">'anneal'</span>,<span class="string">'Annealing'</span>},[],[0 1],<span class="string">'Annealing constant, controls speed of convergence. If empty, use 0.90 for regular or 0.98 for extended Infomax.'</span>,<span class="string">'cat'</span>,<span class="string">'Computation'</span>), <span class="keyword">...</span>
0252         arg({<span class="string">'annealdeg'</span>,<span class="string">'AnnealChange'</span>},60,[0 90],<span class="string">'Weight change threshold for annealing steps. In degrees.'</span>,<span class="string">'cat'</span>,<span class="string">'Computation'</span>), <span class="keyword">...</span>
0253         arg({<span class="string">'pstop'</span>,<span class="string">'MinWeightChange'</span>,<span class="string">'stop'</span>},0.000001,[0 Inf],<span class="string">'Minimum weight change to signal convergence.'</span>,<span class="string">'cat'</span>,<span class="string">'Computation'</span>), <span class="keyword">...</span>
0254         <span class="keyword">...</span>
0255         arg({<span class="string">'pweights'</span>,<span class="string">'InitialWeights'</span>,<span class="string">'weights'</span>},[],[],<span class="string">'Initial weight matrix, if any. If empty, use eye()/spher().'</span>,<span class="string">'cat'</span>,<span class="string">'Miscellaneous'</span>), <span class="keyword">...</span>
0256         arg({<span class="string">'pblock'</span>,<span class="string">'BlockSize'</span>,<span class="string">'block'</span>},[],[],<span class="string">'ICA block size (&lt;&lt; datalength). If empty, use a heuristic.'</span>,<span class="string">'cat'</span>,<span class="string">'Miscellaneous'</span>,<span class="string">'shape'</span>,<span class="string">'scalar'</span>,<span class="string">'type'</span>,<span class="string">'int32'</span>), <span class="keyword">...</span>
0257         arg({<span class="string">'bias'</span>,<span class="string">'BiasAdjust'</span>},true,[],<span class="string">'Perform bias adjustment.'</span>,<span class="string">'cat'</span>,<span class="string">'Miscellaneous'</span>), <span class="keyword">...</span>
0258         arg({<span class="string">'momentum'</span>,<span class="string">'Momentum'</span>},0,[0 1],<span class="string">'Training momentum. Technique to prevent getting stuck in local minima.'</span>,<span class="string">'cat'</span>,<span class="string">'Miscellaneous'</span>), <span class="keyword">...</span>
0259         arg({<span class="string">'pposact'</span>,<span class="string">'PosActivations'</span>,<span class="string">'posact'</span>},false,[],<span class="string">'Make all component activations net-positive. Requires time and memory; posact() may be applied separately.'</span>,<span class="string">'cat'</span>,<span class="string">'Miscellaneous'</span>), <span class="keyword">...</span>
0260         arg({<span class="string">'verbose'</span>,<span class="string">'Verbose'</span>},true,[],<span class="string">'Show progress updates.'</span>,<span class="string">'cat'</span>,<span class="string">'Miscellaneous'</span>), <span class="keyword">...</span>
0261         arg({<span class="string">'logfile'</span>,<span class="string">'Logfile'</span>},<span class="string">''</span>,[],<span class="string">'Log file to save messages to. Messages will still be shown on screen.'</span>,<span class="string">'cat'</span>,<span class="string">'Miscellaneous'</span>,<span class="string">'shape'</span>,<span class="string">'row'</span>,<span class="string">'type'</span>,<span class="string">'char'</span>), <span class="keyword">...</span>
0262         arg({<span class="string">'interupt'</span>,<span class="string">'InterruptBtn'</span>},false,[],<span class="string">'Show interupt button (slow).'</span>,<span class="string">'cat'</span>,<span class="string">'Miscellaneous'</span>)}, <span class="keyword">...</span>
0263     <span class="string">'beamica'</span>, { <span class="keyword">...</span>
0264         arg({<span class="string">'max_iter'</span>,<span class="string">'MaxIterations'</span>},1200,uint32([1 10000]),<span class="string">'Maximum number of iterations.'</span>), <span class="keyword">...</span>
0265         arg({<span class="string">'anchorlabels'</span>,<span class="string">'AnchorLabels'</span>},{}, {<span class="string">'Precentral_L'</span>, <span class="string">'Precentral_R'</span>, <span class="string">'Frontal_Sup_L'</span>, <span class="string">'Frontal_Sup_R'</span>, <span class="string">'Frontal_Sup_Orb_L'</span>, <span class="string">'Frontal_Sup_Orb_R'</span>, <span class="string">'Frontal_Mid_L'</span>, <span class="string">'Frontal_Mid_R'</span>, <span class="string">'Frontal_Mid_Orb_L'</span>, <span class="string">'Frontal_Mid_Orb_R'</span>, <span class="string">'Frontal_Inf_Oper_L'</span>, <span class="string">'Frontal_Inf_Oper_R'</span>, <span class="string">'Frontal_Inf_Tri_L'</span>, <span class="string">'Frontal_Inf_Tri_R'</span>, <span class="string">'Frontal_Inf_Orb_L'</span>, <span class="string">'Frontal_Inf_Orb_R'</span>, <span class="string">'Rolandic_Oper_L'</span>, <span class="string">'Rolandic_Oper_R'</span>, <span class="string">'Supp_Motor_Area_L'</span>, <span class="string">'Supp_Motor_Area_R'</span>, <span class="string">'Frontal_Sup_Medial_L'</span>, <span class="string">'Frontal_Sup_Medial_R'</span>, <span class="string">'Frontal_Med_Orb_L'</span>, <span class="string">'Frontal_Med_Orb_R'</span>, <span class="string">'Insula_L'</span>, <span class="string">'Insula_R'</span>, <span class="string">'Cingulum_Ant_L'</span>, <span class="string">'Cingulum_Ant_R'</span>, <span class="string">'Cingulum_Mid_L'</span>, <span class="string">'Cingulum_Mid_R'</span>, <span class="string">'Cingulum_Post_L'</span>, <span class="string">'Cingulum_Post_R'</span>, <span class="string">'Hippocampus_L'</span>, <span class="string">'Hippocampus_R'</span>, <span class="string">'ParaHippocampal_L'</span>, <span class="string">'ParaHippocampal_R'</span>, <span class="string">'Calcarine_L'</span>, <span class="string">'Calcarine_R'</span>, <span class="string">'Cuneus_L'</span>, <span class="string">'Cuneus_R'</span>, <span class="string">'Lingual_L'</span>, <span class="string">'Lingual_R'</span>, <span class="string">'Occipital_Sup_L'</span>, <span class="string">'Occipital_Sup_R'</span>, <span class="string">'Occipital_Mid_L'</span>, <span class="string">'Occipital_Mid_R'</span>, <span class="string">'Occipital_Inf_L'</span>, <span class="string">'Occipital_Inf_R'</span>, <span class="string">'Fusiform_L'</span>, <span class="string">'Fusiform_R'</span>, <span class="string">'Postcentral_L'</span>, <span class="string">'Postcentral_R'</span>, <span class="string">'Parietal_Sup_L'</span>, <span class="string">'Parietal_Sup_R'</span>, <span class="string">'Parietal_Inf_L'</span>, <span class="string">'Parietal_Inf_R'</span>, <span class="string">'SupraMarginal_L'</span>, <span class="string">'SupraMarginal_R'</span>, <span class="string">'Angular_L'</span>, <span class="string">'Angular_R'</span>, <span class="string">'Precuneus_L'</span>, <span class="string">'Precuneus_R'</span>, <span class="string">'Paracentral_Lobule_L'</span>, <span class="string">'Paracentral_Lobule_R'</span>, <span class="string">'Temporal_Sup_L'</span>, <span class="string">'Temporal_Sup_R'</span>, <span class="string">'Temporal_Pole_Sup_L'</span>, <span class="string">'Temporal_Pole_Sup_R'</span>, <span class="string">'Temporal_Mid_L'</span>, <span class="string">'Temporal_Mid_R'</span>, <span class="string">'Temporal_Pole_Mid_L'</span>, <span class="string">'Temporal_Pole_Mid_R'</span>, <span class="string">'Temporal_Inf_L'</span>, <span class="string">'Temporal_Inf_R'</span>, <span class="string">'Olfactory_L'</span>, <span class="string">'Olfactory_R'</span>, <span class="string">'Rectus_L'</span>, <span class="string">'Rectus_R'</span>, <span class="string">'Amygdala_L'</span>, <span class="string">'Amygdala_R'</span>, <span class="string">'Caudate_L'</span>, <span class="string">'Caudate_R'</span>, <span class="string">'Thalamus_L'</span>, <span class="string">'Thalamus_R'</span>, <span class="string">'Heschl_L'</span>, <span class="string">'Heschl_R'</span>}, <span class="keyword">...</span>
0266             <span class="string">'Cortical anchor locations. List of locations to which components shall be constrained. The first k components are encouraged to lie close to the given locations, in the order of appearance. This is experimental and currently requires a) 10-20 locations and b) Guido Nolte''s source analysis toolbox (not included).'</span>,<span class="string">'experimental'</span>,true), <span class="keyword">...</span>
0267         arg({<span class="string">'reference'</span>,<span class="string">'Reference'</span>},<span class="string">'nasion'</span>,{<span class="string">'nasion'</span>,<span class="string">'common_average'</span>},<span class="string">'Referencing scheme. Only needed if anchor locations are selected.'</span>,<span class="string">'experimental'</span>,true), <span class="keyword">...</span>
0268         arg({<span class="string">'tradeoff'</span>,<span class="string">'BeamPenaltyStrength'</span>},0,[0 1],<span class="string">'Beamformer penalty strength. Larger values emphasize the beamformer constraint over the Infomax cost function.'</span>,<span class="string">'experimental'</span>,true), <span class="keyword">...</span>
0269         arg({<span class="string">'lrate'</span>,<span class="string">'LearningRate'</span>},0.5,[0 1],<span class="string">'Learning rate. The maximum is 1.0, but lower rates (down to 0.1 or below) can be used to ensure stability.'</span>), <span class="keyword">...</span>
0270         arg({<span class="string">'verbose'</span>,<span class="string">'VerboseOutput'</span>},true,[],<span class="string">'Show verbose output.'</span>), <span class="keyword">...</span>
0271         arg({<span class="string">'usegpu'</span>,<span class="string">'TryUseGPU'</span>,<span class="string">'UseGPU'</span>},true,[],<span class="string">'Try to use the GPU.'</span>), <span class="keyword">...</span>
0272         arg({<span class="string">'convergence_check'</span>,<span class="string">'ConvergenceCheck'</span>},false,[],<span class="string">'Force convergence check if on GPU. This is slow on the GPU, but can help ensuring that the solution converges.'</span>)}, <span class="keyword">...</span>
0273     <span class="string">'fastica'</span>, { <span class="keyword">...</span>
0274         arg({<span class="string">'maxNumIterations'</span>,<span class="string">'MaxIterations'</span>},1000,uint32([1 10000]),<span class="string">'Maximum number of iterations.'</span>,<span class="string">'cat'</span>,<span class="string">'Core Parameters'</span>), <span class="keyword">...</span>
0275         arg({<span class="string">'approach'</span>,<span class="string">'Approach'</span>},<span class="string">'symm'</span>,{<span class="string">'symm'</span>,<span class="string">'defl'</span>},<span class="string">'The decorrelation approach used. Can be symmetric, i.e. estimate all the independent component in parallel, or deflation, i.e. estimate independent component one-by-one like in projection pursuit.'</span>,<span class="string">'cat'</span>,<span class="string">'Core Parameters'</span>), <span class="keyword">...</span>
0276         arg({<span class="string">'numOfIC'</span>,<span class="string">'NumICs'</span>},[],[],<span class="string">' Number of estimated independent components. Default equals the dimension of data.'</span>,<span class="string">'cat'</span>,<span class="string">'Core Parameters'</span>,<span class="string">'shape'</span>,<span class="string">'scalar'</span>,<span class="string">'type'</span>,<span class="string">'uint32'</span>), <span class="keyword">...</span>
0277         arg({<span class="string">'g'</span>,<span class="string">'Nonlinearity'</span>},<span class="string">'tanh'</span>,{<span class="string">'pow3'</span>,<span class="string">'tanh'</span>,<span class="string">'gauss'</span>,<span class="string">'skew'</span>},<span class="string">'Nonlinearity to use. Pow3 is g(u)=u^3, tanh is g(u)=tanh(a1*u), gauss is g(u)=u*exp(-a2*u^2/2), and skew is g(u)=u^2.'</span>,<span class="string">'cat'</span>,<span class="string">'Core Parameters'</span>), <span class="keyword">...</span>
0278         arg({<span class="string">'finetune'</span>,<span class="string">'FineTuning'</span>},<span class="string">'tanh'</span>,{<span class="string">'off'</span>,<span class="string">'pow3'</span>,<span class="string">'tanh'</span>,<span class="string">'gauss'</span>,<span class="string">'skew'</span>},<span class="string">'Nonlinearity for fine-tuning. Pow3 is g(u)=u^3, tanh is g(u)=tanh(a1*u), gauss is g(u)=u*exp(-a2*u^2/2), and skew is g(u)=u^2.'</span>,<span class="string">'cat'</span>,<span class="string">'Core Parameters'</span>), <span class="keyword">...</span>
0279         arg({<span class="string">'a1'</span>,<span class="string">'TanhParameter'</span>},1,[],<span class="string">'Parameter a1 for tanh nonlinearity.'</span>,<span class="string">'cat'</span>,<span class="string">'Core Parameters'</span>), <span class="keyword">...</span>
0280         arg({<span class="string">'a2'</span>,<span class="string">'GaussParameter'</span>},1,[],<span class="string">'Parameter a2 for gauss nonlinearity.'</span>,<span class="string">'cat'</span>,<span class="string">'Core Parameters'</span>), <span class="keyword">...</span>
0281         <span class="keyword">...</span>
0282         arg({<span class="string">'stepsize'</span>,<span class="string">'StepSize'</span>,<span class="string">'mu'</span>},1,[],<span class="string">'Step size. If the value is other than 1, then the program will use the stabilized version of the algorithm (see also parameter &quot;Stabilization&quot;).'</span>,<span class="string">'cat'</span>,<span class="string">'Convergence'</span>), <span class="keyword">...</span>
0283         arg({<span class="string">'stabilization'</span>,<span class="string">'Stabilization'</span>},false,[],<span class="string">'Use an adaptive step size. Serves to stabilize the convergence.'</span>,<span class="string">'cat'</span>,<span class="string">'Convergence'</span>), <span class="keyword">...</span>
0284         arg({<span class="string">'epsilon'</span>,<span class="string">'Epsilon'</span>},0.001,[],<span class="string">'Stopping criterion.'</span>,<span class="string">'cat'</span>,<span class="string">'Convergence'</span>), <span class="keyword">...</span>
0285         arg({<span class="string">'maxFinetune'</span>,<span class="string">'MaxFinetune'</span>},100,uint32([1,10000]),<span class="string">'Maximum number of iterations in fine-tuning.'</span>,<span class="string">'cat'</span>,<span class="string">'Convergence'</span>), <span class="keyword">...</span>
0286         arg({<span class="string">'sampleSize'</span>,<span class="string">'SampleSize'</span>},1,[0 1],<span class="string">'Percentage of samples used per iteration. Samples are chosen randomly.'</span>,<span class="string">'cat'</span>,<span class="string">'Convergence'</span>), <span class="keyword">...</span>
0287         arg({<span class="string">'initGuess'</span>,<span class="string">'InitialGuess'</span>},[],[],<span class="string">'Initial guess for A, if any. Default is random.'</span>,<span class="string">'cat'</span>,<span class="string">'Convergence'</span>), <span class="keyword">...</span>
0288         <span class="keyword">...</span>
0289         arg({<span class="string">'verbose'</span>,<span class="string">'Verbose'</span>},true,[],<span class="string">'Report progress of algorithm.'</span>,<span class="string">'cat'</span>,<span class="string">'Miscellaneous'</span>), <span class="keyword">...</span>
0290         arg({<span class="string">'displayMode'</span>,<span class="string">'DisplayMode'</span>},<span class="string">'off'</span>,{<span class="string">'signals'</span>,<span class="string">'basis'</span>,<span class="string">'filters'</span>,<span class="string">'off'</span>},<span class="string">'Plot running estimates of independent components.'</span>,<span class="string">'cat'</span>,<span class="string">'Miscellaneous'</span>), <span class="keyword">...</span>
0291         arg({<span class="string">'displayInterval'</span>,<span class="string">'DisplayInterval'</span>},1,[],<span class="string">'Number of iterations between plots.'</span>,<span class="string">'cat'</span>,<span class="string">'Miscellaneous'</span>), <span class="keyword">...</span>
0292         arg({<span class="string">'firstEig'</span>,<span class="string">'FirstEigenvalue'</span>},1,[],<span class="string">'Skip n largest components. This and &quot;LastEigvalue&quot; specify the range for eigenvalues that are retained, &quot;FirstEigenvalue&quot; is the index of largest eigenvalue to be retained.'</span>,<span class="string">'cat'</span>,<span class="string">'Miscellaneous'</span>), <span class="keyword">...</span>
0293         arg({<span class="string">'lastEig'</span>,<span class="string">'LastEigenvalue'</span>},[],[],<span class="string">'Skip n smallest components. This is the index of the last (smallest) eigenvalue to be retained. Default equals the dimension of data.'</span>,<span class="string">'cat'</span>,<span class="string">'Miscellaneous'</span>)}, <span class="keyword">...</span><span class="comment">    </span>
0294      <span class="string">'rica'</span>, { <span class="keyword">...</span>
0295         arg({<span class="string">'numFeatures'</span>,<span class="string">'NumComponents'</span>},[],[],<span class="string">'Number of components to learn. Can be larger than the number of channels. If empty, use # channels.'</span>), <span class="keyword">...</span>
0296         arg({<span class="string">'dict_criterion'</span>,<span class="string">'DictionaryCriterion'</span>},<span class="string">'reconstruction'</span>,{<span class="string">'reconstruction'</span>,<span class="string">'cortically_anchored'</span>},<span class="string">'Dictionary learning criterion. The cortically anchored mode allows to specify a cell array of anchor locations.'</span>), <span class="keyword">...</span>
0297         arg({<span class="string">'lambda'</span>,<span class="string">'Lambda'</span>},0.05,[0 Inf],<span class="string">'Sparsity/accuracy tradeoff. The lambda parameter in sparse dictionary learning.'</span>), <span class="keyword">...</span>
0298         arg({<span class="string">'gamma'</span>,<span class="string">'Gamma'</span>},0.01,[0 Inf],<span class="string">'Anchoring tradeoff. This is the tradeoff parameter associated with the anchor constraint term.'</span>), <span class="keyword">...</span>
0299         arg({<span class="string">'theta'</span>,<span class="string">'Theta'</span>},1,[0 Inf],<span class="string">'Reconstruction tradeoff. This is the tradeoff parameter associated with the reconstruction cost.'</span>), <span class="keyword">...</span>
0300         arg({<span class="string">'anchors'</span>,<span class="string">'AnchorLocations'</span>},[],[],<span class="string">'Cortical anchor locations. Cell array of dipolar projection triplets, one cell per location that shall be anchored. The first k components are cortically constrained. The associated tuning parameter is Gamma.'</span>), <span class="keyword">...</span>
0301         arg({<span class="string">'anchor_init'</span>,<span class="string">'AnchorInitialization'</span>},<span class="string">'from_subspace'</span>,{<span class="string">'from_subspace'</span>,<span class="string">'bestmatch'</span>,<span class="string">'perpendicular'</span>},<span class="string">'Anchor component initialization. When using from_subspace a random linear combination from the subspace will be used. When using bestmatch, the best-matching component in the initialization will be used.'</span>), <span class="keyword">...</span>
0302         arg({<span class="string">'max_restarts'</span>,<span class="string">'MaxRestarts'</span>},20,uint32([0,1000]),<span class="string">'Maximum # of restarts. When weights blow up or etc.'</span>), <span class="keyword">...</span>
0303         arg({<span class="string">'cov_blocksize'</span>,<span class="string">'CovarianceBlocksize'</span>},10,uint32([1,100000]),<span class="string">'Robust blocksize. Blocksize for robust estimation (currently only covariance).'</span>), <span class="keyword">...</span>
0304         arg({<span class="string">'initialization'</span>,<span class="string">'Initialization'</span>},<span class="string">'random_dipoles'</span>,{<span class="string">'random_dipoles'</span>,<span class="string">'random'</span>,<span class="string">'radial'</span>},<span class="string">'Initialization. Either randomly or using radial (sphering) components.'</span>), <span class="keyword">...</span>
0305         arg({<span class="string">'cov_rejection'</span>,<span class="string">'CovarianceRejection'</span>},5,[0 100],<span class="string">'Covariance-based rejection. Rejects samples that are beyond this many std-devs from a robustly estimated data distribution.'</span>), <span class="keyword">...</span>
0306         arg({<span class="string">'temporal_normalization'</span>,<span class="string">'TemporalNormalization'</span>},false,[],<span class="string">'Temporal normalization. Whether the data should also be normalized in time.'</span>), <span class="keyword">...</span>
0307         arg({<span class="string">'random_init_scale'</span>,<span class="string">'RandomInitScale'</span>},0.1,[],<span class="string">'Initial randomness level. This is the fraction of random noise used to determine the initial solution (e.g., eye+n*randn().'</span>), <span class="keyword">...</span>
0308         arg({<span class="string">'randseed'</span>,<span class="string">'RandomSeed'</span>},10,[],<span class="string">'Random seed. Use the same seed for reproducible results.'</span>), <span class="keyword">...</span>
0309         arg({<span class="string">'epsilon'</span>,<span class="string">'Epsilon'</span>},1e-5,[],<span class="string">'Epsilon parameter in sparsity cost.'</span>), <span class="keyword">...</span>
0310         arg({<span class="string">'topoplot'</span>,<span class="string">'ShowTopoplot'</span>},false,[],<span class="string">'Show topoplots per update. For tracking of convergence, etc.'</span>), <span class="keyword">...</span>
0311         arg_nogui({<span class="string">'chan_labels'</span>,<span class="string">'ChannelLabels'</span>}), <span class="keyword">...</span>
0312         arg_sub({<span class="string">'solverOptions'</span>,<span class="string">'SolverOptions'</span>},{}, { <span class="keyword">...</span>
0313             arg({<span class="string">'MaxIter'</span>,<span class="string">'MaxIterations'</span>},75,uint32([1 10000]),<span class="string">'Maximum number of iterations.'</span>), <span class="keyword">...</span>
0314             arg({<span class="string">'Method'</span>,<span class="string">'Optimizer'</span>},<span class="string">'Scaled Non-Linear Conjugate Gradient'</span>,{<span class="string">'Steepest Descent'</span>,<span class="string">'Cyclic Steepest Descent'</span>,<span class="string">'Barzilai and Borwein Gradient'</span>,<span class="string">'Non-Linear Conjugate Gradient'</span>,<span class="string">'Scaled Non-Linear Conjugate Gradient'</span>,<span class="string">'Preconditionined Non-Linear Conjugate Gradient'</span>,<span class="string">'Quasi-Newton with Limited-Memory BFGS Updating'</span>,<span class="string">'Hessian-Free Newton'</span>,<span class="string">'Preconditioned Hessian-Free Newton '</span>,<span class="string">'Quasi-Newton Hessian approximation'</span>,<span class="string">'Newton with Hessian update every k''th step'</span>},<span class="string">'Optimization method to use. Later methods use fewer step sizes but espectially the Newton-type methods are more expensive, and some advanced methods might be too brittle for ICA.'</span>), <span class="keyword">...</span>
0315             arg({<span class="string">'MaxFunEvals'</span>,<span class="string">'MaxFunctionEvals'</span>},1000,uint32([1 100000]),<span class="string">'Maximum function evaluations. Maximum number of function evaluations allowed (including during line searches).'</span>), <span class="keyword">...</span>
0316             arg({<span class="string">'Display'</span>,<span class="string">'VerbosityLevel'</span>},<span class="string">'iter'</span>,{<span class="string">'off'</span>,<span class="string">'final'</span>,<span class="string">'iter'</span>,<span class="string">'full'</span>,<span class="string">'excessive'</span>},<span class="string">'Verbosity level.'</span>), <span class="keyword">...</span>
0317             arg({<span class="string">'optTol'</span>,<span class="string">'OptimalityTolerance'</span>},[],[],<span class="string">'First-order tolerance. Termination tolerance on the first-order optimality.'</span>), <span class="keyword">...</span>
0318             arg({<span class="string">'progTol'</span>,<span class="string">'ProgressTolerance'</span>},[],[],<span class="string">'Progress tolerance. Termination tolerance on progress in terms of function/parameter changes.'</span>), <span class="keyword">...</span>
0319             arg({<span class="string">'c1'</span>,<span class="string">'ArmijoParam'</span>},[],[],<span class="string">'Armijo parameter. Sufficient Decrease for Armijo condition.'</span>), <span class="keyword">...</span>
0320             arg({<span class="string">'c2'</span>,<span class="string">'WolfeParam'</span>},[],[],<span class="string">'Wolfe parameter. Curvature Decrease for Wolfe conditions. If [], this defaults to 0.2 for CG methods and 0.9 otherwise.'</span>), <span class="keyword">...</span>
0321             arg({<span class="string">'LS_init'</span>,<span class="string">'LineSearchInit'</span>},<span class="string">'Default'</span>,{<span class="string">'Default'</span>,<span class="string">'Always1'</span>,<span class="string">'AsPrevious'</span>,<span class="string">'QuadraticInterp'</span>,<span class="string">'TwicePrevious'</span>,<span class="string">'ScaledConj'</span>},<span class="string">'Line search initialization. The options are: Always try an initial step length of 1 (default for all except ''sd'' and ''cg''); Use a step similar to the previous step; Quadratic Initialization using previous function value and new; The minimum between 1 and twice the previous step length; The scaled conjugate gradient step length (may accelerate conjugate gradient methods, but requires a Hessian-vector product, default for ''scg'').'</span>), <span class="keyword">...</span>
0322             arg({<span class="string">'LS_type'</span>,<span class="string">'LineSearchType'</span>},<span class="string">'Default'</span>,{<span class="string">'Default'</span>,<span class="string">'BacktrackingArmijo'</span>,<span class="string">'BracketingWolfe'</span>,<span class="string">'MatlabOptTB'</span>},<span class="string">'Line search type. The options are: A backtracking line-search based on the Armijo condition (default for ''bb''); A bracekting line-search based on the strong Wolfe conditions (default for all other methods); The line-search from the Matlab Optimization Toolbox (requires Matlab''s linesearch.m to be added to the path).'</span>), <span class="keyword">...</span>
0323             arg({<span class="string">'LS_interp'</span>,<span class="string">'LineSearchInterpolation'</span>},<span class="string">'Default'</span>,{<span class="string">'Default'</span>,<span class="string">'DoubleOrBisect'</span>,<span class="string">'Cubic'</span>,<span class="string">'MixedQuadraticCubic'</span>},<span class="string">'Line search interpolation. For the Wolfe condition. The options are: Step Size Doubling and Bisection; Cubic interpolation/extrapolation using new function and gradient values; Mixed quadratic/cubic interpolation/extrapolation. MinFunc documents that Cubic is the default, while in practice it uses the Mixed mode.'</span>), <span class="keyword">...</span>
0324             arg({<span class="string">'LS_multi'</span>,<span class="string">'LineSearchExtraPoints'</span>},<span class="string">'Default'</span>,{<span class="string">'Default'</span>,<span class="string">'SameOrder'</span>,<span class="string">'HigherOrder'</span>},<span class="string">'Line search extra-points rule. How to handle extra points during the line search. The options are: Keep the same polynomial order regardless, or use a higher order (cubic,quadratic,quintic) if sufficient points are present.'</span>), <span class="keyword">...</span>
0325             arg({<span class="string">'useMex'</span>,<span class="string">'UseMex'</span>},true,[],<span class="string">'Use mex functions. Where applicable, use compiled mex files to speed things up (may not be available on every system).'</span>)},<span class="string">'Control options for the optimizer (minFunc).'</span>)}, <span class="keyword">...</span>
0326      <span class="string">'dictica'</span>, @dictlearn, <span class="keyword">...</span>
0327      <span class="string">'kernelica'</span>, { <span class="keyword">...</span>
0328         arg({<span class="string">'contrastfun'</span>,<span class="string">'ContrastFunc'</span>,<span class="string">'contrast'</span>},<span class="string">'kcca'</span>,{<span class="string">'kcca'</span>,<span class="string">'kgv'</span>},<span class="string">'Contrast function. Either Kernel Canonical Correlation Analysis or Kernel Generalized Variance.'</span>,<span class="string">'cat'</span>,<span class="string">'Core Parameters'</span>), <span class="keyword">...</span>
0329         arg({<span class="string">'contrasttype'</span>,<span class="string">'ContrastType'</span>},<span class="string">'full'</span>,{<span class="string">'full'</span>,<span class="string">'oneunit'</span>},<span class="string">'Type of the contrast function.'</span>,<span class="string">'cat'</span>,<span class="string">'Core Parameters'</span>), <span class="keyword">...</span>
0330         arg({<span class="string">'polish'</span>,<span class="string">'Finetune'</span>},true,[],<span class="string">'Double the precision. Finish with a half sigma value (gives better estimates).'</span>,<span class="string">'cat'</span>,<span class="string">'Core Parameters'</span>), <span class="keyword">...</span>
0331         arg({<span class="string">'restarts'</span>,<span class="string">'NumRestarts'</span>},1,uint32([0 1000]),<span class="string">'Number of restarts.'</span>,<span class="string">'cat'</span>,<span class="string">'Core Parameters'</span>), <span class="keyword">...</span>
0332         arg({<span class="string">'kernel'</span>,<span class="string">'KernelFunc'</span>},<span class="string">'gaussian'</span>,{<span class="string">'gaussian'</span>,<span class="string">'poly'</span>,<span class="string">'hermite'</span>},<span class="string">'Type of kernel for contrast function.'</span>,<span class="string">'cat'</span>,<span class="string">'Core Parameters'</span>), <span class="keyword">...</span>
0333         <span class="keyword">...</span>
0334         arg({<span class="string">'GaussianSigma'</span>},1,[0 Inf],<span class="string">'Bandwidth parameter for the Gaussian kernel.'</span>,<span class="string">'cat'</span>,<span class="string">'Miscellaneous'</span>), <span class="keyword">...</span>
0335         arg({<span class="string">'r'</span>,<span class="string">'PolyR'</span>},1,[],<span class="string">'Parameter r for the polynomial kernel.'</span>,<span class="string">'cat'</span>,<span class="string">'Miscellaneous'</span>), <span class="keyword">...</span>
0336         arg({<span class="string">'s'</span>,<span class="string">'PolyS'</span>},1,[],<span class="string">'Parameter s for the polynomial kernel.'</span>,<span class="string">'cat'</span>,<span class="string">'Miscellaneous'</span>), <span class="keyword">...</span>
0337         arg({<span class="string">'d'</span>,<span class="string">'PolyDegree'</span>},3,uint32([1 10]),<span class="string">'Degree of the polynomial kernel.'</span>,<span class="string">'cat'</span>,<span class="string">'Miscellaneous'</span>), <span class="keyword">...</span>
0338         arg({<span class="string">'p'</span>,<span class="string">'HermiteP'</span>},3,[],<span class="string">'Parameter p of the Hermite Kernel.'</span>,<span class="string">'cat'</span>,<span class="string">'Miscellaneous'</span>), <span class="keyword">...</span>
0339         arg({<span class="string">'HermiteSigma'</span>},2,[],<span class="string">'Parameter sigma of the Hermite Kernel.'</span>,<span class="string">'cat'</span>,<span class="string">'Miscellaneous'</span>), <span class="keyword">...</span>
0340         arg({<span class="string">'kap'</span>,<span class="string">'Kappa'</span>},0.01,[],<span class="string">'Regularization Parameter.'</span>,<span class="string">'cat'</span>,<span class="string">'Miscellaneous'</span>), <span class="keyword">...</span>
0341         arg({<span class="string">'dodisp'</span>,<span class="string">'Verbose'</span>,<span class="string">'disp'</span>},true,[],<span class="string">'Regularization Parameter.'</span>,<span class="string">'cat'</span>,<span class="string">'Miscellaneous'</span>)}, <span class="keyword">...</span>
0342     <span class="string">'fastkernelica'</span>, { <span class="keyword">...</span>
0343         arg({<span class="string">'maxiter'</span>,<span class="string">'MaxIterations'</span>},20,uint32([1,10000]),<span class="string">'Maximum number of iterations.'</span>,<span class="string">'cat'</span>,<span class="string">'Core Parameters'</span>), <span class="keyword">...</span>
0344         arg({<span class="string">'psigma'</span>,<span class="string">'KernelSize'</span>,<span class="string">'sigma'</span>},0.5,[],<span class="string">'Gaussian kernel size. One is a reasonable default; smaller values (e.g., 0.5) allow for higher precision, but can run into local minima.'</span>,<span class="string">'cat'</span>,<span class="string">'Core Parameters'</span>), <span class="keyword">...</span>
0345         arg({<span class="string">'thresh'</span>,<span class="string">'ConvergenceThreshold'</span>},1e-7,[],<span class="string">'Convergence threshold. The algorithm terminates when the difference in subsequent values of the kernel independence measure is lower than this.'</span>,<span class="string">'cat'</span>,<span class="string">'Core Parameters'</span>), <span class="keyword">...</span>
0346         arg({<span class="string">'restarts'</span>,<span class="string">'NumRestarts'</span>},10,uint32([0 1000]),<span class="string">'Number of restarts. Multiple restarts are necessary to find the global optimum, especially with small kernel sizes.'</span>,<span class="string">'cat'</span>,<span class="string">'Core Parameters'</span>)} <span class="keyword">...</span>
0347     <span class="string">'sphere'</span> {}, <span class="keyword">...</span>
0348     <span class="string">'robust_sphere'</span>, {}, <span class="keyword">...</span>
0349     }, <span class="string">'ICA variant. AMICA is the highest quality (but slowest, except if run on a cluster), Infomax is second-highest quality, FastICA is fastest (but can fail to converge and gives poorer results), KernelICA is experimental.'</span>), <span class="keyword">...</span>
0350     arg_sub({<span class="string">'data_cleaning'</span>,<span class="string">'DataCleaning'</span>,<span class="string">'CleaningLevel'</span>,<span class="string">'clean'</span>},{}, @<a href="flt_clean_settings.html" class="code" title="function signal = flt_clean_settings(varargin)">flt_clean_settings</a>,<span class="string">'Optional data cleaning prior to running an ICA. The computed ICA solution will be applied to the original uncleaned data.'</span>), <span class="keyword">...</span>
0351     arg({<span class="string">'do_transform'</span>,<span class="string">'TransformData'</span>,<span class="string">'transform'</span>},false,[],<span class="string">'Transform the data rather than annotate. By default, ICA decompositions are added as annotations to the data set.'</span>),<span class="keyword">...</span>
0352     arg({<span class="string">'retain_labels'</span>,<span class="string">'RetainLabels'</span>},true,[],<span class="string">'Retain labels when transforming. If this is false the channel labels will be replaced by 1:k for k components, if TransformData is checked.'</span>),<span class="keyword">...</span>
0353     arg({<span class="string">'clear_after_trans'</span>,<span class="string">'ClearAfterTransform'</span>},true,[],<span class="string">'Clear .icaweights after transform. This is so that later functions do not attempt to transform the already transformed data.'</span>),<span class="keyword">...</span>
0354     arg({<span class="string">'do_calcact'</span>,<span class="string">'CalculateActivation'</span>},false,[],<span class="string">'Calculate component activations. If true, the .icaact field will be populated.'</span>),<span class="keyword">...</span>
0355     arg({<span class="string">'cleaned_data'</span>,<span class="string">'OutputCleanedData'</span>},false,[],<span class="string">'Emit cleaned data. Whether the cleaned data, instead of the original data should be output (note: this is not applicable for online use, since most cleaning filters cannot be run online).'</span>),<span class="keyword">...</span>
0356     arg({<span class="string">'doresume'</span>,<span class="string">'ResumePrevious'</span>,<span class="string">'resume'</span>},true,[],<span class="string">'Try to resume previous computations if possible.'</span>), <span class="keyword">...</span>
0357     arg({<span class="string">'doforce'</span>,<span class="string">'ForceComputation'</span>,<span class="string">'force'</span>},false,[],<span class="string">'Force computation. Recompute ICA even if the input data set already has an attached ICA solution.'</span>), <span class="keyword">...</span>
0358     arg({<span class="string">'dodebug'</span>,<span class="string">'DebugMode'</span>,<span class="string">'debug'</span>},false,[],<span class="string">'Debug mode. Stops and waits for user input in case of an exception.'</span>,<span class="string">'guru'</span>,true), <span class="keyword">...</span>
0359     arg({<span class="string">'normalize_weights'</span>,<span class="string">'NormalizeWeights'</span>,<span class="string">'NormalizeWights'</span>},false,[],<span class="string">'Normalize weights.'</span>), <span class="keyword">...</span>
0360     arg_nogui({<span class="string">'state'</span>,<span class="string">'State'</span>}));
0361 
0362 <span class="keyword">if</span> ~isempty(state)
0363     <span class="comment">% online case: annotate the data</span>
0364     signal.icasphere = state.icasphere;
0365     signal.icaweights = state.icaweights;
0366     signal.icachansind = state.icachansind;
0367     signal.icawinv = state.icawinv;
0368     <span class="keyword">if</span> isfield(state,<span class="string">'amica'</span>)
0369         signal.etc.amica = state.amica; <span class="keyword">end</span>
0370 <span class="keyword">else</span>
0371     logfile = env_translatepath(<span class="string">'home:/.bcilab/logs/ica_datalog.log'</span>);
0372 
0373     <span class="comment">% offline case: check if we actually need to compute an ICA solution (or if the signal already</span>
0374     <span class="comment">% has one)</span>
0375     <span class="keyword">if</span> doforce || ~(isfield(signal,<span class="string">'icaweights'</span>) &amp;&amp; ~isempty(signal.icaweights))
0376         
0377         <span class="comment">% first pre-process the data (using a sequence of non-causal data reductions)</span>
0378         pre = signal;
0379         [chns,pnts,trials] = size(pre.data);
0380         
0381         <span class="keyword">if</span> trials ~= 1
0382             <span class="comment">% epoched dataset... reshape it</span>
0383             pre.data = reshape(pre.data,chns,[],1);
0384             [pre.chns,pre.pnts,pre.trials] = size(pre.data);
0385             <span class="comment">% delete event &amp; epoch information (would not survive artifact rejection, anyway)</span>
0386             pre.epochs = [];
0387             pre.event = [];
0388         <span class="keyword">end</span>
0389         
0390         <span class="comment">% clean the data</span>
0391         pre = exp_eval(<a href="flt_clean_settings.html" class="code" title="function signal = flt_clean_settings(varargin)">flt_clean_settings</a>(data_cleaning,<span class="string">'signal'</span>,pre));
0392                 
0393         <span class="comment">% get the underlying chanlocs</span>
0394         root_chanlocs = pre.chanlocs;
0395         <span class="keyword">global</span> debug_chanlocs; debug_chanlocs = pre.chanlocs;
0396         
0397         <span class="comment">% run ICA on preprocessed data</span>
0398         <span class="keyword">switch</span> variant.arg_selection <span class="comment">%#ok&lt;*NODEF&gt;</span>
0399             <span class="keyword">case</span> <span class="string">'noica'</span>
0400                 <span class="comment">% this is just for testing - creates random weights</span>
0401                 pre.icaweights = randn(length(pre.chanlocs));
0402                 pre.icasphere = eye(size(pre.data,1));
0403                 
0404             <span class="keyword">case</span> <span class="string">'amica'</span>
0405                 <span class="comment">% determine a unique identifier for this computation</span>
0406                 variant_core = hlp_struct2varargin(variant,<span class="string">'restrict'</span>,{ <span class="keyword">...</span>
0407                     <span class="string">'amica_version'</span>,<span class="string">'max_iter'</span>,<span class="string">'num_models'</span>,<span class="string">'num_mix_comps'</span>,<span class="string">'pdftype'</span>,<span class="string">'share_comps'</span>,<span class="string">'lrate'</span>,<span class="string">'lratefact'</span>,<span class="string">'minlrate'</span>,<span class="string">'rholrate'</span>,<span class="string">'rholratefact'</span>,<span class="string">'rho0'</span>,<span class="string">'minrho'</span>, <span class="keyword">...</span>
0408                     <span class="string">'maxrho'</span>,<span class="string">'do_newton'</span>,<span class="string">'newt_start'</span>,<span class="string">'newtrate'</span>,<span class="string">'newt_ramp'</span>,<span class="string">'comp_thresh'</span>,<span class="string">'share_start'</span>,<span class="string">'share_int'</span>,<span class="string">'do_reject'</span>,<span class="string">'numrej'</span>,<span class="string">'rejsig'</span>,<span class="string">'rejstart'</span>,<span class="string">'rejint'</span>,<span class="string">'kurt_start'</span>, <span class="keyword">...</span>
0409                     <span class="string">'num_kurt'</span>,<span class="string">'kurt_int'</span>,<span class="string">'update_A'</span>,<span class="string">'update_c'</span>,<span class="string">'update_gamma'</span>,<span class="string">'update_alpha'</span>,<span class="string">'update_mu'</span>,<span class="string">'update_sbeta'</span>,<span class="string">'do_rho'</span>,<span class="string">'decwindow'</span>,<span class="string">'invsigmax'</span>,<span class="string">'invsigmin'</span>,<span class="string">'do_mean'</span>, <span class="keyword">...</span>
0410                     <span class="string">'do_sphere'</span>,<span class="string">'doPCA'</span>,<span class="string">'pcakeep'</span>,<span class="string">'doscaling'</span>,<span class="string">'scalestep'</span>,<span class="string">'block_size'</span>});
0411                 tag = hlp_fingerprint({pre.tracking.expression,variant_core});
0412                 
0413                 <span class="comment">% set the output directory</span>
0414                 <span class="keyword">if</span> isempty(variant.outdir)
0415                     variant.outdir = env_translatepath([<span class="string">'temp:/amicaout-'</span> num2str(tag)]);
0416                 <span class="keyword">else</span>
0417                     <span class="comment">% sanitize output directory</span>
0418                     variant.outdir = env_translatepath(variant.outdir);
0419                     <span class="keyword">if</span> variant.outdir(end) ~= filesep
0420                         variant.outdir = [variant.outdir filesep]; <span class="keyword">end</span>
0421                 <span class="keyword">end</span>
0422                 <span class="keyword">if</span> ~isempty(variant.indir)
0423                     <span class="comment">% sanitize input directory</span>
0424                     variant.indir = env_translatepath(variant.indir);
0425                     <span class="keyword">if</span> variant.indir(end) ~= filesep
0426                         variant.indir = [variant.indir filesep]; <span class="keyword">end</span>
0427                 <span class="keyword">end</span>
0428                 
0429                 <span class="comment">% check if a final result for this problem is already there from a previous run</span>
0430                 <span class="keyword">if</span> variant.load_final &amp;&amp; exist([variant.outdir filesep <span class="string">'out.txt'</span>],<span class="string">'file'</span>)
0431                     <span class="keyword">try</span>
0432                         disp(<span class="string">'Checking for previous solutions for this computation...'</span>);
0433                         fileinfo = dir([variant.outdir filesep <span class="string">'out.txt'</span>]);
0434                         time_difference = (now - fileinfo.datenum)*24*60;
0435                         <span class="keyword">if</span> time_difference &lt; variant.reuse_margin
0436                             <span class="comment">% if the result file is too fresh, we might run into a</span>
0437                             <span class="comment">% conflict trying to write to a file that is still in use...</span>
0438                             conflict_potential = true; <span class="keyword">end</span> <span class="comment">%#ok&lt;NASGU&gt;</span>
0439                         
0440                         <span class="comment">% cycle through all alternative storage locations for this tag</span>
0441                         dirs = dir([variant.outdir <span class="string">'*'</span>]);
0442                         k = 1;
0443                         <span class="keyword">while</span> ~exist(<span class="string">'r'</span>,<span class="string">'var'</span>) &amp;&amp; k &lt;= length(dirs)
0444                             curdir = env_translatepath([<span class="string">'temp:/'</span> dirs(k).name]);
0445                             <span class="keyword">try</span>
0446                                 <span class="comment">% an out.txt was written, check if it stems from a completed run</span>
0447                                 t = fopen([curdir filesep <span class="string">'out.txt'</span>]);
0448                                 <span class="keyword">while</span> ~exist(<span class="string">'r'</span>,<span class="string">'var'</span>)
0449                                     line = fgetl(t);
0450                                     <span class="keyword">if</span> ~ischar(line)
0451                                         <span class="keyword">break</span>; <span class="keyword">end</span>
0452                                     <span class="keyword">if</span> ~isempty(strfind(line,<span class="string">'done.'</span>))
0453                                         <span class="comment">% found the 'done.' line - sanity-check the model</span>
0454                                         <span class="keyword">switch</span> variant.amica_version
0455                                             <span class="keyword">case</span> <span class="string">'stable12'</span>
0456                                                 tmp = loadmodout12(curdir);
0457                                             <span class="keyword">case</span> <span class="string">'stable11'</span>
0458                                                 tmp = loadmodout11(curdir);
0459                                             <span class="keyword">case</span> <span class="string">'devel'</span>
0460                                                 tmp = loadmodout10(curdir);
0461                                             <span class="keyword">case</span> <span class="string">'stable'</span>
0462                                                 tmp = loadmodout(curdir);
0463                                         <span class="keyword">end</span>
0464                                         <span class="keyword">if</span> isfield(tmp,<span class="string">'W'</span>) &amp;&amp; size(tmp.W,3) == tmp.num_models
0465                                             disp(<span class="string">'Found a previously successful Amica solution for the same problem.'</span>);
0466                                             r = tmp;
0467                                         <span class="keyword">end</span>
0468                                     <span class="keyword">end</span>
0469                                 <span class="keyword">end</span>
0470                                 fclose(t);
0471                             <span class="keyword">catch</span>
0472                                 disp(<span class="string">'Found an out.txt file of a previous Amica solution, but failed to load the model.'</span>);
0473                                 <span class="keyword">try</span>
0474                                     fclose(t);
0475                                 <span class="keyword">catch</span>,<span class="keyword">end</span>
0476                             <span class="keyword">end</span>
0477                             k = k+1;
0478                         <span class="keyword">end</span>
0479                     <span class="keyword">catch</span>
0480                         disp(<span class="string">'Found directories with alternative solutions, but failed trying to read them.'</span>);
0481                     <span class="keyword">end</span>
0482                 <span class="keyword">end</span>
0483                 
0484                 <span class="comment">% if no previous solution is not already there, go ahead!</span>
0485                 <span class="keyword">if</span> ~exist(<span class="string">'r'</span>,<span class="string">'var'</span>)
0486                     
0487                     <span class="keyword">if</span> exist(<span class="string">'conflict_potential'</span>,<span class="string">'var'</span>)
0488                         <span class="comment">% if there is conflict potential, we preferably choose a different output directory</span>
0489                         fprintf(<span class="string">'Target directory has results of a computation that was updated less than %i minutes ago; choosing a different output directory.\n'</span>,ceil(time_difference));
0490                         variant.outdir = [variant.outdir <span class="string">'-alt'</span> num2str(mod(tic,100000))];
0491                     <span class="keyword">end</span>
0492                     <span class="comment">% translate pdftype into the form expected by amica</span>
0493                     variant.pdftype = hlp_rewrite(variant.pdftype,<span class="string">'GeneralizedGaussian'</span>,0,<span class="string">'ExtendedInfomax'</span>,1,<span class="string">'Gaussian'</span>,2,<span class="string">'Logistic'</span>,3);
0494                     <span class="comment">% translate the PE auto-detection</span>
0495                     variant.use_pe = hlp_rewrite(variant.use_pe,<span class="string">'autodetect'</span>,<span class="string">''</span>);
0496                     <span class="comment">% translate all booleans into doubles</span>
0497                     <span class="keyword">for</span> fn=fieldnames(variant)'
0498                         <span class="keyword">if</span> islogical(variant.(fn{1}))
0499                             variant.(fn{1}) = double(variant.(fn{1})); <span class="keyword">end</span>
0500                     <span class="keyword">end</span>
0501                     <span class="comment">% check pcakeep</span>
0502                     <span class="keyword">if</span> isempty(variant.pcakeep)
0503                         variant.pcakeep = size(pre.data,1); <span class="keyword">end</span>
0504                     
0505                     <span class="comment">% keep track of this to generate random system configurations if amica fails with NaNs...</span>
0506                     original_numprocs = variant.numprocs;
0507                     
0508                     <span class="comment">% adapt argument list for the different supported amica versions...</span>
0509                     <span class="keyword">switch</span> variant.amica_version
0510                         <span class="keyword">case</span> {<span class="string">'stable11'</span>,<span class="string">'stable12'</span>}
0511                             suppress_args = {<span class="string">'scheduler'</span>,<span class="string">'do_mean'</span>,<span class="string">'do_sphere'</span>,<span class="string">'doPCA'</span>,<span class="string">'scalestep'</span>,<span class="string">'kurt_start'</span>,<span class="string">'num_kurt'</span>,<span class="string">'kurt_int'</span>,<span class="string">'load_comp_list'</span>,<span class="string">'block_size'</span>};
0512                             rewrite_args = {};
0513                             <span class="keyword">if</span> isempty(variant.max_threads)
0514                                 variant.max_threads = uint32(999); <span class="keyword">end</span>
0515                         <span class="keyword">case</span> <span class="string">'stable'</span>
0516                             suppress_args = {<span class="string">'share_comps'</span>,<span class="string">'share_int'</span>,<span class="string">'share_start'</span>,<span class="string">'comp_thresh'</span>,<span class="string">'doPCA'</span>,<span class="string">'do_mean'</span>,<span class="string">'do_sphere'</span>,<span class="string">'kurt_int'</span>,<span class="string">'num_kurt'</span>,<span class="string">'kurt_start'</span>,<span class="string">'load_comp_list'</span>,<span class="string">'load_rej'</span>,<span class="string">'scalestep'</span>,<span class="string">'block_size'</span>,<span class="string">'use_queue'</span>,<span class="string">'use_pe'</span>};
0517                             rewrite_args = {<span class="string">'update_A'</span>,<span class="string">'update_W'</span>};
0518                             <span class="keyword">if</span> isempty(variant.max_threads)
0519                                 variant.max_threads = uint32(4); <span class="keyword">end</span>
0520                         <span class="keyword">case</span> <span class="string">'devel'</span>
0521                             suppress_args = {<span class="string">'do_mean'</span>,<span class="string">'do_sphere'</span>,<span class="string">'doPCA'</span>,<span class="string">'scalestep'</span>,<span class="string">'kurt_start'</span>,<span class="string">'num_kurt'</span>,<span class="string">'kurt_int'</span>,<span class="string">'load_comp_list'</span>,<span class="string">'use_queue'</span>,<span class="string">'use_pe'</span>};
0522                             rewrite_args = {};
0523                             <span class="keyword">if</span> isempty(variant.max_threads)
0524                                 variant.max_threads = uint32(4); <span class="keyword">end</span>
0525                         <span class="keyword">case</span> <span class="string">'matlab'</span>
0526                             suppress_args = {<span class="string">'scheduler'</span>};
0527                             rewrite_args = {};
0528                         <span class="keyword">otherwise</span>
0529                             error(<span class="string">'Unsupported Amica version.'</span>)
0530                     <span class="keyword">end</span>
0531                     <span class="comment">% ...and apply a final set of argument transformations that hold across all version</span>
0532                     arglist = hlp_struct2varargin(variant,<span class="string">'suppress'</span>,[{<span class="string">'arg_selection'</span>,<span class="string">'arg_direct'</span>,<span class="string">'poll_interval'</span>,<span class="string">'max_start_waiting'</span>,<span class="string">'max_init_waiting'</span>,<span class="string">'reduce_factor'</span>,<span class="string">'fallback_reduce'</span>,<span class="string">'verbose'</span>,<span class="string">'max_restarts'</span>,<span class="string">'amica_version'</span>,<span class="string">'measure_window'</span>,<span class="string">'benefit_threshold'</span>,<span class="string">'native_threshold'</span>,<span class="string">'load_final'</span>,<span class="string">'flaky_cluster'</span>,<span class="string">'reuse_margin'</span>,<span class="string">'min_numprocs_fraction'</span>},suppress_args],<span class="string">'rewrite'</span>,[{<span class="string">'useqsub'</span>,<span class="string">'qsub'</span>}, rewrite_args]);
0533                     
0534                     <span class="keyword">if</span> strcmp(variant.amica_version,<span class="string">'matlab'</span>)
0535                         <span class="comment">% run native MATLAB version</span>
0536                         disp(<span class="string">'Running native MATLAB implementation of AMICA'</span>);
0537                         r = <a href="#_sub2" class="code" title="subfunction r = amica_native(pre,variant)">amica_native</a>(pre,variant);
0538                     <span class="keyword">else</span>
0539                         <span class="comment">% run fast binary version</span>
0540                         disp([<span class="string">'AMICA output is in '</span> variant.outdir]);
0541                         <span class="keyword">try</span>
0542                             
0543                             <span class="comment">% try to delete all files in this directory</span>
0544                             <span class="keyword">if</span> ~(doresume &amp;&amp; variant.load_param)
0545                                 <span class="keyword">try</span>
0546                                     files = dir(variant.outdir);
0547                                     <span class="keyword">for</span> f=1:length(files)
0548                                         <span class="keyword">if</span> ~isdir(files{f}.name)
0549                                             delete(files{f}.name); <span class="keyword">end</span>
0550                                     <span class="keyword">end</span>
0551                                 <span class="keyword">catch</span>, <span class="keyword">end</span>
0552                             <span class="keyword">end</span>
0553                             
0554                             <span class="comment">% initiate...</span>
0555                             <span class="keyword">if</span> strcmp(variant.useqsub,<span class="string">'off'</span>)
0556                                 <span class="comment">% run locally (without using the cluster)</span>
0557                                 <span class="keyword">switch</span> variant.amica_version
0558                                     <span class="keyword">case</span> <span class="string">'stable12'</span>
0559                                         r = runamica12(pre.data,[],arglist{:});
0560                                     <span class="keyword">case</span> <span class="string">'stable11'</span>
0561                                         r = runamica11(pre.data,[],arglist{:});
0562                                     <span class="keyword">case</span> <span class="string">'devel'</span>
0563                                         r = runamica10(pre.data,[],size(pre.data,1),size(pre.data,2), arglist{:});
0564                                     <span class="keyword">case</span> <span class="string">'stable'</span>
0565                                         r = runamica(pre.data,[],size(pre.data,1),size(pre.data,2), arglist{:});
0566                                 <span class="keyword">end</span>
0567                             <span class="keyword">else</span>
0568                                 <span class="comment">% find out the median Amica running time from past history</span>
0569                                 <span class="keyword">try</span>
0570                                     standard_normtime = median(load(env_translatepath(<span class="string">'resources:/amica_runtimes.txt'</span>)));
0571                                 <span class="keyword">catch</span>
0572                                     disp(<span class="string">'No past Amica performance history available.'</span>);
0573                                     standard_normtime = [];
0574                                 <span class="keyword">end</span>
0575                                 
0576                                 <span class="comment">% schedule a run on the cluster</span>
0577                                 [job,r,t0,iter_times,maxiters,lastlines,job_started,early_finish] = <a href="#_sub1" class="code" title="subfunction [job,result,t0,iter_times,maxiters,lastlines,job_started,early_finish] = schedule_amica(X,scheduler,amica_version,logfile,varargin)">schedule_amica</a>(pre.data,variant.scheduler,variant.amica_version,logfile,arglist{:});
0578                                 
0579                                 <span class="comment">% while not finished/terminated: monitor the computation...</span>
0580                                 num_restarts = 0;
0581                                 <span class="keyword">while</span> maxiters &lt; variant.max_iter &amp;&amp; ~early_finish
0582                                     pause(variant.poll_interval);
0583                                     
0584                                     <span class="comment">% scan the output that amica has produced so far and derive a few</span>
0585                                     <span class="comment">% variables</span>
0586                                     <span class="keyword">try</span>
0587                                         <span class="comment">% job is already started?</span>
0588                                         <span class="keyword">if</span> ~job_started &amp;&amp; exist([variant.outdir filesep <span class="string">'out.txt'</span>],<span class="string">'file'</span>)
0589                                             job_started = true; <span class="keyword">end</span>
0590                                         
0591                                         t = fopen([variant.outdir filesep <span class="string">'out.txt'</span>]);
0592                                         curline = 0;
0593                                         got_nan = false;
0594                                         lastiters = maxiters;
0595                                         <span class="keyword">while</span> 1
0596                                             <span class="comment">% get next line; display</span>
0597                                             line = fgetl(t);
0598                                             <span class="keyword">if</span> ~ischar(line)
0599                                                 <span class="keyword">break</span>; <span class="keyword">end</span>
0600                                             curline = curline + 1;
0601                                             <span class="keyword">if</span> curline &gt; lastlines
0602                                                 disp(line); <span class="keyword">end</span>
0603                                             
0604                                             <span class="comment">% amica finished?</span>
0605                                             <span class="keyword">if</span> ~isempty(strfind(line,<span class="string">'done.'</span>))
0606                                                 <span class="keyword">if</span> maxiters &lt; variant.max_iter
0607                                                     disp(<span class="string">'Amica finished early.'</span>); <span class="keyword">end</span>
0608                                                 early_finish = true;
0609                                             <span class="keyword">end</span>
0610                                             
0611                                             <span class="comment">% we got NaN's?</span>
0612                                             <span class="keyword">if</span> ~isempty(strfind(line,<span class="string">'NaN'</span>))
0613                                                 got_nan = true; <span class="keyword">end</span>
0614                                             
0615                                             <span class="keyword">try</span>
0616                                                 strs = hlp_split(line,<span class="string">' '</span>);
0617                                                 <span class="comment">% we got an iteration output?</span>
0618                                                 <span class="keyword">if</span> strcmp(strs{1},<span class="string">'iter'</span>)
0619                                                     <span class="comment">% remember the iteration number</span>
0620                                                     <span class="keyword">if</span> 2 &lt;= length(strs)
0621                                                         maxiters = str2num(strs{2}); <span class="keyword">end</span>
0622                                                     <span class="keyword">try</span>
0623                                                         <span class="comment">% ... and collect samples of the iteration times</span>
0624                                                         idx = find(strcmp(strs,<span class="string">'s,'</span>),1)-1;
0625                                                         <span class="keyword">if</span> ~isempty(idx) &amp;&amp; idx &lt;= length(strs)
0626                                                             iter_times(curline) = str2num(strs{idx}); <span class="keyword">end</span>
0627                                                     <span class="keyword">catch</span>,<span class="keyword">end</span>
0628                                                 <span class="keyword">end</span>
0629                                             <span class="keyword">catch</span>,<span class="keyword">end</span>
0630                                         <span class="keyword">end</span>
0631                                         
0632                                         <span class="keyword">if</span> lastiters == 0
0633                                             <span class="comment">% measure the time it took to start the computation</span>
0634                                             <span class="comment">% (for statistics &amp; decision-making...)</span>
0635                                             startup_time = toc(t0) - sum(iter_times); <span class="keyword">end</span>
0636                                         
0637                                         lastlines = curline;
0638                                         fclose(t);
0639                                     <span class="keyword">catch</span>
0640                                         <span class="keyword">try</span>
0641                                             fclose(t);
0642                                         <span class="keyword">catch</span>,<span class="keyword">end</span>
0643                                     <span class="keyword">end</span>
0644                                     
0645                                     <span class="comment">% check if amica is running so slowly that we need to restart it</span>
0646                                     <span class="keyword">if</span> ~isempty(iter_times) &amp;&amp; ~isempty(standard_normtime) &amp;&amp; ~(any(strcmp(variant.amica_version,{<span class="string">'stable11'</span>,<span class="string">'stable12'</span>})) &amp;&amp; ~isempty(variant.use_queue))
0647                                         <span class="comment">% estimate computational complexity for the current configuration</span>
0648                                         [C,S] = size(pre.data);
0649                                         M = variant.num_models;
0650                                         K = variant.num_mix_comps;
0651                                         P = variant.numprocs;
0652                                         config_complexity = ((M*(C*C*S + K*C*S + C*S*S))/P);
0653                                         
0654                                         <span class="comment">% compute complexity-normalized runtime per iteration</span>
0655                                         iter_normtime = iter_times / config_complexity;
0656                                         
0657                                         <span class="comment">% measure the average computational throughput in the past measurement window</span>
0658                                         cutoff = find(cumsum(iter_times(end:-1:1)) &gt; variant.measure_window,1);
0659                                         <span class="keyword">if</span> ~isempty(cutoff)
0660                                             mean_normtime = mean(iter_normtime(end-cutoff+1:end));
0661                                             <span class="comment">% compute expected runtime with the current compute throughput</span>
0662                                             expected_runtime = startup_time + sum(iter_times) + (mean_normtime * config_complexity * (variant.max_iter - maxiters));
0663                                             <span class="comment">% compute expected runtime with the mean compute throughput</span>
0664                                             standard_runtime = startup_time + (standard_normtime * config_complexity * variant.max_iter);
0665                                             
0666                                             <span class="comment">% is it better to reschedule?</span>
0667                                             <span class="keyword">if</span> expected_runtime / standard_runtime &gt; variant.benefit_threshold &amp;&amp; num_restarts &lt; variant.max_restarts
0668                                                 disp(<span class="string">'Computation on the cluster is very slow; re-starting to get a better node allocation'</span>);
0669                                                 <span class="keyword">if</span> length(job) &gt;= 2
0670                                                     <span class="keyword">if</span> isa(job{2},<span class="string">'onCleanup'</span>)
0671                                                         <span class="comment">% clearing the job will implicitly lead to its deletion</span>
0672                                                         clear job;
0673                                                     <span class="keyword">else</span> isa(job{2},<span class="string">'function_handle'</span>)
0674                                                         <span class="comment">% old MATLAB version: we invoke the function in job{2} to delete it explicitly</span>
0675                                                         job{2}();
0676                                                     <span class="keyword">end</span>
0677                                                 <span class="keyword">else</span>
0678                                                     disp(<span class="string">'couldn''t delete the previous jobs; please delete them manually.'</span>);
0679                                                 <span class="keyword">end</span>
0680                                                 variant.benefit_threshold = variant.benefit_threshold + 1;
0681                                                 <span class="comment">% restart computation...</span>
0682                                                 num_restarts = num_restarts + 1;
0683                                                 [job,r,t0,iter_times,maxiters,lastlines,job_started,early_finish] = <a href="#_sub1" class="code" title="subfunction [job,result,t0,iter_times,maxiters,lastlines,job_started,early_finish] = schedule_amica(X,scheduler,amica_version,logfile,varargin)">schedule_amica</a>(pre.data,variant.scheduler,variant.amica_version,logfile,arglist{:},<span class="string">'numprocs'</span>,variant.numprocs);
0684                                                 pause(startup_time);
0685                                             <span class="keyword">elseif</span> expected_runtime / standard_runtime &gt; variant.native_threshold &amp;&amp; num_restarts &gt;= variant.max_restarts
0686                                                 <span class="keyword">if</span> variant.flaky_cluster
0687                                                     disp(<span class="string">'The cluster is apparently overloaded; not doing any further restarts from now on.'</span>);
0688                                                 <span class="keyword">else</span>
0689                                                     disp(<span class="string">'Computation on the cluster is extremely slow; reverting to native MATLAB computatation on local machine.'</span>);
0690                                                     <span class="comment">% fall back to native Amica implementation...</span>
0691                                                     error(<span class="string">'fall back'</span>);
0692                                                 <span class="keyword">end</span>
0693                                             <span class="keyword">end</span>
0694                                         <span class="keyword">end</span>
0695                                     <span class="keyword">end</span>
0696                                     
0697                                     <span class="comment">% check if amica is starting to produce NaN values</span>
0698                                     <span class="keyword">if</span> got_nan
0699                                         <span class="comment">% sometimes AMICA gives NaN outputs; need to restart in this case</span>
0700                                         disp(<span class="string">'Got NaN outputs; trying to restart the job...'</span>);
0701                                         <span class="keyword">if</span> length(job) &gt;= 2
0702                                             <span class="keyword">if</span> isa(job{2},<span class="string">'onCleanup'</span>)
0703                                                 <span class="comment">% clearing the job will implicitly lead to its deletion</span>
0704                                                 clear job;
0705                                             <span class="keyword">else</span> isa(job{2},<span class="string">'function_handle'</span>)
0706                                                 <span class="comment">% old MATLAB version: we invoke the function in job{2} to delete it explicitly</span>
0707                                                 job{2}();
0708                                             <span class="keyword">end</span>
0709                                         <span class="keyword">else</span>
0710                                             disp(<span class="string">'couldn''t delete the previous jobs; please delete them manually.'</span>);
0711                                         <span class="keyword">end</span>
0712                                         <span class="keyword">if</span> num_restarts &gt; variant.max_restarts &amp;&amp; ~variant.flaky_cluster
0713                                             disp(<span class="string">'Amica consistently gives NaN outputs; falling back to MATLAB implementation.'</span>)
0714                                             error(<span class="string">'fall back'</span>);
0715                                         <span class="keyword">else</span>
0716                                             <span class="keyword">if</span> strcmp(variant.amica_version,<span class="string">'stable11'</span>)
0717                                                 disp(<span class="string">'Choosing a random number of processors.'</span>);
0718                                                 <span class="keyword">if</span> ~exist(<span class="string">'numprocs_tried'</span>,<span class="string">'var'</span>)
0719                                                     numprocs_tried = []; <span class="keyword">end</span>
0720                                                 <span class="keyword">while</span> true
0721                                                     variant.numprocs = floor(original_numprocs*variant.min_numprocs_fraction + original_numprocs*(1-variant.min_numprocs_fraction)*rand);
0722                                                     <span class="keyword">if</span> ~any(variant.numprocs == numprocs_tried)
0723                                                         numprocs_tried(end+1) = variant.numprocs;
0724                                                         <span class="keyword">break</span>;
0725                                                     <span class="keyword">elseif</span> length(numprocs_tried) &gt;= (original_numprocs*(1-variant.min_numprocs_fraction))-1
0726                                                         disp(<span class="string">'Tried all possible system configurations; giving up and running locally...'</span>);
0727                                                         error(<span class="string">'fall back'</span>);
0728                                                     <span class="keyword">end</span>
0729                                                 <span class="keyword">end</span>
0730                                             <span class="keyword">end</span>
0731                                             
0732                                             <span class="comment">% re-start the job</span>
0733                                             num_restarts = num_restarts + 1;
0734                                             [job,r,t0,iter_times,maxiters,lastlines,job_started,early_finish] = <a href="#_sub1" class="code" title="subfunction [job,result,t0,iter_times,maxiters,lastlines,job_started,early_finish] = schedule_amica(X,scheduler,amica_version,logfile,varargin)">schedule_amica</a>(pre.data,variant.scheduler,variant.amica_version,logfile,arglist{:},<span class="string">'numprocs'</span>,variant.numprocs);
0735                                             exist([variant.outdir filesep <span class="string">'out.txt'</span>],<span class="string">'file'</span>)
0736                                         <span class="keyword">end</span>
0737                                     <span class="keyword">end</span>
0738                                     
0739                                     <span class="comment">% check if starting the job takes suspiciously long (indicating</span>
0740                                     <span class="comment">% that the job size exceeds the cluster quota)</span>
0741                                     <span class="keyword">if</span> (~job_started &amp;&amp; toc(t0) &gt; variant.max_start_waiting) || (maxiters == 0 &amp;&amp; toc(t0) &gt; variant.max_init_waiting)
0742                                         <span class="comment">% in this case, we reduce that and delete the job</span>
0743                                         <span class="keyword">if</span> ~job_started
0744                                             disp(<span class="string">'Apparently, the AMICA jobs didn''t get scheduled; restarting with '</span>);
0745                                         <span class="keyword">else</span>
0746                                             disp(<span class="string">'Apparently, the AMICA computation didn''t init properly; restarting with '</span>);
0747                                         <span class="keyword">end</span>
0748                                         variant.numprocs = ceil(variant.numprocs*variant.reduce_factor);
0749                                         disp([<span class="string">'N = '</span> num2str(variant.numprocs)]);
0750                                         <span class="keyword">if</span> length(job) &gt;= 2
0751                                             <span class="keyword">if</span> isa(job{2},<span class="string">'onCleanup'</span>)
0752                                                 <span class="comment">% clearing the job will implicitly lead to its deletion</span>
0753                                                 clear job;
0754                                             <span class="keyword">else</span> isa(job{2},<span class="string">'function_handle'</span>)
0755                                                 <span class="comment">% old MATLAB version: we invoke the function in job{2} to delete it explicitly</span>
0756                                                 job{2}();
0757                                             <span class="keyword">end</span>
0758                                         <span class="keyword">else</span>
0759                                             disp(<span class="string">'couldn''t delete the previous jobs; please delete them manually.'</span>);
0760                                         <span class="keyword">end</span>
0761                                         
0762                                         <span class="keyword">if</span> variant.numprocs &lt;= 4 &amp;&amp; ~variant.flaky_cluster
0763                                             disp(<span class="string">'Could not acquire cluster resource; falling back to local computation. Note NaN checks cannot be performed in this mode.'</span>);
0764                                             
0765                                             <span class="comment">% try it locally...</span>
0766                                             <span class="keyword">switch</span> variant.amica_version
0767                                                 <span class="keyword">case</span> <span class="string">'devel'</span>
0768                                                     r = runamica10(pre.data,[],size(pre.data,1),size(pre.data,2), arglist{:},<span class="string">'numprocs'</span>,variant.numprocs,<span class="string">'qsub'</span>,<span class="string">'off'</span>);
0769                                                 <span class="keyword">case</span> <span class="string">'stable'</span>
0770                                                     r = runamica(pre.data,[],size(pre.data,1),size(pre.data,2), arglist{:},<span class="string">'numprocs'</span>,variant.numprocs,<span class="string">'qsub'</span>,<span class="string">'off'</span>);
0771                                                 <span class="keyword">case</span> <span class="string">'stable11'</span>
0772                                                     r = runamica11(pre.data,[],arglist{:},<span class="string">'numprocs'</span>,variant.numprocs,<span class="string">'qsub'</span>,<span class="string">'off'</span>);
0773                                                 <span class="keyword">case</span> <span class="string">'stable12'</span>
0774                                                     r = runamica12(pre.data,[],arglist{:},<span class="string">'numprocs'</span>,variant.numprocs,<span class="string">'qsub'</span>,<span class="string">'off'</span>);
0775                                             <span class="keyword">end</span>
0776                                             
0777                                             <span class="comment">% ... and leave the while loop with a valid r</span>
0778                                             <span class="keyword">break</span>;
0779                                         <span class="keyword">else</span>
0780                                             <span class="comment">% re-start the job...</span>
0781                                             [job,r,t0,iter_times,maxiters,lastlines,job_started,early_finish] = <a href="#_sub1" class="code" title="subfunction [job,result,t0,iter_times,maxiters,lastlines,job_started,early_finish] = schedule_amica(X,scheduler,amica_version,logfile,varargin)">schedule_amica</a>(pre.data,variant.scheduler,variant.amica_version,logfile,arglist{:},<span class="string">'numprocs'</span>,variant.numprocs);
0782                                         <span class="keyword">end</span>
0783                                     <span class="keyword">end</span>
0784                                 <span class="keyword">end</span>
0785                                 
0786                                 <span class="comment">% done runnning on the cluster - load the results</span>
0787                                 <span class="keyword">if</span> ~isfield(r,<span class="string">'W'</span>)
0788                                     <span class="keyword">switch</span> variant.amica_version
0789                                         <span class="keyword">case</span> <span class="string">'stable12'</span>
0790                                             r = loadmodout12(variant.outdir);
0791                                         <span class="keyword">case</span> <span class="string">'stable11'</span>
0792                                             r = loadmodout11(variant.outdir);
0793                                         <span class="keyword">case</span> <span class="string">'devel'</span>
0794                                             r = loadmodout10(variant.outdir);
0795                                         <span class="keyword">case</span> <span class="string">'stable'</span>
0796                                             r = loadmodout(variant.outdir);
0797                                     <span class="keyword">end</span>
0798                                 <span class="keyword">end</span>
0799                                 
0800                                 <span class="comment">% append the iteration time samples to the current list of amica runtimes...</span>
0801                                 <span class="keyword">try</span>
0802                                     f = fopen(env_translatepath(<span class="string">'resources:/amica_runtimes.txt'</span>),<span class="string">'a+'</span>);
0803                                     fprintf(f,<span class="string">' %d'</span>,iter_normtime);
0804                                     fclose(f);
0805                                 <span class="keyword">catch</span>
0806                                     <span class="keyword">try</span>
0807                                         fclose(f);
0808                                     <span class="keyword">catch</span>,<span class="keyword">end</span>
0809                                 <span class="keyword">end</span>
0810                             <span class="keyword">end</span>
0811                             
0812                             <span class="comment">% check if the result data is broken, such that we need to fall back</span>
0813                             <span class="comment">% to a native MATLAB implementation</span>
0814                             <span class="keyword">if</span> isempty(r)
0815                                 error(<span class="string">'fall back'</span>); <span class="keyword">end</span>
0816                             <span class="keyword">if</span> ~isfield(r,<span class="string">'S'</span>)
0817                                 error(<span class="string">'fall back'</span>); <span class="keyword">end</span>
0818                         <span class="keyword">catch</span> e
0819                             <span class="comment">% run the pure MATLAB variant</span>
0820                             disp([<span class="string">'note: runamica failed to run; reason: '</span> e.message]);
0821                             disp(<span class="string">'      falling back to MATLAB variant; available parameters: '</span>);
0822                             disp(<span class="string">'      num_models, num_mix_comps, do_mean/do_sphere, do_newton'</span>);
0823                             variant.max_iter = ceil(variant.max_iter * variant.fallback_reduce);
0824                             <span class="keyword">try</span>
0825                                 r = <a href="#_sub2" class="code" title="subfunction r = amica_native(pre,variant)">amica_native</a>(pre,variant);
0826                             <span class="keyword">catch</span> e
0827                                 disp(<span class="string">'Native MATLAB implementation of amica ran into an error. Giving up now.'</span>);
0828                                 rethrow(e);
0829                             <span class="keyword">end</span>
0830                         <span class="keyword">end</span>
0831                     <span class="keyword">end</span>
0832                     quicklog(logfile,<span class="string">'=== success; outdir=%s ==='</span>,variant.outdir);
0833                 <span class="keyword">end</span>
0834                 
0835                 <span class="comment">% translate properties from r (the result) to pre (the data set)</span>
0836                 pre.icasphere  = r.S;
0837                 <span class="keyword">if</span> size(r.W,3) &gt; 1
0838                     <span class="comment">% we have multiple models...</span>
0839                     <span class="comment">% take the most likely model as weights and sphere</span>
0840                     [x,bestmod] = max(r.mod_prob); <span class="comment">%#ok&lt;ASGLU&gt;</span>
0841                     pre.icaweights = r.W(:,:,bestmod);
0842                     <span class="comment">% but retain all the rest in .etc.amica</span>
0843                     <span class="keyword">if</span> exist(<span class="string">'mask'</span>,<span class="string">'var'</span>)
0844                         r.sample_mask = mask; <span class="keyword">end</span>
0845                 <span class="keyword">else</span>
0846                     pre.icaweights = r.W;
0847                 <span class="keyword">end</span>
0848                 signal.etc.amica = r;                
0849             <span class="keyword">case</span> <span class="string">'infomax'</span>
0850                 <span class="comment">% translate all booleans into 'on'/'off'</span>
0851                 variant = structfun(@(p) quickif(islogical(p),quickif(p,<span class="string">'on'</span>,<span class="string">'off'</span>),p),variant,<span class="string">'UniformOutput'</span>,false);
0852                 arglist = hlp_struct2varargin(variant,<span class="string">'suppress'</span>,{<span class="string">'arg_selection'</span>,<span class="string">'arg_direct'</span>},<span class="string">'rewrite'</span>,{<span class="string">'pstop'</span>,<span class="string">'stop'</span>,<span class="string">'pweights'</span>,<span class="string">'weights'</span>,<span class="string">'pblock'</span>,<span class="string">'block'</span>,<span class="string">'pposact'</span>,<span class="string">'posact'</span>});
0853                 [pre.icaweights,pre.icasphere] = hlp_diskcache(<span class="string">'icaweights'</span>,@runica,pre.data,arglist{:});
0854             <span class="keyword">case</span> <span class="string">'beamica'</span>
0855                 sig = cov(pre.data');
0856                 <span class="keyword">if</span> ~isempty(variant.anchorlabels)
0857                     <span class="comment">% calc beamformer penalty matrix for selected locations</span>
0858                     [B,init_W,chanmask] = hlp_diskcache(<span class="string">'filterdesign'</span>,@calc_beamformer_constraints,{pre.chanlocs.labels},variant.anchorlabels,sig,variant.reference); <span class="comment">%#ok&lt;ASGLU&gt;</span>
0859                     <span class="comment">% remove missing channels</span>
0860                     <span class="keyword">if</span> ~any(chanmask)
0861                         error(<span class="string">'None of your channels is in the head model; the AnchorLabels option can currently only be used for data with 10-20 labels.'</span>); <span class="keyword">end</span>
0862                     pre.data = pre.data(chanmask,:,:,:,:,:,:,:);
0863                     pre.chanlocs = pre.chanlocs(chanmask);
0864                     pre.nbchan = size(pre.data,1);
0865                 <span class="keyword">else</span>
0866                     B = {};
0867                 <span class="keyword">end</span>
0868                 [pre.icaweights,pre.icasphere] = hlp_diskcache(<span class="string">'icaweights'</span>,@beamica,pre.data,B,[],[],[],variant.max_iter,variant.lrate,variant.tradeoff,variant.verbose,variant.usegpu,variant.convergence_check);
0869             <span class="keyword">case</span> <span class="string">'fastica'</span>
0870                 <span class="comment">% translate all booleans into 'on'/'off'</span>
0871                 variant = structfun(@(p) quickif(islogical(p),quickif(p,<span class="string">'on'</span>,<span class="string">'off'</span>),p),variant,<span class="string">'UniformOutput'</span>,false);
0872                 arglist = hlp_struct2varargin(variant,<span class="string">'suppress'</span>,{<span class="string">'arg_selection'</span>,<span class="string">'arg_direct'</span>},<span class="string">'rewrite'</span>,{<span class="string">'stepsize'</span>,<span class="string">'mu'</span>});
0873                 [dummy,pre.icaweights] = hlp_diskcache(<span class="string">'icaweights'</span>,@fastica,pre.data,arglist{:}); <span class="comment">%#ok&lt;ASGLU&gt;</span>
0874                 pre.icasphere = eye(size(pre.data,1));
0875             <span class="keyword">case</span> <span class="string">'rica'</span>                
0876                 variant.solverOptions.Method = hlp_rewrite(variant.solverOptions.Method, <span class="keyword">...</span>
0877                     <span class="string">'Steepest Descent'</span>,<span class="string">'sd'</span>,<span class="string">'Cyclic Steepest Descent'</span>,<span class="string">'csd'</span>,<span class="string">'Barzilai and Borwein Gradient'</span>,<span class="string">'bb'</span>,<span class="keyword">...</span>
0878                     <span class="string">'Non-Linear Conjugate Gradient'</span>,<span class="string">'cg'</span>,<span class="string">'Scaled Non-Linear Conjugate Gradient'</span>,<span class="string">'scg'</span>,<span class="string">'Preconditionined Non-Linear Conjugate Gradient'</span>,<span class="string">'pcg'</span>,<span class="keyword">...</span>
0879                     <span class="string">'Quasi-Newton with Limited-Memory BFGS Updating'</span>,<span class="string">'lbfgs'</span>,<span class="string">'Hessian-Free Newton'</span>,<span class="string">'newton0'</span>,<span class="keyword">...</span>
0880                     <span class="string">'Preconditioned Hessian-Free Newton'</span>,<span class="string">'pnewton0'</span>,<span class="string">'Quasi-Newton Hessian approximation'</span>,<span class="string">'qnewton'</span>, <span class="keyword">...</span>
0881                     <span class="string">'Newton with Hessian update every k''th step'</span>,<span class="string">'mnewton'</span>);
0882                 variant.solverOptions.LS_init = hlp_rewrite(variant.solverOptions.LS_init,<span class="string">'Default'</span>,[],<span class="string">'Always1'</span>,0,<span class="string">'AsPrevious'</span>,1,<span class="string">'QuadraticInterp'</span>,2,<span class="string">'TwicePrevious'</span>,3,<span class="string">'ScaledConj'</span>,4);
0883                 variant.solverOptions.LS_type = hlp_rewrite(variant.solverOptions.LS_type,<span class="string">'Default'</span>,[],<span class="string">'BacktrackingArmijo'</span>,0,<span class="string">'BracketingWolfe'</span>,1,<span class="string">'MatlabOptTB'</span>,2);
0884                 variant.solverOptions.LS_interp = hlp_rewrite(variant.solverOptions.LS_interp,<span class="string">'Default'</span>,[],<span class="string">'DoubleOrBisect'</span>,0,<span class="string">'Cubic'</span>,1,<span class="string">'MixedQuadraticCubic'</span>,2);
0885                 variant.solverOptions.LS_multi = hlp_rewrite(variant.solverOptions.LS_multi,<span class="string">'Default'</span>,[],<span class="string">'SameOrder'</span>,0,<span class="string">'HigherOrder'</span>,1);
0886                 variant.chan_labels = {pre.chanlocs.labels};
0887                 variant.chan_locs = pre.chanlocs;
0888                 <span class="keyword">if</span> doforce
0889                     [pre.icaweights,pre.icasphere,pre.icachansind] = rica(pre.data,variant,variant.solverOptions);
0890                 <span class="keyword">else</span>
0891                     [pre.icaweights,pre.icasphere,pre.icachansind] = hlp_diskcache(<span class="string">'icaweights'</span>,@rica,pre.data,variant,variant.solverOptions);
0892                 <span class="keyword">end</span>
0893             <span class="keyword">case</span> <span class="string">'dictica'</span>
0894                 <span class="comment">% use dictionary learning</span>
0895                  [pre.icadict,pre.icasphere] = hlp_diskcache(<span class="string">'icaweights'</span>,@dictlearn,variant,<span class="string">'X'</span>,pre.data,<span class="string">'chanlocs'</span>,pre.chanlocs);
0896             <span class="keyword">case</span> <span class="string">'kernelica'</span>
0897                 <span class="comment">% translate all booleans into 0/1</span>
0898                 variant = structfun(@(p) quickif(islogical(p),double(p),p),variant,<span class="string">'UniformOutput'</span>,false);
0899                 <span class="keyword">if</span> strcmp(variant.kernel,<span class="string">'gaussian'</span>)
0900                     variant.sig = variant.GaussianSigma;
0901                 <span class="keyword">else</span>
0902                     variant.sig = variant.HermiteSigma;
0903                 <span class="keyword">end</span>
0904                 arglist = hlp_struct2varargin(variant,<span class="string">'suppress'</span>,{<span class="string">'arg_selection'</span>,<span class="string">'arg_direct'</span>,<span class="string">'GaussianSigma'</span>,<span class="string">'HermiteSigma'</span>},<span class="string">'rewrite'</span>,{<span class="string">'contrastfun'</span>,<span class="string">'contrast'</span>,<span class="string">'dodisp'</span>,<span class="string">'disp'</span>});
0905                 pre.icaweights = hlp_diskcache(<span class="string">'icaweights'</span>,@kernel_ica_options,pre.data,arglist{:});
0906                 pre.icasphere = eye(size(pre.data,1));
0907             <span class="keyword">case</span> <span class="string">'fastkernelica'</span>
0908                 <span class="comment">% fast KernelICA is a euphemism</span>
0909                 C = size(pre.data,1);
0910                 pre.icasphere = 2.0*inv(sqrtm(cov(pre.data'))); <span class="comment">%#ok&lt;MINV&gt;</span>
0911                 guess = eye(C);
0912                 <span class="keyword">for</span> k=1:variant.restarts
0913                     tmpdata = (pre.icasphere * pre.data);
0914                     [Ws{k}, dummy, HSIC] = hlp_diskcache(<span class="string">'icaweights'</span>,@fastkica,tmpdata, guess, variant.maxiter, variant.psigma, variant.thresh); <span class="comment">%#ok&lt;ASGLU&gt;</span>
0915                     guess = eye(C) + randn(C);
0916                     HSICs(k) = min(HSIC);
0917                 <span class="keyword">end</span>
0918                 [dummy,bestidx] = min(HSICs); <span class="comment">%#ok&lt;ASGLU&gt;</span>
0919                 pre.icaweights = Ws{bestidx};
0920             <span class="keyword">case</span> <span class="string">'sphere'</span>
0921                  pre.icasphere = inv(sqrtm(cov(pre.data')));
0922                  pre.icaweights = eye(size(pre.data,1));
0923             <span class="keyword">case</span> <span class="string">'robust_sphere'</span>
0924                  pre.icasphere = inv(sqrtm(hlp_diskcache(<span class="string">'icaweights'</span>,@cov_blockgeom,pre.data')));
0925                  pre.icaweights = eye(size(pre.data,1));
0926             <span class="keyword">otherwise</span>
0927                 <span class="comment">% let pop_runica handle all the rest</span>
0928                 arglist = hlp_struct2varargin(variant,<span class="string">'suppress'</span>,{<span class="string">'arg_selection'</span>,<span class="string">'arg_direct'</span>});
0929                 pre = pop_runica(pre,<span class="string">'icatype'</span>,variant.label,arglist{:});
0930         <span class="keyword">end</span>
0931         
0932         
0933         <span class="comment">% add channel indices, if necessary</span>
0934         <span class="keyword">try</span>
0935             <span class="keyword">if</span> isempty(pre.icachansind)
0936                 pre.icachansind = 1:size(pre.data,1); <span class="keyword">end</span>
0937             <span class="comment">% add weight inverse (mixing matrix), if necessary</span>
0938             <span class="keyword">if</span> isempty(pre.icawinv)
0939                 pre.icawinv = pinv(pre.icaweights*pre.icasphere); <span class="keyword">end</span>;
0940             <span class="comment">% normalize winv, for better plotting</span>
0941             <span class="keyword">if</span> normalize_weights
0942                 normalizer = sqrt(1./sum(pre.icawinv.*pre.icawinv));
0943                 pre.icawinv = single(pre.icawinv .* (ones(size(pre.icawinv,1),1)*normalizer));
0944                 pre.icaweights = diag(1./normalizer)*pre.icaweights;
0945             <span class="keyword">end</span>          
0946             
0947             <span class="keyword">if</span> cleaned_data
0948                 signal = pre;
0949                 <span class="keyword">if</span> trials ~= 1
0950                     warning(<span class="string">'BCILAB:flt_ica:data_loss'</span>,<span class="string">'The original epoch and event information has been erased from the cleaned data during artifact rejection; cannot restore.'</span>);
0951                     signal.data = reshape(signal.data,chans,pnts,trials);
0952                 <span class="keyword">end</span>
0953             <span class="keyword">else</span>
0954                 <span class="comment">% carry over the fields to the output data set</span>
0955                 signal.icaweights = pre.icaweights;
0956                 signal.icasphere = pre.icasphere;
0957                 signal.icawinv = pre.icawinv;
0958                 <span class="comment">% if channel rejection was used, we remember from which channels the ica map was derived</span>
0959                 [dummy,idxeeg,idxpre] = intersect({signal.chanlocs.labels},{pre.chanlocs.labels}); <span class="comment">%#ok&lt;ASGLU&gt;</span>
0960                 [dummy,idxpre_order] = sort(idxpre);  <span class="comment">%#ok&lt;ASGLU&gt;</span>
0961                 signal.icachansind = idxeeg(idxpre_order);
0962             <span class="keyword">end</span>
0963         <span class="keyword">catch</span> e
0964             <span class="keyword">if</span> dodebug
0965                 disp(<span class="string">'Error in flt_ica code; waiting for user input. You can disable this behavior by setting the DebugMode option to false.'</span>);
0966                 keyboard;
0967             <span class="keyword">else</span>
0968                 rethrow(e);
0969             <span class="keyword">end</span>
0970         <span class="keyword">end</span>
0971     <span class="keyword">else</span>
0972         disp(<span class="string">'The dataset already contains an IC decomposition; skipping... (note: set parameter ''doforce'' to true to force re-computation).'</span>);
0973     <span class="keyword">end</span>
0974     
0975     <span class="comment">% generate root chanlocs, if not already there</span>
0976     <span class="keyword">if</span> ~exist(<span class="string">'root_chanlocs'</span>,<span class="string">'var'</span>)
0977         root_chanlocs = signal.chanlocs(signal.icachansind); <span class="keyword">end</span>
0978     
0979     <span class="comment">% store the ICA decomposition in the state</span>
0980     state = struct(<span class="string">'icasphere'</span>,{signal.icasphere}, <span class="string">'icaweights'</span>,{signal.icaweights}, <span class="string">'icawinv'</span>,{signal.icawinv}, <span class="string">'icachansind'</span>,{signal.icachansind},<span class="string">'root_chanlocs'</span>,{root_chanlocs});
0981     <span class="keyword">if</span> isfield(signal.etc,<span class="string">'amica'</span>)
0982         state.amica = signal.etc.amica; <span class="keyword">end</span>
0983 <span class="keyword">end</span>
0984 
0985 
0986 <span class="comment">% keep track of the last ICA decomposition for inspection</span>
0987 <span class="keyword">global</span> tracking; tracking.inspection.ica = state;
0988 
0989 <span class="keyword">if</span> do_calcact
0990     <span class="comment">% just populate icaact</span>
0991     signal.icaact = (signal.icaweights*signal.icasphere)*signal.data(signal.icachansind,:); <span class="keyword">end</span>
0992 
0993 <span class="keyword">if</span> do_transform
0994     <span class="comment">% transform the data itself, if necessary</span>
0995     <span class="keyword">if</span> isfield(signal.etc,<span class="string">'amica'</span>) &amp;&amp; size(signal.etc.amica.W,3) &gt; 1
0996         warn_once(<span class="string">'Note: The signal will only be transformed according to the 1st amica model.'</span>); <span class="keyword">end</span>
0997     signal.data = (signal.icaweights*signal.icasphere)*signal.data(signal.icachansind,:);
0998     <span class="keyword">if</span> retain_labels &amp;&amp; nnz(signal.icachansind) == size(signal.data,1)
0999         signal.chanlocs = signal.chanlocs(signal.icachansind);
1000     <span class="keyword">else</span>
1001         signal.chanlocs = struct(<span class="string">'labels'</span>,cellfun(@num2str,num2cell(1:length(signal.icachansind),1),<span class="string">'UniformOutput'</span>,false)); 
1002     <span class="keyword">end</span>
1003     signal.nbchan = size(signal.data,1);
1004     <span class="keyword">if</span> clear_after_trans
1005         signal.icaweights = [];
1006         signal.icawinv = [];
1007         signal.icasphere = [];
1008     <span class="keyword">end</span>
1009 <span class="keyword">end</span>
1010 
1011 <span class="comment">% remember which cleaning level was used</span>
1012 <span class="keyword">try</span>
1013     signal.etc.clean_settings = data_cleaning;
1014 <span class="keyword">catch</span>
1015 <span class="keyword">end</span>
1016 
1017 exp_endfun;
1018 
1019 
1020 <span class="comment">% schedule an AMICA run on an Sun Grid Engine cluster...</span>
1021 <a name="_sub1" href="#_subfunctions" class="code">function [job,result,t0,iter_times,maxiters,lastlines,job_started,early_finish] = schedule_amica(X,scheduler,amica_version,logfile,varargin)</a>
1022 
1023 <span class="comment">% schedule the job, get console output</span>
1024 <span class="keyword">switch</span> amica_version
1025     <span class="keyword">case</span> <span class="string">'devel'</span>
1026         [conout,dummy] = evalc(<span class="string">'runamica10(X,[],size(X,1),size(X,2), varargin{:})'</span>); <span class="comment">%#ok&lt;NASGU&gt;</span>
1027     <span class="keyword">case</span> <span class="string">'stable'</span>
1028         [conout,dummy] = evalc(<span class="string">'runamica(X,[],size(X,1),size(X,2), varargin{:})'</span>); <span class="comment">%#ok&lt;NASGU&gt;</span>
1029     <span class="keyword">case</span> {<span class="string">'stable11'</span>,<span class="string">'stable12'</span>}
1030         <span class="comment">% resolve the queue auto-detection</span>
1031         args = hlp_varargin2struct(varargin);
1032         <span class="keyword">if</span> iscell(args.use_queue)
1033             startwait = now;
1034             <span class="keyword">while</span> true
1035                 fprintf(<span class="string">'Scanning available queues...'</span>);
1036                 [status,info] = system([<span class="string">'ssh '</span> scheduler <span class="string">' -x &quot;qstat -g c&quot;'</span>]); <span class="comment">%#ok&lt;ASGLU&gt;</span>
1037                 lines = hlp_split(info,sprintf(<span class="string">'\n'</span>));
1038                 keys = hlp_split(lines{1},<span class="string">' '</span>);
1039                 availrow = find(strcmpi(keys,<span class="string">'avail'</span>))-1;
1040                 lines = lines(3:end);
1041                 qavail = [];
1042                 qname = {};
1043                 qdata = {};
1044                 <span class="keyword">for</span> l=1:length(lines)
1045                     line = lines{l};
1046                     vals = hlp_split(line,<span class="string">' '</span>);
1047                     qname{l} = vals{1};
1048                     qavail(l) = str2num(vals{availrow});
1049                     qdata{l} = [vals{1} <span class="string">':'</span> vals{availrow}];
1050                 <span class="keyword">end</span>
1051                 <span class="comment">% optionally backtrack to a 50% smaller queue</span>
1052                 <span class="keyword">if</span> ~isempty(qavail) &amp;&amp; ~any(qavail&gt;=args.numprocs) &amp;&amp; any(qavail&gt;=args.numprocs/2)
1053                     args.numprocs = args.numprocs/2;
1054                     retain = qavail&gt;=args.numprocs;
1055                     qdata = qdata(retain);
1056                     qname = qname(retain);
1057                     qavail = qavail(retain);
1058                 <span class="keyword">end</span>
1059                 <span class="comment">% our options</span>
1060                 options = intersect(args.use_queue,qdata);
1061                 <span class="keyword">if</span> isempty(options)
1062                     enough = find(qavail&gt;=32);
1063                     <span class="keyword">if</span> (now - startwait) &gt; 6*3600 &amp;&amp; ~isempty(enough)
1064                         <span class="comment">% waited for more than a few hours</span>
1065                         newargs = args;
1066                         newargs.use_queue = qname{enough(1)};
1067                         varargin = hlp_struct2varargin(newargs);
1068                         <span class="keyword">if</span> newargs.numprocs == 0
1069                             newargs.numprocs = qavail; <span class="keyword">end</span>
1070                         fprintf(<span class="string">'patience exhausted. Using queue %s (%i processors).\n'</span>,newargs.use_queue,newargs.numprocs);
1071                         <span class="keyword">break</span>;
1072                     <span class="keyword">else</span>
1073                         fprintf(<span class="string">'no available queue found; waiting...\n'</span>);
1074                         <span class="comment">% wait for 10 minutes...</span>
1075                         pause(10*60);
1076                     <span class="keyword">end</span>
1077                 <span class="keyword">else</span>
1078                     <span class="comment">% pick a random one</span>
1079                     pick = options{1+floor(rand*length(options)-eps)};
1080                     parts = hlp_split(pick,<span class="string">':'</span>);
1081                     <span class="comment">% rebuild varargin</span>
1082                     newargs = args;
1083                     newargs.use_queue = parts{1};
1084                     <span class="keyword">if</span> newargs.numprocs == 0
1085                         newargs.numprocs = qavail; <span class="keyword">end</span>
1086                     varargin = hlp_struct2varargin(newargs);
1087                     fprintf(<span class="string">'using queue %s (%i processors).\n'</span>,newargs.use_queue,newargs.numprocs);
1088                     <span class="keyword">break</span>;
1089                 <span class="keyword">end</span>
1090             <span class="keyword">end</span>
1091         <span class="keyword">end</span>
1092         quicklog(logfile,<span class="string">'=== new attempt/%s: [%i x %i]; numprocs=%i; num_models=%i; outdir=%s'</span>,amica_version,size(X,1),size(X,2),newargs.numprocs,newargs.num_models, newargs.outdir);
1093         <span class="keyword">if</span> strcmp(amica_version,<span class="string">'stable11'</span>)
1094             [conout,dummy] = evalc(<span class="string">'runamica11(X,args.outdir,varargin{:})'</span>); <span class="comment">%#ok&lt;NASGU&gt;</span>
1095         <span class="keyword">else</span>
1096             [conout,dummy] = evalc(<span class="string">'runamica12(X,args.outdir,varargin{:})'</span>); <span class="comment">%#ok&lt;NASGU&gt;</span>
1097         <span class="keyword">end</span>
1098 <span class="keyword">end</span>
1099 
1100 <span class="keyword">try</span>
1101     <span class="comment">% take apart the console output of AMICA to find the qsub id....</span>
1102     lines = hlp_split(conout,10);
1103     id = [];
1104     <span class="keyword">for</span> l = 1:length(lines)
1105         <span class="keyword">if</span> ~isempty(strfind(lines{l},<span class="string">'qsub id ='</span>))
1106             parts = hlp_split(lines{l},<span class="string">'='</span>);
1107             id = strtrim(parts{2});
1108             <span class="keyword">if</span> isempty(id)
1109                 error(<span class="string">'Amica could not submit a job to the queue. Please check whether you are on a computer from which you can submit to that queue.'</span>); <span class="keyword">end</span>
1110             id = str2num(id);
1111             <span class="keyword">try</span>
1112                 disp([<span class="string">'current qsub id: '</span> num2str(id)]);
1113             <span class="keyword">catch</span>,<span class="keyword">end</span>
1114             <span class="keyword">break</span>;
1115         <span class="keyword">end</span>
1116     <span class="keyword">end</span>
1117     <span class="keyword">if</span> ~id
1118         error(<span class="string">'didn''t find the qsub id...'</span>); <span class="keyword">end</span>
1119     <span class="comment">% get the job's outdir</span>
1120     args = hlp_varargin2struct(varargin);
1121     clean_function = @()<a href="#_sub3" class="code" title="subfunction delete_job(id,scheduler,outdir)">delete_job</a>(id,scheduler,args.outdir);
1122     job = {id, onCleanup(clean_function)};
1123 <span class="keyword">catch</span>
1124     disp(<span class="string">'couldn''t identify job id, jobs will not be auto-deleted.'</span>);
1125     job = [];
1126 <span class="keyword">end</span>
1127 result = [];
1128 <span class="comment">% also set a few other things that are associated with a new amica run</span>
1129 t0 = tic;
1130 iter_times = [];
1131 maxiters = 0;
1132 lastlines = 0;
1133 job_started = false;
1134 early_finish = false;
1135 
1136 
1137 
1138 <span class="comment">% native MATLAB implementation of AMICA</span>
1139 <a name="_sub2" href="#_subfunctions" class="code">function r = amica_native(pre,variant)</a>
1140 <span class="keyword">if</span> ~isfield(variant,<span class="string">'do_mean'</span>)
1141     variant.do_mean = 1; <span class="keyword">end</span>
1142 <span class="keyword">if</span> ~isfield(variant,<span class="string">'do_sphere'</span>)
1143     variant.do_sphere = 1; <span class="keyword">end</span>
1144 [r.W r.A r.c r.LL r.LLt r.mod_prob] = amica10(pre.data, variant.num_models, variant.num_mix_comps, variant.max_iter, variant.do_mean|variant.do_sphere, variant.do_newton);
1145 <span class="comment">% recompute some missing parameters</span>
1146 r.S = eye(size(pre.data,1));
1147 r.v = zeros(size(r.LLt));
1148 <span class="keyword">for</span> m = 1:size(r.v,1)
1149     r.v(m,:) = 1./sum(exp(bsxfun(@minus,r.LLt,r.LLt(m,:))),1); <span class="keyword">end</span>
1150 
1151 
1152 
1153 <span class="comment">% delete a running (or possibly completed) amica job</span>
1154 <a name="_sub3" href="#_subfunctions" class="code">function delete_job(id,scheduler,outdir)</a>
1155 <span class="comment">% first delete the job from qsub</span>
1156 system([<span class="string">'ssh '</span> scheduler <span class="string">' qdel '</span> num2str(id)]);
1157 <span class="comment">% try to clean up the out.txt file, if the job did not get done...</span>
1158 job_done = false;
1159 file_exists = false;
1160 <span class="keyword">try</span>
1161     t = fopen([outdir filesep <span class="string">'out.txt'</span>]);
1162     file_exists = (t ~= -1);
1163     <span class="keyword">if</span> file_exists
1164         <span class="keyword">while</span> 1
1165             line = fgetl(t);
1166             <span class="keyword">if</span> ~ischar(line)
1167                 <span class="keyword">break</span>; <span class="keyword">end</span>
1168             <span class="keyword">if</span> ~isempty(strfind(line,<span class="string">'done.'</span>))
1169                 job_done = true;
1170                 <span class="keyword">break</span>;
1171             <span class="keyword">end</span>
1172         <span class="keyword">end</span>
1173         fclose(t);
1174     <span class="keyword">end</span>
1175 <span class="keyword">catch</span>
1176     <span class="keyword">try</span>
1177         fclose(t);
1178     <span class="keyword">catch</span>,<span class="keyword">end</span>
1179 <span class="keyword">end</span>
1180 
1181 <span class="keyword">if</span> ~job_done &amp;&amp; file_exists
1182     <span class="keyword">try</span>
1183         <span class="keyword">if</span> exist([outdir filesep <span class="string">'out.txt'</span>],<span class="string">'file'</span>)
1184             delete([outdir filesep <span class="string">'out.txt'</span>]); <span class="keyword">end</span>
1185         disp(<span class="string">'Deleted out.txt file.'</span>);
1186     <span class="keyword">catch</span>
1187         disp(<span class="string">'Could not delete out.txt file.'</span>);
1188     <span class="keyword">end</span>
1189 <span class="keyword">end</span></pre></div>

<hr><address>Generated on Wed 19-Aug-2015 18:06:23 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>