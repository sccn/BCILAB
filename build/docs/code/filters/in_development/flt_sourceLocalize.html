<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of flt_sourceLocalize</title>
  <meta name="keywords" content="flt_sourceLocalize">
  <meta name="description" content="Localize sources for a given head model.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="#">code</a> &gt; <a href="../index.html">filters</a> &gt; <a href="index.html">in_development</a> &gt; flt_sourceLocalize.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for code/filters/in_development&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>flt_sourceLocalize

</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>Localize sources for a given head model.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [signal, state] = flt_sourceLocalize(varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Localize sources for a given head model.
 Estimated sources and inverse operator will be stored in 
 signal.CSD and signal.invOperator
 
 Author: Tim Mullen, Jan 2013, SCCN/INC/UCSD
         Alejandro Ojeda, Jan 2013, SCCN/INC/UCSD
         Christian Kothe, Jan 2013, SCCN/INC/UCSD</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">

<li><a href="flt_beamforming.html" class="code" title="function [signal, state] = flt_beamforming(varargin)">flt_beamforming</a>	Return the current source density for a given head model and data using</li>
<li><a href="flt_dynamicloreta.html" class="code" title="function [signal, state] = flt_dynamicloreta(varargin)">flt_dynamicloreta</a>	Return the current source density for a given head model and data using</li>
<li><a href="flt_evidence_approx_tikhonov_reg.html" class="code" title="function [signal, state] = flt_evidence_approx_tikhonov_reg(varargin)">flt_evidence_approx_tikhonov_reg</a>	Return the current source density for a given head model and data using</li>
<li><a href="flt_loreta.html" class="code" title="function [signal, state] = flt_loreta(varargin)">flt_loreta</a>	Return the current source density for a given head model and data using</li>
<li><a href="flt_vbloreta.html" class="code" title="function [signal, state] = flt_vbloreta(varargin)">flt_vbloreta</a>	Return the current source density for a given head model and data using</li>
</ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">

</ul>
<!-- crossreference -->


<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">

<li><a href="#_sub1" class="code">function state = build_state(hmObj,channels,sourceAtlasLabels,roiAtlasLabels,roiVertices,roiVerticesLabels,makeDipfitStruct,verb,chanlocs,combineROIs,combineMode,usecar,normalCSDWeight,leadfieldOrientation)</a></li>
</ul>




<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [signal, state] = flt_sourceLocalize(varargin)</a>
0002 <span class="comment">% Localize sources for a given head model.</span>
0003 <span class="comment">% Estimated sources and inverse operator will be stored in</span>
0004 <span class="comment">% signal.CSD and signal.invOperator</span>
0005 <span class="comment">%</span>
0006 <span class="comment">% Author: Tim Mullen, Jan 2013, SCCN/INC/UCSD</span>
0007 <span class="comment">%         Alejandro Ojeda, Jan 2013, SCCN/INC/UCSD</span>
0008 <span class="comment">%         Christian Kothe, Jan 2013, SCCN/INC/UCSD</span>
0009 
0010 <span class="comment">% FIXME: Need to add a for loop over the calls to Loreta (or add it in the</span>
0011 <span class="comment">% flt_loreta function) which loops over sub-partitions of the data block,</span>
0012 <span class="comment">% estimating CSD for each partition (i.e. assuming local stationarity of</span>
0013 <span class="comment">% the inverse operator within each partition). The invOperator results are</span>
0014 <span class="comment">% stored in a 3D array and the mean invOperator is then returned in state</span>
0015 <span class="comment">% obj as well as in signal obj.</span>
0016 <span class="comment">% FIXME: Implement option to only update inverse operatior infrequently,</span>
0017 <span class="comment">% otherwise using the inv op stored in state object (i.e. mean over last</span>
0018 <span class="comment">% block).</span>
0019 
0020 <span class="keyword">if</span> ~exp_beginfun(<span class="string">'filter'</span>), <span class="keyword">return</span>; <span class="keyword">end</span>
0021 
0022 declare_properties(<span class="string">'name'</span>,<span class="string">'SourceLocalization'</span>, <span class="string">'experimental'</span>,true, <span class="string">'follows'</span>,{<span class="string">'flt_ica'</span>,<span class="string">'flt_fir'</span>,<span class="string">'flt_iir'</span>}, <span class="string">'cannot_precede'</span>,{<span class="string">'flt_clean_settings'</span>},<span class="string">'independent_channels'</span>,false, <span class="string">'independent_trials'</span>,false);
0023 
0024 headmodel_default = <span class="string">'resources:/headmodels/standard-Colin27-385ch.mat'</span>;
0025 
0026 <span class="comment">% try to get ROI names supported by head model (for use in arg definition)</span>
0027 ROINames = {};
0028 <span class="keyword">if</span> ~onl_isonline
0029     hmObj = arg_extract(varargin,{<span class="string">'hmObj'</span>,<span class="string">'HeadModelObject'</span>},[],headmodel_default);
0030     <span class="keyword">if</span> isstruct(hmObj) || (ischar(hmObj) &amp;&amp; ~isempty(hmObj))
0031         hmObj = hlp_validateHeadModelObject(hmObj);
0032         <span class="keyword">if</span> ~isempty(hmObj)
0033             <span class="comment">% get the unique ROI names</span>
0034             [tmp, idx] = unique(hmObj.atlas.label); <span class="comment">%#ok&lt;ASGLU&gt;</span>
0035             ROINames = hmObj.atlas.label(sort(idx))';
0036         <span class="keyword">end</span>
0037     <span class="keyword">end</span>
0038 <span class="keyword">end</span>
0039 
0040 arg_define(varargin, <span class="keyword">...</span>
0041     arg_norep({<span class="string">'signal'</span>,<span class="string">'Signal'</span>},[],[],<span class="string">'Signal structure. Must contain .data field with channel data'</span>), <span class="keyword">...</span>
0042     arg({<span class="string">'hmObj'</span>,<span class="string">'HeadModelObject'</span>},headmodel_default,[],<span class="string">'Head model object generated by MOBILAB. Usually a filename, or a cell array of the form {query,file,query,file,...} where a query is a wildcard pattern that, if matching the sourcedata filename, determines that the subsequent file in the list shall be used  See MOBILAB''s headModel class.'</span>,<span class="string">'type'</span>,<span class="string">'expression'</span>), <span class="keyword">...</span>
0043     arg({<span class="string">'channels'</span>,<span class="string">'Channels'</span>},[],[],<span class="string">'Cell array of channel labels to retain. If empty, all channels in signal.chanlocs.labels will be used. Channels must be a subset of hmObj.getChannelLabels()'</span>,<span class="string">'type'</span>,<span class="string">'cellstr'</span>,<span class="string">'shape'</span>,<span class="string">'row'</span>), <span class="keyword">...</span>
0044     arg_subswitch({<span class="string">'invMethod'</span>,<span class="string">'InverseMethod'</span>},{<span class="string">'LORETA'</span>}, <span class="keyword">...</span>
0045     [{<span class="keyword">...</span>
0046       <span class="string">'LORETA'</span>, @<a href="flt_loreta.html" class="code" title="function [signal, state] = flt_loreta(varargin)">flt_loreta</a>, <span class="keyword">...</span>
0047       <span class="string">'Evidence Approximation'</span>, @<a href="flt_evidence_approx_tikhonov_reg.html" class="code" title="function [signal, state] = flt_evidence_approx_tikhonov_reg(varargin)">flt_evidence_approx_tikhonov_reg</a>, <span class="keyword">...</span>
0048       <span class="string">'Variational LORETA'</span>, @<a href="flt_vbloreta.html" class="code" title="function [signal, state] = flt_vbloreta(varargin)">flt_vbloreta</a>, <span class="keyword">...</span>
0049       <span class="string">'Beamforming'</span>, @<a href="flt_beamforming.html" class="code" title="function [signal, state] = flt_beamforming(varargin)">flt_beamforming</a>}, <span class="keyword">...</span>
0050       quickif(exist(<span class="string">'flt_champagne'</span>,<span class="string">'file'</span>),{<span class="string">'Champagne'</span>,@flt_champagne},{})], <span class="keyword">...</span>
0051      <span class="string">'Source Localization Algorithm'</span>), <span class="keyword">...</span>
0052     arg({<span class="string">'sourceAtlasLabels'</span>,<span class="string">'SourceAtlasLabels'</span>,<span class="string">'SourceAtlasROI'</span>},ROINames,ROINames,<span class="string">'Source regions of interest (atlas labels). This is a cell array of strings corresponding to a subset of the labels stored in hmObj.atlas.label. Current source density will be estimated only for these ROIs.'</span>,<span class="string">'type'</span>,<span class="string">'logical'</span>,<span class="string">'rangecheck'</span>,true), <span class="keyword">...</span>
0053     arg({<span class="string">'colRoiCsd'</span>,<span class="string">'CollapseRoiCsd'</span>},<span class="string">'sum'</span>,{<span class="string">'none'</span>,<span class="string">'mean'</span>,<span class="string">'sum'</span>,<span class="string">'max'</span>,<span class="string">'maxmag'</span>,<span class="string">'median'</span>},<span class="string">'Method for computing ROI CSD. Return the (mean, integral, max) current source density within each ROI. signal.srcpot matrix will be reduced to [num_rois x num_samples].'</span>), <span class="keyword">...</span>
0054     arg({<span class="string">'keepFullCsd'</span>,<span class="string">'KeepFullCsd'</span>},true,[],<span class="string">'Keep a copy of the csd for each vertex. This is stored in srcpot_all'</span>), <span class="keyword">...</span>
0055     arg({<span class="string">'roiAtlasLabels'</span>,<span class="string">'ROIAtlasLabels'</span>,<span class="string">'AtlasROI'</span>,<span class="string">'ROI'</span>},ROINames,ROINames,<span class="string">'Regions of interest atlas labels. This is a cell array of strings corresponding to a subset of the labels stored in hmObj.atlas.label. If CollapseRoiCsd is set, current source density will be integrated over these ROIs. If empty the all ROIs in SourceAtlasLabels are selected.'</span>,<span class="string">'type'</span>,<span class="string">'logical'</span>,<span class="string">'rangecheck'</span>,true), <span class="keyword">...</span>
0056     arg({<span class="string">'combineROIs'</span>,<span class="string">'CombineROI'</span>},[],[],<span class="string">'Combine ROIs in ROIAtlasLabels. This is a cell array of (name, value) pairs. The name entry is a string denoting the name of a new ROI. The value part is a cell array of strings indicating which of the ROIs in ROIAtlasLabels should be combined to form a new ROI. Any ROIs that were merged into a new ROI are removed from the original set of ROIs. To preserve an ROI that was merged into a new ROI, specify a new ROI containing only this ROI. All new ROIs are then appended to the list of existing (unmerged) ROIs in ROIAtlasLabels. If CollapseRoiCsd is set, current source density will be integrated over all ROIs.'</span>,<span class="string">'type'</span>,<span class="string">'expression'</span>,<span class="string">'shape'</span>,<span class="string">'row'</span>), <span class="keyword">...</span>
0057     arg({<span class="string">'combineMode'</span>,<span class="string">'CombineMode'</span>},<span class="string">'merge'</span>,{<span class="string">'replace'</span>,<span class="string">'append'</span>,<span class="string">'merge'</span>},<span class="string">'Mode for combining MetaROIs with original ROIs'</span>), <span class="keyword">...</span>
0058     arg_nogui({<span class="string">'appendROI'</span>,<span class="string">'AppendROI'</span>},false,[],<span class="string">'Append superROIs or replace'</span>), <span class="keyword">...</span>
0059     arg({<span class="string">'reference'</span>,<span class="string">'Reference'</span>},[],[],<span class="string">'Reference scheme. This is a cell array of channel labels defining the reference. If more than one channel, average reference is assumed'</span>,<span class="string">'type'</span>,<span class="string">'cellstr'</span>,<span class="string">'shape'</span>,<span class="string">'row'</span>), <span class="keyword">...</span>
0060     arg_nogui({<span class="string">'roiVertices'</span>,<span class="string">'ROIVertices'</span>},[],[],<span class="string">'Regions of interest (vertices). This is supplementary to the ''RegionsOfInterest'' option. ''roiVertices'' is a cell array where each cell contains the indices of all vertices within a region of interest. The vertex indices correspond to respective columns of the lead field matrix. These ROIs will be added to the set of ROIs defined in the ''RegionsOfInterest'' option.'</span>), <span class="keyword">...</span>
0061     arg_nogui({<span class="string">'roiVerticesLabels'</span>,<span class="string">'ROIVerticesLabels'</span>},[],[],<span class="string">'Labels for the supplementary ROIs. This is a cell array of same dimension as ''roiVertices'' with labels for each ROI'</span>,<span class="string">'type'</span>,<span class="string">'cellstr'</span>), <span class="keyword">...</span>
0062     arg({<span class="string">'normalCSDWeight'</span>,<span class="string">'NormalCSDWeight'</span>},0.7,[],<span class="string">'Weight of normal direction in CSD. When calculating the CSD at a given vertex from a lead-field matrix that is not restricted to the surface normal this is the weighting of the current normal to the surface (and tangential current will be weighted by 1 minus this value).'</span>,<span class="string">'guru'</span>,true),<span class="keyword">...</span>
0063     arg({<span class="string">'leadfieldOrientation'</span>,<span class="string">'LeadfieldOrientation'</span>},<span class="string">'axisparallel'</span>,{<span class="string">'axisparallel'</span>,<span class="string">'tangentspace'</span>},<span class="string">'Orientation of local leadfield components. This is for a given source vertex (if orientations are flexible). If axisparallel, the projections will point in X/Y/Z directions, if tangentspace, the projections will point in surface normal, tangent and binormal directions.'</span>,<span class="string">'guru'</span>,true),<span class="keyword">...</span>
0064     arg({<span class="string">'makeDipfitStruct'</span>,<span class="string">'MakeDipfitStruct'</span>},true,[],<span class="string">'Make dipfit structure. If selected, a dipfit structure will be created in signal.dipfit containing the locations (.posxyz) and moments (.mom) of each dipole or center of mass of ROI.'</span>), <span class="keyword">...</span><span class="comment"> </span>
0065     arg({<span class="string">'do_transform'</span>,<span class="string">'TransformData'</span>,<span class="string">'transform'</span>},false,[],<span class="string">'Transform the data rather than annotate. By default, source reconstructions are added as annotations (.srcpot) to the data set.'</span>),<span class="keyword">...</span>
0066     arg({<span class="string">'usecar'</span>,<span class="string">'CAR'</span>},true,[],<span class="string">'Rereference to common average. This should always be enabled, unless you are really sure about it'</span>), <span class="keyword">...</span>
0067     arg({<span class="string">'verb'</span>,<span class="string">'Verbosity'</span>},0,[],<span class="string">'Verbosity level.'</span>,<span class="string">'typecheck'</span>,false), <span class="keyword">...</span>
0068     arg_nogui({<span class="string">'state'</span>,<span class="string">'State'</span>}));
0069 
0070 
0071 <span class="keyword">if</span> isempty(roiAtlasLabels) <span class="comment">%#ok</span>
0072     roiAtlasLabels = ROINames;
0073 <span class="keyword">end</span>
0074 <span class="keyword">if</span> isempty(sourceAtlasLabels) <span class="comment">%#ok</span>
0075     sourceAtlasLabels = ROINames;
0076 <span class="keyword">end</span>
0077 
0078 
0079 <span class="comment">% Intialization block</span>
0080 <span class="comment">% -------------------------------------------------------------------------</span>
0081 <span class="keyword">if</span> isempty(state)
0082     <span class="comment">% || (isfield(state,'roiAtlasLabels') &amp;&amp; ~isequal(state.roiAtlasLabels,roiAtlasLabels))</span>
0083     
0084     <span class="keyword">if</span> iscellstr(hmObj)    
0085         <span class="comment">% per-subject headmodels given as a cell array of query-model pairsl resolve which one to use</span>
0086         loader = utl_find_filter(signal,<span class="string">'io_loadset'</span>);
0087         filename = loader.parts{1};
0088         <span class="keyword">for</span> k=1:2:length(hmObj)
0089             pattern = regexptranslate(<span class="string">'wildcard'</span>,hmObj{k});
0090             <span class="keyword">if</span> regexp(filename,pattern)
0091                 hmObj = hmObj{k+1};
0092                 <span class="keyword">break</span>;
0093             <span class="keyword">end</span>
0094         <span class="keyword">end</span>
0095         <span class="keyword">if</span> iscellstr(hmObj)
0096             error(<span class="string">'No matching headmodel found for the given data filename: %s (patterns: %s)'</span>,filename,hlp_tostring(hmObj(1:2:end))); <span class="keyword">end</span>
0097     <span class="keyword">end</span>
0098     
0099     <span class="comment">% Either we are initializing our adaptive estimator or user-specified</span>
0100     <span class="comment">% ROIs have changed.</span>
0101     state = hlp_microcache(<span class="string">'sourcespace'</span>,@<a href="#_sub1" class="code" title="subfunction state = build_state(hmObj,channels,sourceAtlasLabels,roiAtlasLabels,roiVertices,roiVerticesLabels,makeDipfitStruct,verb,chanlocs,combineROIs,combineMode,usecar,normalCSDWeight,leadfieldOrientation)">build_state</a>,hmObj,channels,sourceAtlasLabels,roiAtlasLabels,roiVertices,roiVerticesLabels,makeDipfitStruct,verb,signal.chanlocs,combineROIs,combineMode,usecar,normalCSDWeight,leadfieldOrientation);
0102 <span class="keyword">end</span>
0103 
0104 <span class="comment">% Estimate Current Source Density</span>
0105 <span class="comment">% -------------------------------------------------------------------------</span>
0106 
0107 <span class="comment">% Current source density is returned in signal.srcpot</span>
0108 <span class="comment">% [num_vertices x num_samples]</span>
0109 <span class="comment">% Inverse operator is returned in signal.srcweights</span>
0110 <span class="comment">% [num_vertices x num_channels]</span>
0111 
0112 <span class="keyword">if</span> usecar
0113     <span class="comment">% apply common average reference</span>
0114     signal.data = bsxfun(@minus,signal.data,mean(signal.data));
0115 <span class="keyword">end</span>
0116 <span class="keyword">switch</span> lower(invMethod.arg_selection)
0117     <span class="keyword">case</span> <span class="string">'loreta'</span>
0118         [signal, state.solverState] = hlp_scope({<span class="string">'disable_expressions'</span>,true}, <span class="keyword">...</span>
0119                                     @<a href="flt_loreta.html" class="code" title="function [signal, state] = flt_loreta(varargin)">flt_loreta</a>,                    <span class="keyword">...</span>
0120                                     <span class="string">'signal'</span>,signal,                <span class="keyword">...</span>
0121                                     invMethod,                      <span class="keyword">...</span>
0122                                     <span class="string">'state'</span>,state.solverState,      <span class="keyword">...</span>
0123                                     <span class="string">'K'</span>,state.leadFieldMatrix,      <span class="keyword">...</span>
0124                                     <span class="string">'L'</span>,state.laplacianOperator,    <span class="keyword">...</span>
0125                                     <span class="string">'verb'</span>,max(0,verb-1),<span class="string">'arg_direct'</span>,true);
0126         signal.srcweights = state.solverState.srcweights;
0127     <span class="keyword">case</span> <span class="string">'evidence approximation'</span>
0128         [signal, state.solverState] = hlp_scope({<span class="string">'disable_expressions'</span>,true}, <span class="keyword">...</span>
0129                                     @<a href="flt_evidence_approx_tikhonov_reg.html" class="code" title="function [signal, state] = flt_evidence_approx_tikhonov_reg(varargin)">flt_evidence_approx_tikhonov_reg</a>,                  <span class="keyword">...</span>
0130                                     <span class="string">'signal'</span>,signal,                <span class="keyword">...</span>
0131                                     invMethod,                      <span class="keyword">...</span>
0132                                     <span class="string">'state'</span>,state.solverState,      <span class="keyword">...</span>
0133                                     <span class="string">'K'</span>,state.leadFieldMatrix,      <span class="keyword">...</span>
0134                                     <span class="string">'L'</span>,state.laplacianOperator,    <span class="keyword">...</span>
0135                                     <span class="string">'verb'</span>,verb,<span class="string">'arg_direct'</span>,true);
0136         signal.srcweights = state.solverState.srcweights;
0137     <span class="keyword">case</span> <span class="string">'variational loreta'</span>
0138         [signal, state.solverState] = hlp_scope({<span class="string">'disable_expressions'</span>,true}, <span class="keyword">...</span>
0139                                     @<a href="flt_vbloreta.html" class="code" title="function [signal, state] = flt_vbloreta(varargin)">flt_vbloreta</a>,                  <span class="keyword">...</span>
0140                                     <span class="string">'signal'</span>,signal,                <span class="keyword">...</span>
0141                                     invMethod,                      <span class="keyword">...</span>
0142                                     <span class="string">'state'</span>,state.solverState,      <span class="keyword">...</span>
0143                                     <span class="string">'K'</span>,state.leadFieldMatrix,      <span class="keyword">...</span>
0144                                     <span class="string">'L'</span>,state.laplacianOperator,    <span class="keyword">...</span>
0145                                     <span class="string">'verb'</span>,max(0,verb-1),<span class="string">'arg_direct'</span>,true);
0146         signal.srcweights = state.solverState.srcweights;
0147     <span class="keyword">case</span> <span class="string">'dynamic loreta'</span>
0148         [signal, state.solverState] = hlp_scope({<span class="string">'disable_expressions'</span>,true}, <span class="keyword">...</span>
0149                                     @<a href="flt_dynamicloreta.html" class="code" title="function [signal, state] = flt_dynamicloreta(varargin)">flt_dynamicloreta</a>,             <span class="keyword">...</span>
0150                                     <span class="string">'signal'</span>,signal,                <span class="keyword">...</span>
0151                                     invMethod,                      <span class="keyword">...</span>
0152                                     <span class="string">'state'</span>,state.solverState,      <span class="keyword">...</span>
0153                                     <span class="string">'K'</span>,state.leadFieldMatrix,      <span class="keyword">...</span>
0154                                     <span class="string">'L'</span>,state.laplacianOperator,    <span class="keyword">...</span>
0155                                     <span class="string">'verb'</span>,max(0,verb-1),<span class="string">'arg_direct'</span>,true);
0156         signal.srcweights = state.solverState.srcweights;
0157     <span class="keyword">case</span> <span class="string">'beamforming'</span>
0158         [signal, state.solverState] = hlp_scope({<span class="string">'disable_expressions'</span>,true}, <span class="keyword">...</span>
0159                                     @<a href="flt_beamforming.html" class="code" title="function [signal, state] = flt_beamforming(varargin)">flt_beamforming</a>,                  <span class="keyword">...</span>
0160                                     <span class="string">'signal'</span>,signal,                <span class="keyword">...</span><span class="comment">                                    </span>
0161                                     invMethod, <span class="keyword">...</span>
0162                                     <span class="string">'lead_field'</span>, state.leadFieldMatrix, <span class="keyword">...</span>
0163                                     <span class="string">'state'</span>,state.solverState,      <span class="keyword">...</span>
0164                                     <span class="string">'arg_direct'</span>,true);
0165     <span class="keyword">case</span> <span class="string">'champagne'</span>
0166         [signal, state.solverState] = hlp_scope({<span class="string">'disable_expressions'</span>,true}, <span class="keyword">...</span>
0167                                     @flt_champagne,                  <span class="keyword">...</span>
0168                                     <span class="string">'signal'</span>,signal,                <span class="keyword">...</span>
0169                                     invMethod,                      <span class="keyword">...</span>
0170                                     <span class="string">'state'</span>,state.solverState,      <span class="keyword">...</span>
0171                                     <span class="string">'head_file'</span>,struct(<span class="string">'leadfield'</span>,reshape(state.leadFieldMatrix,state.nChannels,state.nVertices,state.orientationDegrees), <span class="keyword">...</span>
0172                                                        <span class="string">'chanlabels'</span>,{{signal.chanlocs.labels}}), <span class="keyword">...</span>
0173                                     <span class="string">'arg_direct'</span>,true);
0174                                 
0175     <span class="keyword">otherwise</span>
0176         error(<span class="string">'flt_sourceLocalize:badInverseMethod'</span>,<span class="string">'Invalid inverse method %s'</span>,invMethod.arg_selection);
0177 <span class="keyword">end</span>
0178 
0179 
0180 <span class="comment">% collapse srcpot from 3d to 1d based on state.srcweightCollapseDoFWeights</span>
0181 <span class="keyword">if</span> state.orientationDegrees == 3
0182     siz = size(signal.srcpot);
0183     signal.srcpot = reshape(sum(reshape(bsxfun(@times,signal.srcpot,state.srcweightCollapseDoFWeights),[3 siz(1)/3 siz(2:end)]),1),[siz(1)/3 siz(2:end)]);
0184 <span class="keyword">end</span>
0185 
0186 <span class="comment">% Collapse CSD within each ROI</span>
0187 <span class="comment">% -------------------------------------------------------------------------</span>
0188 <span class="comment">% FIXME: We may wish to replace avg with the surface integral over the ROI</span>
0189 <span class="comment">% We can use numerical double integration i.e. quad2d() or more crudely:</span>
0190 <span class="comment">% sum(signal.CSD(x,:)) * dx * dy;</span>
0191 <span class="comment">% where dx, dy are the voxel x,y dimensions.</span>
0192 <span class="comment">% If the csd is not constrained to the surface of a mesh, then we need to</span>
0193 <span class="comment">% use triple integration i.e. triplequad(). Or</span>
0194 <span class="comment">% sum(signal.CSD(x,:)) * dx * dy * dz</span>
0195 
0196 <span class="keyword">if</span> ~strcmp(colRoiCsd,<span class="string">'none'</span>) &amp;&amp; ~isempty(signal.srcpot)
0197     <span class="keyword">if</span> verb
0198         fprintf(<span class="string">'Computing %s CSD for each ROI \n'</span>, colRoiCsd); 
0199     <span class="keyword">end</span>
0200     
0201     <span class="keyword">if</span> keepFullCsd
0202         <span class="comment">% store backup with all vertices</span>
0203         <span class="comment">% also, register this as a time-series field</span>
0204         signal = utl_register_field(signal,<span class="string">'timeseries'</span>,<span class="string">'srcpot_all'</span>,signal.srcpot);
0205         signal.srcweights_all = signal.srcweights;
0206     <span class="keyword">end</span>
0207         
0208     <span class="comment">% collapse current density</span>
0209     signal.srcpot = hlp_colsrc(signal.srcpot,state.roiVerticesReduced,colRoiCsd);
0210     <span class="comment">% collapse weights (note: if weights are time-varying, then whatever snapshot this is isn't</span>
0211     <span class="comment">% going to be too useful)</span>
0212     <span class="keyword">if</span> isfield(signal,<span class="string">'srcweights'</span>)
0213         signal.srcweights = hlp_colsrc(signal.srcweights,state.roiVerticesReduced,colRoiCsd); <span class="keyword">end</span>
0214 <span class="keyword">else</span>
0215     signal.srcpot_all       = [];
0216     signal.srcweights_all   = [];
0217 <span class="keyword">end</span>
0218 
0219 
0220 <span class="comment">% Store additional outputs in signal</span>
0221 <span class="comment">% -------------------------------------------------------------------------</span>
0222 <span class="keyword">if</span> makeDipfitStruct
0223     signal.dipfit   = state.dipfit;
0224 <span class="keyword">end</span>
0225 signal.roiLabels          = state.roiLabels;
0226 signal.roiVertices        = state.roiVertices;
0227 signal.roiVerticesReduced = state.roiVerticesReduced;
0228 signal.rmIndices          = state.rmIndices;
0229 
0230 <span class="keyword">if</span> do_transform
0231     signal.data = signal.srcpot;
0232     signal.nbchan = size(signal.data,1);
0233     signal.chanlocs = struct(<span class="string">'labels'</span>,cellfun(@num2str,num2cell(1:signal.nbchan,1),<span class="string">'UniformOutput'</span>,false));
0234 <span class="keyword">end</span>
0235 signal.hmObj = hmObj;
0236 signal.leadFieldMatrix = state.leadFieldMatrix;
0237 
0238     
0239 exp_endfun;
0240 
0241 
0242 <a name="_sub1" href="#_subfunctions" class="code">function state = build_state(hmObj,channels,sourceAtlasLabels,roiAtlasLabels,roiVertices,roiVerticesLabels,makeDipfitStruct,verb,chanlocs,combineROIs,combineMode,usecar,normalCSDWeight,leadfieldOrientation)</a>
0243 <span class="comment">% validate the head model and construct the source space</span>
0244 
0245 orilen = length(roiAtlasLabels);
0246 [res ia] = intersect(roiAtlasLabels,sourceAtlasLabels);
0247 roiAtlasLabels = roiAtlasLabels(sort(ia));  <span class="comment">% FIXME: double-check this order</span>
0248 <span class="keyword">if</span> length(roiAtlasLabels)~=orilen
0249     warn_once(<span class="string">'BCILAB:AtlasLabelMismatch'</span>,<span class="string">'Some elements of ROIAtlasLabels were not contained in SourceAtlasLabels. These were removed.'</span>);
0250 <span class="keyword">end</span>
0251 
0252 <span class="comment">% Validate Inputs</span>
0253 hmObj     = hlp_validateHeadModelObject(hmObj);
0254 <span class="keyword">if</span> isempty(hmObj)
0255     error(<span class="string">'HeadModelObject was improperly defined. Exiting'</span>);
0256 <span class="keyword">end</span>
0257 <span class="keyword">if</span> ~isempty(roiVerticesLabels) &amp;&amp; ~isempty(roiVertices) <span class="keyword">...</span>
0258         &amp;&amp; length(roiVertices) ~= length(roiVerticesLabels)
0259     fprintf(<span class="string">'WARNING: The number of ROI labels in ''roiVerticesLabels'' does not match the number of ROIs in ''roiVertices''. Reverting to generic labeling scheme {''ROI1'' ''ROI2'' ... ''ROIN''}.'</span>);
0260     roiVerticesLabels = [];
0261 <span class="keyword">end</span>
0262 
0263 
0264 <span class="keyword">if</span> verb
0265     fprintf(<span class="string">'Initializing source reconstructor \n'</span>);
0266 <span class="keyword">end</span>
0267 
0268 <span class="comment">% Prune lead field matrix and laplacian operator</span>
0269 <span class="comment">% to contain only regions of interest</span>
0270 <span class="comment">% If there are no specific ROIs selected, this will &quot;open&quot; the</span>
0271 <span class="comment">% surface mesh by removing a few vertices</span>
0272 <span class="comment">% (the surface mesh cannot be a closed surface)</span>
0273 <span class="keyword">if</span> verb
0274     fprintf(<span class="string">'Constructing source space \n'</span>);
0275 <span class="keyword">end</span>
0276 
0277 <span class="comment">% remove undesired brain structures</span>
0278 <span class="comment">% note: we assume that the leadFieldMatrix produced by this step is 2d, but</span>
0279 <span class="comment">% contain stacked pages for X, Y and Z dipole components (so that a reshape</span>
0280 <span class="comment">% to [#ch,#vox,3] would yield the correct result.</span>
0281 brainStructsToRemove = setdiff(unique(hmObj.atlas.label),sourceAtlasLabels);
0282 [   reducedSpace,                      <span class="keyword">...</span>
0283     state.leadFieldMatrix,             <span class="keyword">...</span>
0284     state.laplacianOperator            <span class="keyword">...</span>
0285     state.rmIndices                    <span class="keyword">...</span>
0286     ] = getSourceSpace4PEB(hmObj,brainStructsToRemove,roiVertices);
0287 
0288 state.nVertices = size(reducedSpace.vertices,1);
0289 state.nChannels = length(chanlocs);
0290 
0291 <span class="comment">% determine the number of orientation degrees of freedom</span>
0292 <span class="keyword">if</span> size(state.leadFieldMatrix,2) == state.nVertices
0293     state.orientationDegrees = 1;
0294 <span class="keyword">elseif</span> size(state.leadFieldMatrix,2) == 3*state.nVertices
0295     state.orientationDegrees = 3;
0296 <span class="keyword">else</span>
0297     error(<span class="string">'Your lead-field matrix has a # of columns that does not correspond to the # of source vertices.'</span>);
0298 <span class="keyword">end</span>
0299 
0300 <span class="comment">% project leadfield matrix onto tangent space</span>
0301 <span class="keyword">if</span> state.orientationDegrees==3
0302     <span class="comment">% get tangent space at each vertex</span>
0303     <span class="keyword">if</span> isprop(hmObj,<span class="string">'surfNormal'</span>)
0304         state.surfNormals = blk_diag(hmObj.surfNormal,1)';
0305         <span class="comment">% prune removed indices</span>
0306         state.surfNormals(state.rmIndices,:)=[];
0307     <span class="keyword">else</span>
0308         <span class="comment">% FIXME: these data contains NaN's (presumably near deleted triangles)</span>
0309         state.surfNormals = geometricTools.getSurfaceNormals(reducedSpace.vertices,reducedSpace.faces,true);
0310     <span class="keyword">end</span>
0311     state.surfTangents = cross(state.surfNormals,ones(length(state.surfNormals),1)*[1 0 0],2);
0312     state.surfBinormals = cross(state.surfNormals,state.surfTangents,2);    
0313 
0314     <span class="comment">% also calc final projection operator</span>
0315     <span class="keyword">if</span> strcmp(leadfieldOrientation,<span class="string">'axisparallel'</span>)
0316         state.srcweightCollapseDoFWeights = vec((state.surfNormals*normalCSDWeight + (state.surfTangents+state.surfBinormals)*(1-normalCSDWeight))'); <span class="comment">% does assume axis-parallel lead-field</span>
0317     <span class="keyword">elseif</span> strcmp(leadfieldOrientation,<span class="string">'tangentspace'</span>)
0318         state.srcweightCollapseDoFWeights = vec((ones(length(state.surfNormals),1)*[normalCSDWeight (1-normalCSDWeight)/2 (1-normalCSDWeight)/2])');  <span class="comment">% assumes rotated lead-field</span>
0319         <span class="comment">% turn into triplet order</span>
0320         tmp = permute(reshape(state.leadFieldMatrix,state.nChannels,state.nVertices,state.orientationDegrees),[1 3 2]);
0321         <span class="comment">% transpose for recombination</span>
0322         tmp = tmp(:,:)'; siz = size(tmp);
0323         <span class="comment">% recombine into tangent space in pages</span>
0324         new_matrix = permute(cat(3,reshape(sum(reshape(bsxfun(@times,tmp,vec(state.surfNormals')),[3 siz(1)/3 siz(2:end)]),1),[siz(1)/3 siz(2:end)]), <span class="keyword">...</span>
0325             reshape(sum(reshape(bsxfun(@times,tmp,vec(state.surfTangents')),[3 siz(1)/3 siz(2:end)]),1),[siz(1)/3 siz(2:end)]), <span class="keyword">...</span>
0326             reshape(sum(reshape(bsxfun(@times,tmp,vec(state.surfBinormals')),[3 siz(1)/3 siz(2:end)]),1),[siz(1)/3 siz(2:end)])),[2 1 3]);
0327         <span class="comment">% flatten again</span>
0328         state.leadFieldMatrix = new_matrix(:,:);
0329     <span class="keyword">else</span>
0330         error(<span class="string">'Unsupported LeadfieldOrientation specified: %s'</span>,leadfieldOrientation);
0331     <span class="keyword">end</span>
0332 <span class="keyword">end</span>
0333 
0334 <span class="comment">% We also store the indices of the vertices of each ROI (in the full</span>
0335 <span class="comment">% source space) in a cell array. This allows us to obtain dipole</span>
0336 <span class="comment">% centroids for each ROI</span>
0337 <span class="keyword">for</span> k=1:length(roiAtlasLabels)
0338     state.roiVertices{k} = find(indices4Structure(hmObj,roiAtlasLabels{k}))';
0339     <span class="comment">%         [~,state.roiVertices{k}] = removeStructureFromSourceSpace(hmObj,state.brainStructsToRemove{k});</span>
0340 <span class="keyword">end</span>
0341 <span class="comment">% append any additional ROI defined by 'roiVertices' input argument</span>
0342 state.roiVertices = [state.roiVertices roiVertices];
0343 
0344 <span class="comment">% get ROI indices into reduced source space. These are used for</span>
0345 <span class="comment">% integration over current source density (CSD) within each ROI</span>
0346 LFMcols = 1:length(hmObj.atlas.colorTable);
0347 LFMcols(state.rmIndices) = [];
0348 <span class="keyword">for</span> k=1:length(state.roiVertices)
0349     state.roiVerticesReduced{k} = find(ismember(LFMcols,state.roiVertices{k}));
0350 <span class="keyword">end</span>
0351 
0352 
0353 <span class="comment">% set up the labeling for any vertex-index-defined ROIs</span>
0354 <span class="keyword">if</span> isempty(roiVerticesLabels) &amp;&amp; ~isempty(roiVertices)
0355     <span class="comment">% use generic labeling scheme {'ROI1' 'ROI2' ... 'ROIN'}</span>
0356     roiVerticesLabels = cellstr(num2str((1:length(roiVertices))'))';
0357     roiVerticesLabels = cellfun(@(x)[<span class="string">'ROI'</span> x],roiVerticesLabels,<span class="string">'UniformOutput'</span>,false);
0358 <span class="keyword">end</span>
0359 state.roiLabels = [roiAtlasLabels roiVerticesLabels];
0360 
0361 
0362 <span class="comment">% if needed, combine ROIs according to rules in combineROIs</span>
0363 <span class="keyword">if</span> ~isempty(combineROIs)
0364     <span class="keyword">if</span> mod(length(combineROIs),2)
0365         error(<span class="string">'BCILAB:BadNameValuePair'</span>,<span class="string">'CombineROI must be a cell array of name,value pairs'</span>);
0366     <span class="keyword">end</span>
0367     newRoiLabels = combineROIs(1:2:end-1);
0368     roiSubLabels = combineROIs(2:2:end);
0369     numroi = length(newRoiLabels);
0370     newRoiVerticesReduced = cell(1,numroi);
0371     newRoiVertices        = cell(1,numroi);
0372     roiIdxInAtlas  = cell(1,numroi);
0373     <span class="keyword">for</span> k=1:numroi
0374         matchedLabels = ismember(roiSubLabels{k},roiAtlasLabels);
0375         <span class="keyword">if</span> ~all(matchedLabels)
0376             error(<span class="string">'BCILAB:BadROINames'</span>, <span class="keyword">...</span>
0377                   <span class="string">'The following ROIs in ''CombineROIs'' are not in the ROIAtlasLabels list: %s'</span>, <span class="keyword">...</span>
0378                           hlp_tostring(roiSubLabels{k}(~matchedLabels)));
0379         <span class="keyword">end</span>
0380         roiIdxInAtlas{k}  = find(ismember(roiAtlasLabels,roiSubLabels{k}));
0381         A = cell2mat(state.roiVerticesReduced(roiIdxInAtlas{k}));
0382         [tmp, idx] = unique(A);
0383         newRoiVerticesReduced{k} = A(sort(idx));
0384         <span class="comment">% do the same for roiVertices</span>
0385         A = cell2mat(state.roiVertices(roiIdxInAtlas{k}));
0386         [tmp, idx] = unique(A);
0387         newRoiVertices{k} = A(sort(idx));
0388     <span class="keyword">end</span>
0389     
0390     <span class="keyword">switch</span> combineMode
0391         <span class="keyword">case</span> <span class="string">'merge'</span>
0392             <span class="comment">% remove all merged ROIs ...</span>
0393             mergedROI = unique(cell2mat(roiIdxInAtlas));
0394             state.roiVerticesReduced(mergedROI) = [];
0395             state.roiVertices(mergedROI)        = [];
0396             state.roiLabels(mergedROI)          = [];
0397             
0398             <span class="comment">% ... and append the new ROIs</span>
0399             state.roiVerticesReduced = [state.roiVerticesReduced newRoiVerticesReduced];
0400             state.roiVertices        = [state.roiVertices newRoiVertices];
0401             state.roiLabels          = [state.roiLabels newRoiLabels];
0402         <span class="keyword">case</span> <span class="string">'replace'</span>
0403             <span class="comment">% keep only the new rois</span>
0404             state.roiVerticesReduced = newRoiVerticesReduced;
0405             state.roiVertices        = newRoiVertices;
0406             state.roiLabels          = newRoiLabels;
0407         <span class="keyword">case</span> <span class="string">'append'</span>
0408             <span class="comment">% append the new ROIs</span>
0409             state.roiVerticesReduced = [state.roiVerticesReduced newRoiVerticesReduced];
0410             state.roiVertices        = [state.roiVertices newRoiVertices];
0411             state.roiLabels          = [state.roiLabels newRoiLabels];
0412     <span class="keyword">end</span>
0413 <span class="keyword">end</span>
0414 
0415 
0416 <span class="comment">% prune the lead field matrix to contain only desired channels</span>
0417 hmChanlabels  = lower(hmObj.channelLabel);
0418 <span class="keyword">if</span> isempty(channels)
0419     channels = lower({chanlocs.labels});
0420 <span class="keyword">end</span>
0421 
0422 <span class="comment">% use only selected channels that are in the head model</span>
0423 <span class="comment">% chaninds is also an integer permutation vector so that rows of</span>
0424 <span class="comment">% LFM match the ordering of 'channels' variable</span>
0425 [~, ia, ib] = intersect(lower(hmChanlabels),lower(channels),<span class="string">'stable'</span>);
0426 <span class="keyword">if</span> max(ib)&gt;length(ia)
0427     error(<span class="string">'The following channels could not be matched to the headmodel: %s'</span>, <span class="keyword">...</span>
0428           hlp_tostring(channels(ib&gt;length(ia))));
0429 <span class="keyword">end</span>
0430 chaninds = ia; <span class="comment">%ia(ib);</span>
0431 <span class="comment">% if nnz(chaninds)~=length(channels)</span>
0432 <span class="comment">%     error('Some channels could not be matched to the headmodel');</span>
0433 <span class="comment">% end</span>
0434 state.leadFieldMatrix = state.leadFieldMatrix(chaninds,:,:);
0435 
0436 <span class="keyword">if</span> usecar
0437     <span class="comment">% apply common-average rereference</span>
0438     state.leadFieldMatrix = bsxfun(@minus,state.leadFieldMatrix,mean(state.leadFieldMatrix));
0439 <span class="keyword">end</span>
0440 
0441 <span class="comment">% load the original source space (non-reduced)</span>
0442 tmp = load(hmObj.surfaces);
0443 fn  = fieldnames(tmp);
0444 state.sourceSpace = tmp.(fn{1})(end);  <span class="comment">% dim end = cortical surface</span>
0445 
0446 <span class="comment">% make dipfit structure containing centroids (dipfit.model.posxyz) and</span>
0447 <span class="comment">% surface mesh (dipfit.model.surfmesh) for each ROI as well as complete</span>
0448 <span class="comment">% surface mesh (dipfit.surfmesh). We also store the indices of each ROI</span>
0449 <span class="comment">% into the complete surface mesh (dipfit.model.meshVertices)</span>
0450 <span class="keyword">if</span> makeDipfitStruct
0451     state.dipfit = hlp_makeDipfitStruct(state.sourceSpace,state.roiVertices,reducedSpace);
0452 <span class="keyword">end</span>
0453 
0454 <span class="comment">% initialize the state of the solver</span>
0455 state.solverState = [];</pre></div>

<hr><address>Generated on Wed 19-Aug-2015 18:06:23 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>