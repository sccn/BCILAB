<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of set_insert_markers</title>
  <meta name="keywords" content="set_insert_markers">
  <meta name="description" content="Inject runs of markers into specific segments of a continuous data set.">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="#">code</a> &gt; <a href="index.html">dataset_editing</a> &gt; set_insert_markers.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for code/dataset_editing&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>set_insert_markers

</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>Inject runs of markers into specific segments of a continuous data set.</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function newsignal = set_insert_markers(varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Inject runs of markers into specific segments of a continuous data set.
 Signal = set_insert_markers(Signal, Options...)

 Almost all real-time inference in BCIs is done on the basis of epochs, and epochs are most
 conveniently created relative to certain (&quot;time-locking&quot;) events/markers in the data. This
 function allows to cover periods of continuous data with events, at regular or random intervals,
 so that epochs covering these ranges can subsequently be extracted. What periods shall be
 populated with events can be flexibly specified.

 In:
   Signal      : continuous data set

   SegmentSpec : segment specification. cell array of one of the following forms (lats in seconds):
                 (default: {0 Inf})
                 note: the ordering of time values w.r.t. event-type values and cell-array values in the subsequent 
                       specifications is arbitrary, whereas the ordering of time values w.r.t. each other is relevant 
                       (first time value shall be lower than second time value); the ordering of eventtypes w.r.t. each 
                       other is also relevant.
                 * {absolute_time absolute_time}:
                   segment specified using two time points
                 * {event_type relative_time relative_time} / {relative_time  event_type relative_time} / 
                   {relative_time relative_time event_type}:
                   here, the segment is relative to some event (of a given type), in between the time interval given by the 
                   first and second time value
                 * {event_type relative_time relative_time event_type} / {relative_time event_type event_type relative_time} / ...
                   here, the segment is in between two immediately successive events of the given types (any intervals with other 
                   events in between the specified ones are not considered for injection), constrained by the relative lats 
                   for each event
                 * {event_type relative_time {ignore_type1,ignore_type2,...} relative_time event_type}
                   as above, except that intermediate events of type ignore_type1/ignore_type2/etc. are ignored
                   (if the in-between cell array is empty, any other events are ignored)
                 * {event_type relative_time {{forbidden_type1,forbidden_type2,...}} relative_time event_type}
                   as above, except that intermediate events of type
                   forbidden_type1/forbidden_type2/etc. must not occur

   Limits : optional time limits (in seconds) to constrain event placement (default: [-Inf Inf])

   Event : the inserted event type string, or alternatively a template event struct 
           (default: &quot;mytype_i&quot;, when injected relative to an event of type &quot;mytype&quot; or
           &quot;mytype1_mytype2&quot;, when injected in between two events of type &quot;mytype1&quot; and &quot;mytype2&quot;)
           * if a string is specified, all event fields besides the 'type', 'latency' and 'duration' fields 
             contained in the data will be left empty 
           * if a struct is specified, the 'latency' field will be substituted appropriately

   Count : number of events inserted within an interval; see Counting for the counting scheme (default: 1)

   Counting : what count means for any given segmentspec, either 'perinterval' or 'persecond' (default: 'perinterval')

   Placement : how the injected events should be placed, either 'random' or 'equidistant' (default: 'equidistant')

   Repeatable : whether the randomization procedure shall give repeatable results (default: 1); different numbers (aside from 0)
                give different repeatable runs, i.e. the value determines the randseed

   MinLength : segments that are shorter than this (in seconds) are ignored. (default: 0)

   MaxLength : segments that are longer than this (in seconds) are ignored. (default: Inf)

 Out:
   Signal  : continuous data set with new events injected

 Notes:
   The only parameter that may be specified by position (instead of as name-value pair) is the first one.

 Examples:
   % place 20 events of type 'X' within the interval 1000s to 2000s into the given data set (regular placement)
   eeg = set_insert_markers(eeg, 'SegmentSpec',{1000 2000},'Count',20,'Event','X')

   % as before, but use an event struct
   eeg = set_insert_markers(eeg, 'SegmentSpec',{1000 2000},'Count',20,'Event',struct('type','X'))

   % place 20 events within the interval 1000s to 2000s into the given data set (random pleacement)
   eeg = set_insert_markers(eeg, 'SegmentSpec',{1000 2000},'Count',20,'Placement','random','Event','X')

   % place 3 events per second within the interval 1000s to 2000s into the given data set (regular placement)
   eeg = set_insert_markers(eeg, 'SegmentSpec',{1000 2000}, 'Count',3, 'Counting','persecond','Event','X')
 
   % place on average 3 events per second within the interval 1000s to 2000s into the given data set (random placement)
   eeg = set_insert_markers(eeg, 'SegmentSpec',{1000 2000}, 'Count',3, 'Counting','persecond','Placement','random','Event','X')

   % place 20 events of type 'X' within each interval within 2s to 10s following each occurrence of the event 'A'
   eeg = set_insert_markers(eeg, 'SegmentSpec',{'A',2,10},'Count',20,'Event','X')

   % place on average 5 events per second (typed 'X') within each interval within -5s to 10s around each occurrence of the event 'A' (random placement)
   eeg = set_insert_markers(eeg, 'SegmentSpec',{'A',-5,10},'Counting','persecond','Count',5,'Event','X','Placement','random')

   % same as before, equivalent SegmentSpec formatting
   eeg = set_insert_markers(eeg, 'SegmentSpec',{-5,'A',10},'Counting','persecond','Count',5,'Event','X','Placement','random')

   % place 10 events (typed 'X') between each successive occurrence of event 'A' followed by event 'B' (with no other event in between),
   % and begin the interval 5s after event 'A' and end it 3s before event 'B' (regular placement)
   eeg = set_insert_markers(eeg, 'SegmentSpec',{'A',5,-3,'B'},'Count',10,'Event','X')

   % place 10 events (typed 'X') between each successive occurrence of event 'A' followed by event 'B' (with no other event in between),
   % and begin the interval 5s *before* event 'A' and end it right on event 'B' (regular placement)
   eeg = set_insert_markers(eeg, 'SegmentSpec',{-5,'A',0,'B'},'Count',10,'Event','X')

   % as before, but insert 3 events per second
   eeg = set_insert_markers(eeg, 'SegmentSpec',{-5,'A',0,'B'},'Count',3,'Counting','persecond','Event','X')

   % as before, but also consider those intervals where other events of type 'p' and/or 'q' occur between the 'A' and the 'B'
   eeg = set_insert_markers(eeg, 'SegmentSpec',{-5,'A', {'p','q'}, 0,'B'},'Count',3,'Counting','persecond','Event','X')
 
   % as before, but also consider those intervals where no other events than type 'p' and/or 'q' occur between the 'A' and the 'B'
   eeg = set_insert_markers(eeg, 'SegmentSpec',{-5,'A', {{'p','q'}}, 0,'B'},'Count',3,'Counting','persecond','Event','X')

   % as before, but also consider intervals where any other event occurs between the 'A' and the 'B' (except for 'B' obviously)
   eeg = set_insert_markers(eeg, 'SegmentSpec',{-5,'A', {}, 0,'B'},'Count',3,'Counting','persecond','Event','X')

   % as before, but discard segments that would be longer than 10 seconds
   eeg = set_insert_markers(eeg, 'SegmentSpec',{-5,'A', {}, 0,'B'},'Count',3,'Counting','persecond','Event','X','MaxLength',10)

   % as before, but use random placement
   eeg = set_insert_markers(eeg, 'SegmentSpec',{-5,'A', {}, 0,'B'},'Count',3,'Counting','persecond','Event','X','Placement','random')

   % as before, but use a random rand seed to obtain different placing at every call
   eeg = set_insert_markers(eeg, 'SegmentSpec',{-5,'A', {}, 0,'B'},'Count',3,'Counting','persecond','Event','X','Placement','random','Repeatable',0)

   % as before, but use a fixed specific rand seed to obtain a specific (but repeatable placing)
   eeg = set_insert_markers(eeg, 'SegmentSpec',{-5,'A', {}, 0,'B'},'Count',3,'Counting','persecond','Event','X','Placement','random','Repeatable',10)

                                Christian Kothe, Swartz Center for Computational Neuroscience, UCSD
                                2010-05-24</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">

</ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">

</ul>
<!-- crossreference -->


<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">

<li><a href="#_sub1" class="code">function [signal,coverage] = perform_injection(signal,ival,opts)</a></li>
<li><a href="#_sub2" class="code">function evt = make_default_event(evts,type)</a></li>
<li><a href="#_sub3" class="code">function [selection,spec] = parse_segment(spec)</a></li>
</ul>




<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function newsignal = set_insert_markers(varargin)</a>
0002 <span class="comment">% Inject runs of markers into specific segments of a continuous data set.</span>
0003 <span class="comment">% Signal = set_insert_markers(Signal, Options...)</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% Almost all real-time inference in BCIs is done on the basis of epochs, and epochs are most</span>
0006 <span class="comment">% conveniently created relative to certain (&quot;time-locking&quot;) events/markers in the data. This</span>
0007 <span class="comment">% function allows to cover periods of continuous data with events, at regular or random intervals,</span>
0008 <span class="comment">% so that epochs covering these ranges can subsequently be extracted. What periods shall be</span>
0009 <span class="comment">% populated with events can be flexibly specified.</span>
0010 <span class="comment">%</span>
0011 <span class="comment">% In:</span>
0012 <span class="comment">%   Signal      : continuous data set</span>
0013 <span class="comment">%</span>
0014 <span class="comment">%   SegmentSpec : segment specification. cell array of one of the following forms (lats in seconds):</span>
0015 <span class="comment">%                 (default: {0 Inf})</span>
0016 <span class="comment">%                 note: the ordering of time values w.r.t. event-type values and cell-array values in the subsequent</span>
0017 <span class="comment">%                       specifications is arbitrary, whereas the ordering of time values w.r.t. each other is relevant</span>
0018 <span class="comment">%                       (first time value shall be lower than second time value); the ordering of eventtypes w.r.t. each</span>
0019 <span class="comment">%                       other is also relevant.</span>
0020 <span class="comment">%                 * {absolute_time absolute_time}:</span>
0021 <span class="comment">%                   segment specified using two time points</span>
0022 <span class="comment">%                 * {event_type relative_time relative_time} / {relative_time  event_type relative_time} /</span>
0023 <span class="comment">%                   {relative_time relative_time event_type}:</span>
0024 <span class="comment">%                   here, the segment is relative to some event (of a given type), in between the time interval given by the</span>
0025 <span class="comment">%                   first and second time value</span>
0026 <span class="comment">%                 * {event_type relative_time relative_time event_type} / {relative_time event_type event_type relative_time} / ...</span>
0027 <span class="comment">%                   here, the segment is in between two immediately successive events of the given types (any intervals with other</span>
0028 <span class="comment">%                   events in between the specified ones are not considered for injection), constrained by the relative lats</span>
0029 <span class="comment">%                   for each event</span>
0030 <span class="comment">%                 * {event_type relative_time {ignore_type1,ignore_type2,...} relative_time event_type}</span>
0031 <span class="comment">%                   as above, except that intermediate events of type ignore_type1/ignore_type2/etc. are ignored</span>
0032 <span class="comment">%                   (if the in-between cell array is empty, any other events are ignored)</span>
0033 <span class="comment">%                 * {event_type relative_time {{forbidden_type1,forbidden_type2,...}} relative_time event_type}</span>
0034 <span class="comment">%                   as above, except that intermediate events of type</span>
0035 <span class="comment">%                   forbidden_type1/forbidden_type2/etc. must not occur</span>
0036 <span class="comment">%</span>
0037 <span class="comment">%   Limits : optional time limits (in seconds) to constrain event placement (default: [-Inf Inf])</span>
0038 <span class="comment">%</span>
0039 <span class="comment">%   Event : the inserted event type string, or alternatively a template event struct</span>
0040 <span class="comment">%           (default: &quot;mytype_i&quot;, when injected relative to an event of type &quot;mytype&quot; or</span>
0041 <span class="comment">%           &quot;mytype1_mytype2&quot;, when injected in between two events of type &quot;mytype1&quot; and &quot;mytype2&quot;)</span>
0042 <span class="comment">%           * if a string is specified, all event fields besides the 'type', 'latency' and 'duration' fields</span>
0043 <span class="comment">%             contained in the data will be left empty</span>
0044 <span class="comment">%           * if a struct is specified, the 'latency' field will be substituted appropriately</span>
0045 <span class="comment">%</span>
0046 <span class="comment">%   Count : number of events inserted within an interval; see Counting for the counting scheme (default: 1)</span>
0047 <span class="comment">%</span>
0048 <span class="comment">%   Counting : what count means for any given segmentspec, either 'perinterval' or 'persecond' (default: 'perinterval')</span>
0049 <span class="comment">%</span>
0050 <span class="comment">%   Placement : how the injected events should be placed, either 'random' or 'equidistant' (default: 'equidistant')</span>
0051 <span class="comment">%</span>
0052 <span class="comment">%   Repeatable : whether the randomization procedure shall give repeatable results (default: 1); different numbers (aside from 0)</span>
0053 <span class="comment">%                give different repeatable runs, i.e. the value determines the randseed</span>
0054 <span class="comment">%</span>
0055 <span class="comment">%   MinLength : segments that are shorter than this (in seconds) are ignored. (default: 0)</span>
0056 <span class="comment">%</span>
0057 <span class="comment">%   MaxLength : segments that are longer than this (in seconds) are ignored. (default: Inf)</span>
0058 <span class="comment">%</span>
0059 <span class="comment">% Out:</span>
0060 <span class="comment">%   Signal  : continuous data set with new events injected</span>
0061 <span class="comment">%</span>
0062 <span class="comment">% Notes:</span>
0063 <span class="comment">%   The only parameter that may be specified by position (instead of as name-value pair) is the first one.</span>
0064 <span class="comment">%</span>
0065 <span class="comment">% Examples:</span>
0066 <span class="comment">%   % place 20 events of type 'X' within the interval 1000s to 2000s into the given data set (regular placement)</span>
0067 <span class="comment">%   eeg = set_insert_markers(eeg, 'SegmentSpec',{1000 2000},'Count',20,'Event','X')</span>
0068 <span class="comment">%</span>
0069 <span class="comment">%   % as before, but use an event struct</span>
0070 <span class="comment">%   eeg = set_insert_markers(eeg, 'SegmentSpec',{1000 2000},'Count',20,'Event',struct('type','X'))</span>
0071 <span class="comment">%</span>
0072 <span class="comment">%   % place 20 events within the interval 1000s to 2000s into the given data set (random pleacement)</span>
0073 <span class="comment">%   eeg = set_insert_markers(eeg, 'SegmentSpec',{1000 2000},'Count',20,'Placement','random','Event','X')</span>
0074 <span class="comment">%</span>
0075 <span class="comment">%   % place 3 events per second within the interval 1000s to 2000s into the given data set (regular placement)</span>
0076 <span class="comment">%   eeg = set_insert_markers(eeg, 'SegmentSpec',{1000 2000}, 'Count',3, 'Counting','persecond','Event','X')</span>
0077 <span class="comment">%</span>
0078 <span class="comment">%   % place on average 3 events per second within the interval 1000s to 2000s into the given data set (random placement)</span>
0079 <span class="comment">%   eeg = set_insert_markers(eeg, 'SegmentSpec',{1000 2000}, 'Count',3, 'Counting','persecond','Placement','random','Event','X')</span>
0080 <span class="comment">%</span>
0081 <span class="comment">%   % place 20 events of type 'X' within each interval within 2s to 10s following each occurrence of the event 'A'</span>
0082 <span class="comment">%   eeg = set_insert_markers(eeg, 'SegmentSpec',{'A',2,10},'Count',20,'Event','X')</span>
0083 <span class="comment">%</span>
0084 <span class="comment">%   % place on average 5 events per second (typed 'X') within each interval within -5s to 10s around each occurrence of the event 'A' (random placement)</span>
0085 <span class="comment">%   eeg = set_insert_markers(eeg, 'SegmentSpec',{'A',-5,10},'Counting','persecond','Count',5,'Event','X','Placement','random')</span>
0086 <span class="comment">%</span>
0087 <span class="comment">%   % same as before, equivalent SegmentSpec formatting</span>
0088 <span class="comment">%   eeg = set_insert_markers(eeg, 'SegmentSpec',{-5,'A',10},'Counting','persecond','Count',5,'Event','X','Placement','random')</span>
0089 <span class="comment">%</span>
0090 <span class="comment">%   % place 10 events (typed 'X') between each successive occurrence of event 'A' followed by event 'B' (with no other event in between),</span>
0091 <span class="comment">%   % and begin the interval 5s after event 'A' and end it 3s before event 'B' (regular placement)</span>
0092 <span class="comment">%   eeg = set_insert_markers(eeg, 'SegmentSpec',{'A',5,-3,'B'},'Count',10,'Event','X')</span>
0093 <span class="comment">%</span>
0094 <span class="comment">%   % place 10 events (typed 'X') between each successive occurrence of event 'A' followed by event 'B' (with no other event in between),</span>
0095 <span class="comment">%   % and begin the interval 5s *before* event 'A' and end it right on event 'B' (regular placement)</span>
0096 <span class="comment">%   eeg = set_insert_markers(eeg, 'SegmentSpec',{-5,'A',0,'B'},'Count',10,'Event','X')</span>
0097 <span class="comment">%</span>
0098 <span class="comment">%   % as before, but insert 3 events per second</span>
0099 <span class="comment">%   eeg = set_insert_markers(eeg, 'SegmentSpec',{-5,'A',0,'B'},'Count',3,'Counting','persecond','Event','X')</span>
0100 <span class="comment">%</span>
0101 <span class="comment">%   % as before, but also consider those intervals where other events of type 'p' and/or 'q' occur between the 'A' and the 'B'</span>
0102 <span class="comment">%   eeg = set_insert_markers(eeg, 'SegmentSpec',{-5,'A', {'p','q'}, 0,'B'},'Count',3,'Counting','persecond','Event','X')</span>
0103 <span class="comment">%</span>
0104 <span class="comment">%   % as before, but also consider those intervals where no other events than type 'p' and/or 'q' occur between the 'A' and the 'B'</span>
0105 <span class="comment">%   eeg = set_insert_markers(eeg, 'SegmentSpec',{-5,'A', {{'p','q'}}, 0,'B'},'Count',3,'Counting','persecond','Event','X')</span>
0106 <span class="comment">%</span>
0107 <span class="comment">%   % as before, but also consider intervals where any other event occurs between the 'A' and the 'B' (except for 'B' obviously)</span>
0108 <span class="comment">%   eeg = set_insert_markers(eeg, 'SegmentSpec',{-5,'A', {}, 0,'B'},'Count',3,'Counting','persecond','Event','X')</span>
0109 <span class="comment">%</span>
0110 <span class="comment">%   % as before, but discard segments that would be longer than 10 seconds</span>
0111 <span class="comment">%   eeg = set_insert_markers(eeg, 'SegmentSpec',{-5,'A', {}, 0,'B'},'Count',3,'Counting','persecond','Event','X','MaxLength',10)</span>
0112 <span class="comment">%</span>
0113 <span class="comment">%   % as before, but use random placement</span>
0114 <span class="comment">%   eeg = set_insert_markers(eeg, 'SegmentSpec',{-5,'A', {}, 0,'B'},'Count',3,'Counting','persecond','Event','X','Placement','random')</span>
0115 <span class="comment">%</span>
0116 <span class="comment">%   % as before, but use a random rand seed to obtain different placing at every call</span>
0117 <span class="comment">%   eeg = set_insert_markers(eeg, 'SegmentSpec',{-5,'A', {}, 0,'B'},'Count',3,'Counting','persecond','Event','X','Placement','random','Repeatable',0)</span>
0118 <span class="comment">%</span>
0119 <span class="comment">%   % as before, but use a fixed specific rand seed to obtain a specific (but repeatable placing)</span>
0120 <span class="comment">%   eeg = set_insert_markers(eeg, 'SegmentSpec',{-5,'A', {}, 0,'B'},'Count',3,'Counting','persecond','Event','X','Placement','random','Repeatable',10)</span>
0121 <span class="comment">%</span>
0122 <span class="comment">%                                Christian Kothe, Swartz Center for Computational Neuroscience, UCSD</span>
0123 <span class="comment">%                                2010-05-24</span>
0124 
0125 <span class="comment">% set_insert_markers_version&lt;1.0&gt; -- for the cache</span>
0126 
0127 <span class="keyword">global</span> tracking;
0128 
0129 <span class="keyword">if</span> ~exp_beginfun(<span class="string">'editing'</span>) <span class="keyword">return</span>; <span class="keyword">end</span>
0130 
0131 declare_properties(<span class="string">'name'</span>,<span class="string">'MarkerInsertion'</span>, <span class="string">'independent_channels'</span>,true, <span class="string">'cannot_follow'</span>,<span class="string">'set_makepos'</span>, <span class="string">'independent_channels'</span>,true,<span class="string">'independent_trials'</span>,true);
0132 
0133 opts = arg_define([0 1],varargin, <span class="keyword">...</span>
0134     arg_norep({<span class="string">'signal'</span>,<span class="string">'Signal'</span>}), <span class="keyword">...</span>
0135     arg_subswitch({<span class="string">'segmentspec'</span>,<span class="string">'SegmentSpec'</span>,<span class="string">'segment'</span>},<span class="string">'absoluterange'</span>, <span class="keyword">...</span>
0136         {<span class="string">'absoluterange'</span>,{ <span class="keyword">...</span>
0137             arg({<span class="string">'lo'</span>,<span class="string">'BeginOffset'</span>},0,[],<span class="string">'Lower bound of insertion interval. Events will be inserted beginning from this time point, in seconds.'</span>), <span class="keyword">...</span>
0138             arg({<span class="string">'hi'</span>,<span class="string">'EndOffset'</span>},Inf,[],<span class="string">'Upper bound of insertion interval. Events will be inserted up to this time point, in seconds. If this is negative, it counts from the end of the recording.'</span>)}, <span class="keyword">...</span>
0139          <span class="string">'relativerange'</span>,{ <span class="keyword">...</span>
0140             arg({<span class="string">'event'</span>,<span class="string">'EventType'</span>},<span class="string">'event1'</span>,[],<span class="string">'Reference event type. New events will be inserted in a range around each event of this type.'</span>), <span class="keyword">...</span>
0141             arg({<span class="string">'lo'</span>,<span class="string">'BeginOffset'</span>},-0.5,[],<span class="string">'Lower bound relative to event. This is the lower boundary of insertion intervals relative to the reference events. In seconds.'</span>), <span class="keyword">...</span>
0142             arg({<span class="string">'hi'</span>,<span class="string">'EndOffset'</span>},1,[],<span class="string">'Upper bound relative to event. This is the upper boundary of insertion intervals relative to the reference events. In seconds.'</span>)}, <span class="keyword">...</span>
0143          <span class="string">'spannedrange'</span>,{ <span class="keyword">...</span>
0144             arg({<span class="string">'openevent'</span>,<span class="string">'OpenEvent'</span>},<span class="string">'event1'</span>,[],<span class="string">'Type of opening reference event. New events will be inserted between each pair of successive events with types OpenEvent and CloseEvent.'</span>), <span class="keyword">...</span>
0145             arg({<span class="string">'closeevent'</span>,<span class="string">'CloseEvent'</span>},<span class="string">'event2'</span>,[],<span class="string">'Type of closing reference event. New events will be inserted between each pair of successive events with types OpenEvent and CloseEvent.'</span>), <span class="keyword">...</span>
0146             arg({<span class="string">'lo'</span>,<span class="string">'OpenOffset'</span>},0.5,[],<span class="string">'Offset relative to opening event. This is an offset relative to the position of the opening reference event, which shifts the beginning of a spanned insertion interval. In seconds.'</span>), <span class="keyword">...</span>
0147             arg({<span class="string">'hi'</span>,<span class="string">'CloseOffset'</span>},-0.5,[],<span class="string">'Offset relative to closing event. This is an offset relative to the position of the closing reference event, which shifts the beginning of a spanned insertion interval. In seconds.'</span>), <span class="keyword">...</span>
0148             arg({<span class="string">'ignored'</span>,<span class="string">'IgnoredEvents'</span>},{},[],<span class="string">'Ignored event types. This is the list of event types that may occur between the opening and closing events. If any other event appears between a pair of successive opening and closing events, this range will not be considered for event insertion (it is considered &quot;broken&quot;). If set to ''ignoreall'', any event type may appear in between.'</span>, <span class="string">'type'</span>,<span class="string">'cellstr'</span>,<span class="string">'shape'</span>,<span class="string">'row'</span>) <span class="keyword">...</span>
0149             arg({<span class="string">'forbidden'</span>,<span class="string">'ForbiddenEvents'</span>},{},[],<span class="string">'Forbidden event types. This is the list of event types that may not occur between the opening and closing events. This is typically combined with ignored set to ignoreall.'</span>, <span class="string">'type'</span>,<span class="string">'cellstr'</span>,<span class="string">'shape'</span>,<span class="string">'row'</span>)} <span class="keyword">...</span>
0150         },<span class="string">'Insertion interval definition. Events can be inserted either in fixed, absolute time window of the data set (absoluterange), or in time windows relative to reference events of a certain type (relativerange), or in time window spanned by two subsequent events of certain types (called the opening event and the closing event), optionally with ignored events in between (spannedrange).'</span>,<span class="string">'cat'</span>,<span class="string">'Time Ranges'</span>,<span class="string">'mapper'</span>,@<a href="#_sub3" class="code" title="subfunction [selection,spec] = parse_segment(spec)">parse_segment</a>), <span class="keyword">...</span>
0151     arg({<span class="string">'limits'</span>,<span class="string">'Limits'</span>},[-Inf Inf],[],<span class="string">'Time limits for event placement. Events that fall outside these bounds will be skipped. Therefore, intervals that intersect these boundaries may have fewer events than others.'</span>,<span class="string">'cat'</span>,<span class="string">'Time Ranges'</span>),<span class="keyword">...</span>
0152     arg({<span class="string">'event'</span>,<span class="string">'InsertedType'</span>,<span class="string">'Event'</span>},<span class="string">'newevent'</span>,[],<span class="string">'Type of inserted events. The event type for the newly inserted events.'</span>,<span class="string">'cat'</span>,<span class="string">'Placement'</span>), <span class="keyword">...</span>
0153     arg({<span class="string">'count'</span>,<span class="string">'Count'</span>},1,[],<span class="string">'Number of inserted events. This is either per interval or per second, depending on the Counting argument.'</span>,<span class="string">'cat'</span>,<span class="string">'Placement'</span>), <span class="keyword">...</span>
0154     arg({<span class="string">'counting'</span>,<span class="string">'Counting'</span>},<span class="string">'perinterval'</span>,{<span class="string">'perinterval'</span>,<span class="string">'persecond'</span>},<span class="string">'Counting measure. Events can be inserted in a certain number per interval or per second'</span>,<span class="string">'cat'</span>,<span class="string">'Placement'</span>), <span class="keyword">...</span>
0155     arg({<span class="string">'placement'</span>,<span class="string">'Placement'</span>},<span class="string">'equidistant'</span>,{<span class="string">'equidistant'</span>,<span class="string">'random'</span>},<span class="string">'Event placement scheme. Events can be inserted at equal (regular) distance from each other, or at random positions.'</span>,<span class="string">'cat'</span>,<span class="string">'Placement'</span>), <span class="keyword">...</span>
0156     arg({<span class="string">'repeatable'</span>,<span class="string">'Repeatable'</span>},1,[],<span class="string">'Repeatable versus random placement. If 0, placement is random, if different from 0, the number is taken as the random seed, giving a unique repeatable run per number.'</span>,<span class="string">'cat'</span>,<span class="string">'Placement'</span>), <span class="keyword">...</span>
0157     arg({<span class="string">'minlen'</span>,<span class="string">'MinLength'</span>},0,[],<span class="string">'Minimum segment length. Ignore segments that are shorter than this, in seconds.'</span>), <span class="keyword">...</span>
0158     arg({<span class="string">'maxlen'</span>,<span class="string">'MaxLength'</span>},Inf,[],<span class="string">'Maximum segment length. Ignore segments that are longer than this, in seconds.'</span>));
0159 
0160 signal = opts.signal;
0161 
0162 <span class="comment">% input validation</span>
0163 utl_check_fields(signal,{<span class="string">'data'</span>,<span class="string">'xmax'</span>,<span class="string">'xmin'</span>,<span class="string">'srate'</span>},<span class="string">'signal'</span>,<span class="string">'signal'</span>);
0164 <span class="keyword">if</span> (isfield(signal,<span class="string">'epoch'</span>) &amp;&amp; ~isempty(signal.epoch)) || size(signal.data,3) &gt; 1
0165     error(<span class="string">'the data set appears to contain epochs: only continuous data set are supported by this implementation.'</span>); <span class="keyword">end</span>
0166 <span class="keyword">if</span> ~isfield(signal,<span class="string">'event'</span>)
0167     signal.event = []; <span class="keyword">end</span>
0168 <span class="keyword">if</span> ~isempty(signal.event)
0169     <span class="keyword">if</span> ~isfield(signal.event,<span class="string">'latency'</span>)
0170         error(<span class="string">'The given signal has a non-empty field .event but is missing the required field .event.latency.'</span>); <span class="keyword">end</span>
0171     <span class="keyword">if</span> ~isfield(signal.event,<span class="string">'type'</span>)
0172         error(<span class="string">'The given signal has a non-empty field .event but is missing the required field .event.type.'</span>); <span class="keyword">end</span>
0173     latency_numels = cellfun(<span class="string">'prodofsize'</span>,{signal.event.latency});
0174     <span class="keyword">if</span> any(latency_numels == 0)
0175         error(<span class="string">'The given signal has one or more events with empty .latency field. This is not permitted.'</span>);
0176     <span class="keyword">elseif</span> any(latency_numels ~= 1)
0177         error(<span class="string">'The given signal has one or more events with a .latency value that is not a scalar. This is not permitted.'</span>);
0178     <span class="keyword">end</span>    
0179 <span class="keyword">end</span>
0180 <span class="keyword">if</span> ~isequal(size(opts.limits),[1 2]) || ~isreal(opts.limits) || opts.limits(1)&gt;opts.limits(2)
0181     error(<span class="string">'The given Limits argument needs to be of the form [lower,upper].'</span>); <span class="keyword">end</span>
0182 
0183 <span class="comment">% refine options</span>
0184 opts.count = double(opts.count);
0185 opts.limits = sort(max(min(opts.limits,signal.xmax),signal.xmin));
0186 opts.limits = opts.limits*signal.srate;
0187 opts.segmentspec.lo = opts.segmentspec.lo*signal.srate;
0188 opts.segmentspec.hi = opts.segmentspec.hi*signal.srate;
0189 
0190 <span class="comment">% init randomization</span>
0191 <span class="keyword">if</span> strcmp(opts.placement,<span class="string">'random'</span>) &amp;&amp; opts.repeatable
0192     <span class="keyword">if</span> hlp_matlab_version &lt; 707
0193         <span class="comment">% save &amp; override RNG state</span>
0194         randstate = rand(<span class="string">'state'</span>); <span class="comment">%#ok&lt;RAND&gt;</span>
0195         rand(<span class="string">'state'</span>,5182+opts.repeatable); <span class="comment">%#ok&lt;RAND&gt;</span>
0196     <span class="keyword">else</span>
0197         <span class="comment">% create a legacy-compatible RandStream</span>
0198         tracking.temp.randstream_inject_events = RandStream(<span class="string">'swb2712'</span>,<span class="string">'Seed'</span>,5182+opts.repeatable);
0199     <span class="keyword">end</span>
0200 <span class="keyword">end</span>
0201 
0202 newsignal = signal;
0203 <span class="keyword">switch</span> opts.segmentspec.arg_selection 
0204     <span class="keyword">case</span> <span class="string">'absoluterange'</span>
0205         <span class="keyword">if</span> opts.segmentspec.lo == -Inf
0206             opts.segmentspec.lo = signal.xmin*signal.srate; <span class="keyword">end</span>
0207         <span class="keyword">if</span> opts.segmentspec.hi == Inf
0208             opts.segmentspec.hi = signal.xmax*signal.srate; <span class="keyword">end</span>
0209         <span class="keyword">if</span> opts.segmentspec.hi &lt; 0
0210             opts.segmentspec.hi = signal.xmax*signal.srate - opts.segmentspec.hi; <span class="keyword">end</span>
0211         
0212         <span class="comment">% inject using absolute latencies</span>
0213         <span class="keyword">if</span> isempty(opts.event)
0214             error(<span class="string">'an event type must be specified'</span>); <span class="keyword">end</span>
0215         <span class="keyword">if</span> ischar(opts.event)
0216             opts.event = <a href="#_sub2" class="code" title="subfunction evt = make_default_event(evts,type)">make_default_event</a>(signal.event,opts.event); <span class="keyword">end</span>
0217         newsignal = <a href="#_sub1" class="code" title="subfunction [signal,coverage] = perform_injection(signal,ival,opts)">perform_injection</a>(newsignal,[opts.segmentspec.lo opts.segmentspec.hi],opts);
0218     <span class="keyword">case</span> <span class="string">'relativerange'</span>
0219         <span class="comment">% inject relative to one single marker</span>
0220         <span class="keyword">if</span> isempty(opts.event)
0221             opts.event = [opts.segmentspec.event <span class="string">'_i'</span>]; <span class="keyword">end</span>
0222         <span class="keyword">if</span> ischar(opts.event)
0223             opts.event = <a href="#_sub2" class="code" title="subfunction evt = make_default_event(evts,type)">make_default_event</a>(signal.event,opts.event); <span class="keyword">end</span>
0224         <span class="keyword">for</span> e=find(strcmp({signal.event.type},opts.segmentspec.event))
0225             newsignal = <a href="#_sub1" class="code" title="subfunction [signal,coverage] = perform_injection(signal,ival,opts)">perform_injection</a>(newsignal,signal.event(e).latency+[opts.segmentspec.lo opts.segmentspec.hi],opts); <span class="keyword">end</span>
0226     <span class="keyword">case</span> <span class="string">'spannedrange'</span>
0227         <span class="comment">% inject in between two successive markers</span>
0228         <span class="keyword">if</span> isempty(opts.event)
0229             opts.event = [opts.segmentspec.openevent <span class="string">'_'</span> opts.segmentspec.closeevent]; <span class="keyword">end</span>
0230         <span class="keyword">if</span> ischar(opts.event)
0231             opts.event = <a href="#_sub2" class="code" title="subfunction evt = make_default_event(evts,type)">make_default_event</a>(signal.event,opts.event); <span class="keyword">end</span>
0232         types = {signal.event.type};
0233         starts = find(strcmp(types,opts.segmentspec.openevent));
0234         starts(end+1) = length(signal.event);
0235         ends = strcmp(types,opts.segmentspec.closeevent);
0236         <span class="comment">% for each potential interval start...</span>
0237         <span class="keyword">for</span> k=1:length(starts)-1
0238             valid = true;
0239             <span class="comment">% the range of event indices from start marker to next end marker</span>
0240             scan_range = starts(k) : starts(k) + find(ends(starts(k)+1:starts(k+1)-1),1);
0241             <span class="keyword">if</span> length(scan_range) &gt;= 2
0242                 <span class="comment">% the range excluding the start and end marker</span>
0243                 inner_range = scan_range(2:end-1);
0244                 <span class="comment">% check various exclusion criteria</span>
0245                 <span class="keyword">if</span> ~isempty(inner_range)
0246                     <span class="comment">% selective ignorance turned on but non-ignored intermediate marker found?</span>
0247                     <span class="keyword">if</span> ~isequal(opts.segmentspec.ignored,{<span class="string">'ignoreall'</span>})
0248                         <span class="keyword">for</span> e=inner_range
0249                             <span class="keyword">if</span> ~any(strcmp(signal.event(e).type,opts.segmentspec.ignored))
0250                                 valid = false; <span class="keyword">break</span>; <span class="keyword">end</span>
0251                         <span class="keyword">end</span>
0252                     <span class="keyword">end</span>
0253                     <span class="comment">% selectively forbidden events turned on and a match was found?</span>
0254                     <span class="keyword">if</span> valid &amp;&amp; ~isempty(opts.segmentspec.forbidden)
0255                         <span class="keyword">for</span> e=inner_range
0256                             <span class="keyword">if</span> any(strcmp(signal.event(e).type,opts.segmentspec.forbidden))
0257                                 valid = false; <span class="keyword">break</span>; <span class="keyword">end</span>
0258                         <span class="keyword">end</span>
0259                     <span class="keyword">end</span>
0260                 <span class="keyword">end</span>
0261                 <span class="comment">% if valid, we can inject</span>
0262                 <span class="keyword">if</span> valid
0263                     newsignal = <a href="#_sub1" class="code" title="subfunction [signal,coverage] = perform_injection(signal,ival,opts)">perform_injection</a>(newsignal,[signal.event(scan_range(1)).latency+opts.segmentspec.lo,signal.event(scan_range(end)).latency+opts.segmentspec.hi],opts); <span class="keyword">end</span>
0264             <span class="keyword">end</span>
0265         <span class="keyword">end</span>
0266 <span class="keyword">end</span>
0267 <span class="comment">% sort the events by latency...</span>
0268 newsignal.event = newsignal.event(hlp_getresult(2,@sort,[newsignal.event.latency]));
0269 
0270 <span class="comment">% update .urevent field if trivial</span>
0271 <span class="keyword">if</span> isempty(newsignal.urevent) || isequal([newsignal.event.urevent],1:length(newsignal.event))
0272     newsignal.urevent = newsignal.event;
0273     [newsignal.event.urevent] = arraydeal(1:length(newsignal.event));
0274 <span class="keyword">end</span>
0275 
0276 <span class="comment">% conclude randomization</span>
0277 <span class="keyword">if</span> strcmp(opts.placement,<span class="string">'random'</span>) &amp;&amp; opts.repeatable &amp;&amp; hlp_matlab_version &lt; 707
0278     <span class="comment">% restore saved RNG state</span>
0279     rand(<span class="string">'state'</span>,randstate); <span class="comment">%#ok&lt;RAND&gt;</span>
0280 <span class="keyword">end</span>
0281 
0282 exp_endfun;
0283 
0284 
0285 
0286 <a name="_sub1" href="#_subfunctions" class="code">function [signal,coverage] = perform_injection(signal,ival,opts)</a>
0287 <span class="keyword">global</span> tracking;
0288 coverage = 0;
0289 <span class="comment">% sanity check</span>
0290 <span class="keyword">if</span> length(ival) == 2 &amp;&amp; ival(1) &lt;= ival(2)
0291     coverage = ival(2)-ival(1);
0292     <span class="comment">% check the segment length</span>
0293     seg_length = coverage/signal.srate;
0294     <span class="keyword">if</span> seg_length &lt; opts.minlen || seg_length &gt; opts.maxlen
0295         exp_endfun; <span class="keyword">return</span>; <span class="keyword">end</span>
0296     <span class="comment">% hande the spacing method</span>
0297     <span class="keyword">if</span> strcmp(opts.counting,<span class="string">'persecond'</span>)
0298         opts.count = max(1,round(opts.count*(ival(2)-ival(1))/signal.srate)); <span class="keyword">end</span>
0299     <span class="comment">% handle the placement method</span>
0300     <span class="keyword">if</span> strcmp(opts.placement,<span class="string">'equidistant'</span>)
0301         <span class="keyword">if</span> coverage ~= 0
0302             stepsize = (ival(2)-ival(1))/(opts.count-1);
0303             ival = round(ival(1):stepsize:ival(2));
0304         <span class="keyword">else</span>
0305             ival = ival(1)*ones(1,opts.count);
0306         <span class="keyword">end</span>
0307     <span class="keyword">elseif</span> strcmp(opts.placement,<span class="string">'random'</span>)        
0308         <span class="keyword">if</span> ival(1) &lt; ival(2)            
0309             <span class="keyword">if</span> hlp_matlab_version &lt; 707
0310                 positions = rand(1,opts.count);
0311             <span class="keyword">else</span>
0312                 positions = rand(tracking.temp.randstream_inject_events,1,opts.count);
0313             <span class="keyword">end</span>
0314             ival = round(positions*(ival(2)-ival(1))+ival(1));
0315         <span class="keyword">elseif</span> ival(1) == ival(2)
0316             ival = ival(1)*ones(1,opts.count);
0317         <span class="keyword">else</span>
0318             ival = [];
0319         <span class="keyword">end</span>
0320     <span class="keyword">else</span>
0321         error(<span class="string">'unsupported placement scheme specified'</span>);
0322     <span class="keyword">end</span>
0323     <span class="keyword">if</span> ~isempty(ival)
0324         <span class="comment">% compute the individual latencies</span>
0325         lats = ival(ival&gt;=opts.limits(1) &amp; ival&lt;=opts.limits(2));
0326         <span class="comment">% sanitize latencies</span>
0327         lats = min(max(lats,1),size(signal.data,2));
0328         <span class="keyword">if</span> ~isempty(signal.urevent)
0329             signal.urevent = []; <span class="keyword">end</span>
0330         <span class="keyword">if</span> isempty(signal.event)
0331             signal.event = setfield(setfield(opts.event,<span class="string">'latency'</span>,1),<span class="string">'type'</span>,<span class="string">'dummy'</span>); <span class="keyword">end</span>; <span class="comment">%#ok&lt;SFLD&gt;</span>
0332         range = length(signal.event) + (1:length(lats));
0333         [signal.event(range)] = deal(opts.event);
0334         [signal.event(range).latency] = arraydeal(lats);
0335     <span class="keyword">end</span>
0336 <span class="keyword">end</span>
0337 
0338 
0339 <span class="comment">% create a default event from an event array</span>
0340 <a name="_sub2" href="#_subfunctions" class="code">function evt = make_default_event(evts,type)</a>
0341 <span class="keyword">if</span> isempty(evts)
0342     evt = struct(<span class="string">'type'</span>,{type},<span class="string">'latency'</span>,{[]},<span class="string">'duration'</span>,{1},<span class="string">'urevent'</span>,{[]});
0343 <span class="keyword">else</span>
0344     evt = evts(1);
0345     <span class="keyword">for</span> fn=fieldnames(evt)'
0346         evt.(fn{1}) = []; <span class="keyword">end</span>
0347     evt.type = type;
0348     <span class="keyword">if</span> isfield(evt,<span class="string">'duration'</span>)
0349         evt.duration = 1; <span class="keyword">end</span>
0350 <span class="keyword">end</span>
0351 
0352 
0353 <span class="comment">% parse a SegmentSpec specification into a cell array {tag,name,value,name,value,...}</span>
0354 <span class="comment">% in addition to the typical arg_subswitch syntax, we also allow cell arrays that contain time</span>
0355 <span class="comment">% values and marker labels as in the documentation of SegmentSpec above</span>
0356 <a name="_sub3" href="#_subfunctions" class="code">function [selection,spec] = parse_segment(spec)</a>
0357 <span class="comment">% sanitize</span>
0358 <span class="keyword">if</span> ~iscell(spec)
0359     <span class="keyword">if</span> isstruct(spec) || ischar(spec)
0360         spec = {spec};
0361     <span class="keyword">elseif</span> isequal(spec,[])
0362         spec = {};
0363     <span class="keyword">else</span>
0364         error([<span class="string">'It is not allowed to assign anything other than a cell, a struct, or a (selector) string to an arg_subswitch argument (here:'</span> names{1} <span class="string">')'</span>]); 
0365     <span class="keyword">end</span>
0366 <span class="keyword">end</span>
0367 
0368 <span class="comment">% check for standard mappings</span>
0369 <span class="keyword">if</span> isempty(spec)
0370     selection = <span class="string">'absoluterange'</span>;
0371 <span class="keyword">elseif</span> isfield(spec{1},<span class="string">'arg_selection'</span>)
0372     selection = spec{1}.arg_selection;
0373 <span class="keyword">elseif</span> any(strcmp(spec{1},{<span class="string">'absoluterange'</span>,<span class="string">'relativerange'</span>,<span class="string">'spannedrange'</span>}))
0374     [selection,spec] = deal(spec{1},spec(2:end));
0375 <span class="keyword">elseif</span> any(strcmp(spec(1:end-1),<span class="string">'arg_selection'</span>))
0376     pos = find(strcmp(<span class="string">'arg_selection'</span>,spec(1:end-1)),1,<span class="string">'last'</span>);
0377     [selection,spec] = deal(spec{pos+1},spec([1:pos-1 pos+2:end]));
0378 <span class="keyword">else</span>
0379     <span class="comment">% we have a custom SegmentSpec specification (as indicated in the function's help text)</span>
0380     <span class="comment">% parse it.</span>
0381     mrks = {};
0382     lats = [];
0383     ignored = [];
0384     forbidden = {};
0385     <span class="keyword">for</span> i=1:length(spec)
0386         <span class="keyword">if</span> ischar(spec{i})
0387             mrks{end+1} = spec{i};
0388         <span class="keyword">elseif</span> iscell(spec{i})
0389             <span class="keyword">if</span> ~isempty(spec{i}) &amp;&amp; iscell(spec{i})
0390                 forbidden = [forbidden spec{i}{1}];
0391             <span class="keyword">else</span>
0392                 ignored = [ignored spec{i}];
0393             <span class="keyword">end</span>
0394         <span class="keyword">else</span>
0395             lats(end+1) = spec{i};
0396         <span class="keyword">end</span>
0397     <span class="keyword">end</span>
0398     <span class="comment">% and configure parameters</span>
0399     <span class="keyword">if</span> isempty(mrks)
0400         selection = <span class="string">'absoluterange'</span>; spec = {<span class="string">'lo'</span> min(lats) <span class="string">'hi'</span> max(lats)};
0401     <span class="keyword">elseif</span> length(mrks) == 1
0402         selection = <span class="string">'relativerange'</span>; spec = {<span class="string">'event'</span> mrks{1} <span class="string">'lo'</span> min(lats) <span class="string">'hi'</span> max(lats)};
0403     <span class="keyword">elseif</span> length(mrks) == 2
0404         selection = <span class="string">'spannedrange'</span>; 
0405         <span class="keyword">if</span> isequal(ignored,{}) || (~isempty(forbidden) &amp;&amp; isequal(ignored,[]))
0406             ignored = {<span class="string">'ignoreall'</span>};
0407         <span class="keyword">elseif</span> isequal(ignored,[])
0408             ignored = {};
0409         <span class="keyword">end</span>
0410         spec = {<span class="string">'openevent'</span> mrks{1} <span class="string">'closeevent'</span> mrks{2} <span class="string">'lo'</span> lats(1) <span class="string">'hi'</span> lats(2) <span class="string">'ignored'</span> ignored <span class="string">'forbidden'</span> forbidden};
0411     <span class="keyword">else</span>
0412         error(<span class="string">'Unsupported segment specification: %s.'</span>,hlp_tostring(spec));
0413     <span class="keyword">end</span>
0414 <span class="keyword">end</span>
0415 
0416 <span class="comment">% If this error is triggered, an value was passed for an argument which has a flexible structure (chosen out of a set of possibilities), but the possibility</span>
0417 <span class="comment">% which was chosen according to the passed value does not match any of the specified ones. For a value that is a cell array of arguments, the choice is</span>
0418 <span class="comment">% made based on the first element in the cell. For a value that is a structure of arguments, the choice is made based on the 'arg_selection' field.</span>
0419 <span class="comment">% The error is usually resolved by reviewing the argument specification of the offending function carefully, and comparing the passed value to the Alternatives</span>
0420 <span class="comment">% declared in the arg_subswitch() clause in which the offending argument is declared.</span>
0421 <span class="keyword">if</span> isempty(selection)
0422     error(<span class="string">'The chosen selector argument (empty) does not match any of the possible options {''absoluterange'', ''relativerange'', ''spannedrange''} in the function argument SegmentSpec.'</span>);
0423 <span class="keyword">elseif</span> ~any(strcmpi(selection,{<span class="string">'absoluterange'</span>,<span class="string">'relativerange'</span>,<span class="string">'spannedrange'</span>}))
0424     error([<span class="string">'The chosen selector argument ('</span> selection <span class="string">') does not match any of the possible options {''absoluterange'', ''relativerange'', ''spannedrange''} in the function argument SegmentSpec.'</span>]); 
0425 <span class="keyword">end</span></pre></div>

<hr><address>Generated on Wed 19-Aug-2015 18:06:23 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>