function [signal, state] = flt_sourceLocalize(varargin)
% Localize sources for a given head model.
% Estimated sources and inverse operator will be stored in 
% signal.CSD and signal.invOperator
% 
% Author: Tim Mullen, Jan 2013, SCCN/INC/UCSD
%         Alejandro Ojeda, Jan 2013, SCCN/INC/UCSD
%         Christian Kothe, Jan 2013, SCCN/INC/UCSD

% FIXME: Need to add a for loop over the calls to Loreta (or add it in the
% flt_loreta function) which loops over sub-partitions of the data block,
% estimating CSD for each partition (i.e. assuming local stationarity of 
% the inverse operator within each partition). The invOperator results are 
% stored in a 3D array and the mean invOperator is then returned in state
% obj as well as in signal obj.
% FIXME: Implement option to only update inverse operatior infrequently,
% otherwise using the inv op stored in state object (i.e. mean over last
% block).

if ~exp_beginfun('filter'), return; end

declare_properties('name','SourceLocalization', 'experimental',true, 'follows',{'flt_ica','flt_fir','flt_iir','flt_project'}, 'cannot_precede',{'flt_clean_settings'},'cannot_follow',{'set_makepos'},'independent_channels',false, 'independent_trials',false);

% extract some defaults
headmodel_default = 'resources:/headmodels/standard-Colin27-385ch.mat';
if ~onl_isonline
    hmObj = arg_extract(varargin,{'hmObj','HeadModelObject'},[],headmodel_default);
    hmObj = hlp_validateHeadModelObject(hmObj);
    if isempty(hmObj)
        ROINames = {};
    else
        % get the unique ROI names
        [tmp, idx] = unique(hmObj.atlas.label);
        ROINames = hmObj.atlas.label(sort(idx))';
    end
else
    ROINames = {};
end

arg_define(varargin, ...
    arg_norep({'signal','Signal'},[],[],'Signal structure. Must contain .data field with channel data'), ...
    arg({'hmObj','HeadModelObject'},headmodel_default,[],'Head model object generated by MOBILAB. See MOBILAB''s headModel class.'), ...
    arg({'channels','Channels'},[],[],'Cell array of channel labels to retain. If empty, all channels in signal.chanlocs.labels will be used. Channels must be a subset of hmObj.getChannelLabels()','type','cellstr','shape','row'), ...
    arg_subswitch({'invMethod','InverseMethod'},{'LORETA'}, ...
    {...
     'LORETA', @flt_loreta, ...
     'Variational LORETA', @flt_vbloreta, ...
     },'Source Localization Algorithm'), ...
    arg({'sourceAtlasLabels','SourceAtlasLabels','SourceAtlasROI'},ROINames,ROINames,'Source regions of interest (atlas labels). This is a cell array of strings corresponding to a subset of the labels stored in hmObj.atlas.label. Current source density will be estimated only for these ROIs.','type','logical'), ...
    arg({'colRoiCsd','CollapseRoiCsd'},'sum',{'none','mean','sum','max','maxmag','median'},'Method for computing ROI CSD. Return the (mean, integral, max) current source density within each ROI. signal.CSD matrix will be reduced to [num_rois x num_samples].'), ...
    arg({'keepFullCsd','KeepFullCsd'},true,[],'Keep a copy of the csd for each vertex. This is stored in srcpot_all'), ...
    arg({'roiAtlasLabels','ROIAtlasLabels','AtlasROI','ROI'},ROINames,ROINames,'Regions of interest atlas labels. This is a cell array of strings corresponding to a subset of the labels stored in hmObj.atlas.label. If CollapseRoiCsd is set, current source density will be integrated over these ROIs. If empty the all ROIs in SourceAtlasLabels are selected.','type','logical'), ...
    arg({'combineROIs','CombineROI'},[],[],'Combine ROIs in ROIAtlasLabels. This is a cell array of (name, value) pairs. The name entry is a string denoting the name of a new ROI. The value part is a cell array of strings indicating which of the ROIs in ROIAtlasLabels should be combined to form a new ROI. Any ROIs that were merged into a new ROI are removed from the original set of ROIs. To preserve an ROI that was merged into a new ROI, specify a new ROI containing only this ROI. All new ROIs are then appended to the list of existing (unmerged) ROIs in ROIAtlasLabels. If CollapseRoiCsd is set, current source density will be integrated over all ROIs.','type','expression','shape','row'), ...
    arg({'appendROI','AppendROI'},false,[],'Append superROIs or replace'), ...
    arg({'reference','Reference'},[],[],'Reference scheme. This is a cell array of channel labels defining the reference. If more than one channel, average reference is assumed','type','cellstr','shape','row'), ...
    arg_nogui({'roiVertices','ROIVertices'},[],[],'Regions of interest (vertices). This is supplementary to the ''RegionsOfInterest'' option. ''roiVertices'' is a cell array where each cell contains the indices of all vertices within a region of interest. The vertex indices correspond to respective columns of the lead field matrix. These ROIs will be added to the set of ROIs defined in the ''RegionsOfInterest'' option.','type','expression'), ...
    arg_nogui({'roiVerticesLabels'},[],[],'Labels for the supplementary ROIs. This is a cell array of same dimension as ''roiVertices'' with labels for each ROI','type','cellstr'), ...
    arg({'makeDipfitStruct','MakeDipfitStruct'},true,[],'Make dipfit structure. If selected, a dipfit structure will be created in signal.dipfit containing the locations (.posxyz) and moments (.mom) of each dipole or center of mass of ROI.'), ... 
    arg({'do_transform','TransformData','transform'},false,[],'Transform the data rather than annotate. By default, source reconstructions are added as annotations (.srcpot) to the data set.'),...
    arg({'verb','Verbosity'},false,[],'Verbose output'), ...
    arg_nogui({'state','State'}));

if isempty(roiAtlasLabels) %#ok
    roiAtlasLabels = ROINames;
end
if isempty(sourceAtlasLabels) %#ok
    sourceAtlasLabels = ROINames;
end
% if ~isempty(combineROIs)
%     % initially override roiAtlasLabels
%     roiAtlasLabels = sourceAtlasLabels;
% end


% Intialization block
% -------------------------------------------------------------------------
if isempty(state)
    % || (isfield(state,'roiAtlasLabels') && ~isequal(state.roiAtlasLabels,roiAtlasLabels))
    % Either we are initializing our adaptive estimator or user-specified 
    % ROIs have changed.
    state = hlp_microcache('sourcespace',@build_state,hmObj,channels,sourceAtlasLabels,roiAtlasLabels,roiVertices,roiVerticesLabels,makeDipfitStruct,verb,signal.chanlocs,combineROIs,appendROI);
end

% Estimate Current Source Density
% -------------------------------------------------------------------------

% Current source density is returned in signal.srcpot 
% [num_vertices x num_samples] 
% Inverse operator is returned in signal.srcweights   
% [num_vertices x num_channels]

switch lower(invMethod.arg_selection)
    case 'loreta'
        if isempty(state.solverState)
            [signal, state.solverState] = exp_eval_optimized(flt_loreta(                    ...
                                        'signal',signal,                ...
                                        invMethod,                      ...
                                        'state',state.solverState,      ...
                                        'K',state.leadFieldMatrix,      ...
                                        'L',state.laplacianOperator,    ...
                                        'verb',verb,'arg_direct',true));
        else
            [signal, state.solverState] = hlp_scope({'disable_expressions',true}, ...
                                        @flt_loreta,                    ...
                                        'signal',signal,                ...
                                        invMethod,                      ...
                                        'state',state.solverState,      ...
                                        'K',state.leadFieldMatrix,      ...
                                        'L',state.laplacianOperator,    ...
                                        'verb',verb,'arg_direct',true);
        end
        signal.srcweights = state.solverState.srcweights;
    case 'variational loreta'
        if isempty(state.solverState)
            [signal, state.solverState] = exp_eval_optimized(flt_vbloreta(                    ...
                                        'signal',signal,                ...
                                        invMethod,                      ...
                                        'state',state.solverState,      ...
                                        'K',state.leadFieldMatrix,      ...
                                        'L',state.laplacianOperator,    ...
                                        'verb',verb,'arg_direct',true));
        else
            [signal, state.solverState] = hlp_scope({'disable_expressions',true}, ...
                                        @flt_vbloreta,                  ...
                                        'signal',signal,                ...
                                        invMethod,                      ...
                                        'state',state.solverState,      ...
                                        'K',state.leadFieldMatrix,      ...
                                        'L',state.laplacianOperator,    ...
                                        'verb',verb,'arg_direct',true);
        end
        signal.srcweights = state.solverState.srcweights;
    otherwise
        error('flt_sourceLocalize:badInverseMethod','Invalid inverse method %s',invMethod.arg_selection);
end

% Collapse CSD within each ROI
% -------------------------------------------------------------------------
% FIXME: We may wish to replace avg with the surface integral over the ROI
% We can use numerical double integration i.e. quad2d() or more crudely:
% sum(signal.CSD(x,:)) * dx * dy;
% where dx, dy are the voxel x,y dimensions.
% If the csd is not constrained to the surface of a mesh, then we need to
% use triple integration i.e. triplequad(). Or
% sum(signal.CSD(x,:)) * dx * dy * dz

if ~strcmp(colRoiCsd,'none') && ~isempty(signal.srcpot)
    if verb
        fprintf('Computing %s CSD for each ROI \n', colRoiCsd); 
    end
    
    if keepFullCsd
        % store backup with all vertices
        signal.srcpot_all     = signal.srcpot;
        signal.srcweights_all = signal.srcweights;
    end
        
    % collapse current density
    signal.srcpot = hlp_colsrc(signal.srcpot,state.roiVerticesReduced,colRoiCsd);
    % collapse weights
    signal.srcweights = hlp_colsrc(signal.srcweights,state.roiVerticesReduced,colRoiCsd);
else
    signal.srcpot_all = [];
    signal.srcweights_all = [];
end


% Store additional outputs in signal
% -------------------------------------------------------------------------
if makeDipfitStruct
    signal.dipfit   = state.dipfit;
end
signal.roiLabels          = state.roiLabels;
signal.roiVertices        = state.roiVertices;
signal.roiVerticesReduced = state.roiVerticesReduced;

if do_transform
    signal.data = signal.srcpot;
    signal.nbchan = size(signal.data,1);
    signal.chanlocs = struct('labels',cellfun(@num2str,num2cell(1:signal.nbchan,1),'UniformOutput',false));
end
signal.hmObj = hmObj;
signal.leadFieldMatrix = state.leadFieldMatrix;

    
exp_endfun;



function state = build_state(hmObj,channels,sourceAtlasLabels,roiAtlasLabels,roiVertices,roiVerticesLabels,makeDipfitStruct,verb,chanlocs,combineROIs,appendROI)
% validate the head model and construct the source space

orilen = length(roiAtlasLabels);
[res ia] = intersect(roiAtlasLabels,sourceAtlasLabels);
roiAtlasLabels = roiAtlasLabels(sort(ia));  % FIXME: double-check this order
if length(roiAtlasLabels)~=orilen
    warn_once('BCILAB:AtlasLabelMismatch','Some elements of ROIAtlasLabels were not contained in SourceAtlasLabels. These were removed.');
end

% Validate Inputs
hmObj     = hlp_validateHeadModelObject(hmObj);
if isempty(hmObj)
    error('HeadModelObject was improperly defined. Exiting');
end
if ~isempty(roiVerticesLabels) && ~isempty(roiVertices) ...
        && length(roiVertices) ~= length(roiVerticesLabels)
    fprintf('WARNING: The number of ROI labels in ''roiVerticesLabels'' does not match the number of ROIs in ''roiVertices''. Reverting to generic labeling scheme {''ROI1'' ''ROI2'' ... ''ROIN''}.');
    roiVerticesLabels = [];
end


if verb
    fprintf('Initializing source reconstructor \n');
end

% Prune lead field matrix and laplacian operator
% to contain only regions of interest
% If there are no specific ROIs selected, this will "open" the
% surface mesh by removing a few vertices
% (the surface mesh cannot be a closed surface)
if verb
    fprintf('Constructing source space \n');
end
brainStructsToRemove = setdiff(unique(hmObj.atlas.label),sourceAtlasLabels);
[   reducedSpace,                      ...
    state.leadFieldMatrix,             ...
    state.laplacianOperator            ...
    state.rmIndices                          ...
    ] = getSourceSpace4PEB(hmObj,brainStructsToRemove,roiVertices);

% We also store the indices of the vertices of each ROI (in the full
% source space) in a cell array. This allows us to obtain dipole
% centroids for each ROI
for k=1:length(roiAtlasLabels)
    state.roiVertices{k} = indices4Structure(hmObj,roiAtlasLabels{k})';
    %         [~,state.roiVertices{k}] = removeStructureFromSourceSpace(hmObj,state.brainStructsToRemove{k});
end
% append any additional ROI defined by 'roiVertices' input argument
state.roiVertices = [state.roiVertices roiVertices];

% get ROI indices into reduced source space. These are used for
% integration over current source density (CSD) within each ROI
nvert   = length(hmObj.atlas.color);
LFMcols = 1:nvert;
LFMcols(state.rmIndices) = [];
for k=1:length(state.roiVertices)
    state.roiVerticesReduced{k} = find(ismember(LFMcols,state.roiVertices{k}));
end

% set up the labeling for any vertex-index-defined ROIs
if isempty(roiVerticesLabels) && ~isempty(roiVertices)
    % use generic labeling scheme {'ROI1' 'ROI2' ... 'ROIN'}
    roiVerticesLabels = cellstr(num2str((1:length(roiVertices))'))';
    roiVerticesLabels = cellfun(@(x)['ROI' x],roiVerticesLabels,'UniformOutput',false);
end
state.roiLabels = [roiAtlasLabels roiVerticesLabels];


% if needed, combine ROIs according to rules in combineROIs
if ~isempty(combineROIs)
    if mod(length(combineROIs),2)
        error('BCILAB:BadNameValuePair','CombineROI must be a cell array of name,value pairs');
    end
    newRoiLabels = combineROIs(1:2:end-1);
    roiSubLabels = combineROIs(2:2:end);
    numroi = length(newRoiLabels);
    newRoiVerticesReduced = cell(1,numroi);
    newRoiVertices        = cell(1,numroi);
    roiIdxInAtlas  = cell(1,numroi);
    for k=1:numroi
        matchedLabels = ismember(roiSubLabels{k},roiAtlasLabels);
        if ~all(matchedLabels)
            error('BCILAB:BadROINames', ...
                  'The following ROIs in ''CombineROIs'' are not in the ROIAtlasLabels list: %s', ...
                          hlp_tostring(roiSubLabels{k}(~matchedLabels)));
        end
        roiIdxInAtlas{k}  = find(ismember(roiAtlasLabels,roiSubLabels{k}));
        A = cell2mat(state.roiVerticesReduced(roiIdxInAtlas{k}));
        [tmp, idx] = unique(A);
        newRoiVerticesReduced{k} = A(sort(idx));
        % do the same for roiVertices
        A = cell2mat(state.roiVertices(roiIdxInAtlas{k}));
        [tmp, idx] = unique(A);
        newRoiVertices{k} = A(sort(idx));
    end
    
    if ~appendROI
        % remove all merged ROIs ...
        mergedROI = unique(cell2mat(roiIdxInAtlas));
        state.roiVerticesReduced(mergedROI) = [];
        state.roiVertices(mergedROI)        = [];
        state.roiLabels(mergedROI)          = [];
    end
    % ... and append the new ROIs
    state.roiVerticesReduced = [state.roiVerticesReduced newRoiVerticesReduced];
    state.roiVertices        = [state.roiVertices newRoiVertices];
    state.roiLabels          = [state.roiLabels newRoiLabels];
    
    
end


% prune the lead field matrix to contain only desired channels
hmChanlabels  = lower(hmObj.getChannelLabels());
if isempty(channels)
    channels = lower({chanlocs.labels});
end

% use only selected channels that are in the head model
chaninds = ismember(hmChanlabels,channels);
if nnz(chaninds)~=length(channels)
    error('Some channels could not be matched to the headmodel');
end
state.leadFieldMatrix = state.leadFieldMatrix(chaninds,:);

% load the original source space (non-reduced)
tmp = load(hmObj.surfaces);
fn  = fieldnames(tmp);
state.sourceSpace = tmp.(fn{1})(3);  % dim3 = cortical surface

% make dipfit structure containing centroids (dipfit.model.posxyz) and
% surface mesh (dipfit.model.surfmesh) for each ROI as well as complete
% surface mesh (dipfit.surfmesh). We also store the indices of each ROI
% into the complete surface mesh (dipfit.model.meshVertices)
if makeDipfitStruct
    state.dipfit = hlp_makeDipfitStruct(state.sourceSpace,state.roiVertices,reducedSpace);
end

% initialize the state of the solver
state.solverState = [];
